question,answer,contexts,ground_truth,context_precision,context_recall,faithfulness,answer_relevancy
Why are Functions so important?,"Functions are important because they hide detail and enable us to think at a higher level. They allow us to package computational ideas in a way that others can use them, making it easier to implement and understand complex processes. Functions also help achieve decomposition and abstraction in programming, making code more organized, coherent, and reusable.","[""4. Modules and Functions  \nTopics:  \n \n Modules  \n Using import \n Using functions from  math  \n A first look at defining functions  \n \n \n The Usual Idea of a Function  \n \n \n \n          sqrt \n \n 9 3 \nA factory that has inputs and builds outputs.  Why are Functions So Important?  \nOne reason is that they hide detail and  \nenable us to think at a higher level.  \n \nWho wants to think about how to \ncompute square roots in a calculation that  \ninvolves other more challenging things?  \n \nr = (sqrt(250+110* sqrt(5))/20)*E  The Process of Implementation  \nTo implement  a function is to package a  \ncomputational idea in a way that others  \ncan use it.  \n \nWe use the example of square root to  \nillustrate this.  It Starts with an Insight  \nThe act of computing the square root  \nof a number  x is equivalent to building a  \nsquare whose area is x.  \n \nIf you can build that square and measure  \nits side, then you have sqrt(x). Making a Given Rectangle  \n“More Square”  \nL  x/L = W  \nHow can we make this rectangle “ more square ”  \nwhile preserving its area?  Observation  \nIf the square and rectangle  have area x,  then  \nwe see that  the sqrt(x) is in between L and W . Recipe for an Improved L  \nL x/L \nL = (L+x/L)/2      \nx/L L \nTake the  \naverage of the  \nlength and width  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nIn comes x, the “raw material”.  \nA square root is fabricated and shipped.  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nHow do we make something like        in Python?  \n \nWe talk about “built in” functions first.      Talking About Functions  \nA function has a name and arguments.  \nm = max( x,y) \nname  arguments  \nWe say that   max(x,y) is a function call . Built-in Functions  \n \nThe list of “built -in” Python functions  is quite \nshort.  \n \nHere are some of the ones that require  \nnumerical arguments:  \n \n                  max,  min, abs, round  \n   \n \n \n abs(-6) is 6       max( -3,2) is 2       min(9, -7) is -7 \nround(6.3) is 6.0    round(3.5) is 4.0    round( -6.3) is -6.0  Calling  Functions  \n \n>>> a = 5  \n>>> b = 7  \n>>> m = max(a** b,b**a) \n>>> diff = abs( a**b–b**a)                   \n \nIn a function call, arguments can be expressions.  \nThus, the value of the expression  a**b–b**a \nis passed as an argument to abs. Functions in Mathematics vs \nFunctions in Python  \n \nSo far our examples look like the kind of  \nfunctions that we learn about in math.  \n \n “In comes one or more numbers and out  \n comes a number.”  \n \nHowever, the concept is more general in  \ncomputing as we will see throughout the course.  \n  \n \n >>> a = 5  \n>>> b = 6  \n>>> c = 7  \n>>> d = 8  \n>>> m = max(a** d,d**a,b**c,c**b) \n>>> n = max(a*b*c*d,500)  The Number of Arguments is  \nSometimes Allowed to Vary  \nThe max function can have an arbitrary number of arguments   The Built -In Function len \nA function can have a string argument.  >>> s = ‘ abcde’ \n>>> n = len(s) \n>>> print n  \n5 \n“In comes a string and out comes its length (as an int)”   Functions and Type  \nSometimes a function only accepts arguments of  \na certain type. E.g., you cannot pass an int \nvalue to the function len: \n>>> x = 10  \n>>> n = len(x) \nTypeError : Object of the type int \n                has no len() Functions and Type  \nOn the other hand, sometimes a function is  \ndesigned to be flexible regarding the type  \nof values it accepts:  \n>>> x = 10  \n>>> y = 7.0  \n>>> z = max( x,y) \nHere, max is returning the larger of two values  \nand it does not care if one has type int and the  \nother has type float.  Type -Conversion  Functions  \nThree important built -in functions convert types:  \nint, float , and str. \n \n >>> a = float(22)/float(7)  \n>>> a \n3.142857142857143  \n>>> b = int(100*a) \n>>> b \n314 \n>>> c = '100*pi = ' + str(b) \n>>> c \n'100*pi = 314'  \n        Some Obvious Functions are not \nin the “Core” Python Library!  \n>>> x = 9  \n>>> y = sqrt(x)""
 ""4. Modules and Functions  \nTopics:  \n \n Modules  \n Using import \n Using functions from  math  \n A first look at defining functions  \n \n \n The Usual Idea of a Function  \n \n \n \n          sqrt \n \n 9 3 \nA factory that has inputs and builds outputs.  Why are Functions So Important?  \nOne reason is that they hide detail and  \nenable us to think at a higher level.  \n \nWho wants to think about how to \ncompute square roots in a calculation that  \ninvolves other more challenging things?  \n \nr = (sqrt(250+110* sqrt(5))/20)*E  The Process of Implementation  \nTo implement  a function is to package a  \ncomputational idea in a way that others  \ncan use it.  \n \nWe use the example of square root to  \nillustrate this.  It Starts with an Insight  \nThe act of computing the square root  \nof a number  x is equivalent to building a  \nsquare whose area is x.  \n \nIf you can build that square and measure  \nits side, then you have sqrt(x). Making a Given Rectangle  \n“More Square”  \nL  x/L = W  \nHow can we make this rectangle “ more square ”  \nwhile preserving its area?  Observation  \nIf the square and rectangle  have area x,  then  \nwe see that  the sqrt(x) is in between L and W . Recipe for an Improved L  \nL x/L \nL = (L+x/L)/2      \nx/L L \nTake the  \naverage of the  \nlength and width  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nIn comes x, the “raw material”.  \nA square root is fabricated and shipped.  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nHow do we make something like        in Python?  \n \nWe talk about “built in” functions first.      Talking About Functions  \nA function has a name and arguments.  \nm = max( x,y) \nname  arguments  \nWe say that   max(x,y) is a function call . Built-in Functions  \n \nThe list of “built -in” Python functions  is quite \nshort.  \n \nHere are some of the ones that require  \nnumerical arguments:  \n \n                  max,  min, abs, round  \n   \n \n \n abs(-6) is 6       max( -3,2) is 2       min(9, -7) is -7 \nround(6.3) is 6.0    round(3.5) is 4.0    round( -6.3) is -6.0  Calling  Functions  \n \n>>> a = 5  \n>>> b = 7  \n>>> m = max(a** b,b**a) \n>>> diff = abs( a**b–b**a)                   \n \nIn a function call, arguments can be expressions.  \nThus, the value of the expression  a**b–b**a \nis passed as an argument to abs. Functions in Mathematics vs \nFunctions in Python  \n \nSo far our examples look like the kind of  \nfunctions that we learn about in math.  \n \n “In comes one or more numbers and out  \n comes a number.”  \n \nHowever, the concept is more general in  \ncomputing as we will see throughout the course.  \n  \n \n >>> a = 5  \n>>> b = 6  \n>>> c = 7  \n>>> d = 8  \n>>> m = max(a** d,d**a,b**c,c**b) \n>>> n = max(a*b*c*d,500)  The Number of Arguments is  \nSometimes Allowed to Vary  \nThe max function can have an arbitrary number of arguments   The Built -In Function len \nA function can have a string argument.  >>> s = ‘ abcde’ \n>>> n = len(s) \n>>> print n  \n5 \n“In comes a string and out comes its length (as an int)”   Functions and Type  \nSometimes a function only accepts arguments of  \na certain type. E.g., you cannot pass an int \nvalue to the function len: \n>>> x = 10  \n>>> n = len(x) \nTypeError : Object of the type int \n                has no len() Functions and Type  \nOn the other hand, sometimes a function is  \ndesigned to be flexible regarding the type  \nof values it accepts:  \n>>> x = 10  \n>>> y = 7.0  \n>>> z = max( x,y) \nHere, max is returning the larger of two values  \nand it does not care if one has type int and the  \nother has type float.  Type -Conversion  Functions  \nThree important built -in functions convert types:  \nint, float , and str. \n \n >>> a = float(22)/float(7)  \n>>> a \n3.142857142857143  \n>>> b = int(100*a) \n>>> b \n314 \n>>> c = '100*pi = ' + str(b) \n>>> c \n'100*pi = 314'  \n        Some Obvious Functions are not \nin the “Core” Python Library!  \n>>> x = 9  \n>>> y = sqrt(x)""
 ""4. Modules and Functions  \nTopics:  \n \n Modules  \n Using import \n Using functions from  math  \n A first look at defining functions  \n \n \n The Usual Idea of a Function  \n \n \n \n          sqrt \n \n 9 3 \nA factory that has inputs and builds outputs.  Why are Functions So Important?  \nOne reason is that they hide detail and  \nenable us to think at a higher level.  \n \nWho wants to think about how to \ncompute square roots in a calculation that  \ninvolves other more challenging things?  \n \nr = (sqrt(250+110* sqrt(5))/20)*E  The Process of Implementation  \nTo implement  a function is to package a  \ncomputational idea in a way that others  \ncan use it.  \n \nWe use the example of square root to  \nillustrate this.  It Starts with an Insight  \nThe act of computing the square root  \nof a number  x is equivalent to building a  \nsquare whose area is x.  \n \nIf you can build that square and measure  \nits side, then you have sqrt(x). Making a Given Rectangle  \n“More Square”  \nL  x/L = W  \nHow can we make this rectangle “ more square ”  \nwhile preserving its area?  Observation  \nIf the square and rectangle  have area x,  then  \nwe see that  the sqrt(x) is in between L and W . Recipe for an Improved L  \nL x/L \nL = (L+x/L)/2      \nx/L L \nTake the  \naverage of the  \nlength and width  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nIn comes x, the “raw material”.  \nA square root is fabricated and shipped.  Repeat and Package  \nx L L = x \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nL = (L+x/L)/2 \nHow do we make something like        in Python?  \n \nWe talk about “built in” functions first.      Talking About Functions  \nA function has a name and arguments.  \nm = max( x,y) \nname  arguments  \nWe say that   max(x,y) is a function call . Built-in Functions  \n \nThe list of “built -in” Python functions  is quite \nshort.  \n \nHere are some of the ones that require  \nnumerical arguments:  \n \n                  max,  min, abs, round  \n   \n \n \n abs(-6) is 6       max( -3,2) is 2       min(9, -7) is -7 \nround(6.3) is 6.0    round(3.5) is 4.0    round( -6.3) is -6.0  Calling  Functions  \n \n>>> a = 5  \n>>> b = 7  \n>>> m = max(a** b,b**a) \n>>> diff = abs( a**b–b**a)                   \n \nIn a function call, arguments can be expressions.  \nThus, the value of the expression  a**b–b**a \nis passed as an argument to abs. Functions in Mathematics vs \nFunctions in Python  \n \nSo far our examples look like the kind of  \nfunctions that we learn about in math.  \n \n “In comes one or more numbers and out  \n comes a number.”  \n \nHowever, the concept is more general in  \ncomputing as we will see throughout the course.  \n  \n \n >>> a = 5  \n>>> b = 6  \n>>> c = 7  \n>>> d = 8  \n>>> m = max(a** d,d**a,b**c,c**b) \n>>> n = max(a*b*c*d,500)  The Number of Arguments is  \nSometimes Allowed to Vary  \nThe max function can have an arbitrary number of arguments   The Built -In Function len \nA function can have a string argument.  >>> s = ‘ abcde’ \n>>> n = len(s) \n>>> print n  \n5 \n“In comes a string and out comes its length (as an int)”   Functions and Type  \nSometimes a function only accepts arguments of  \na certain type. E.g., you cannot pass an int \nvalue to the function len: \n>>> x = 10  \n>>> n = len(x) \nTypeError : Object of the type int \n                has no len() Functions and Type  \nOn the other hand, sometimes a function is  \ndesigned to be flexible regarding the type  \nof values it accepts:  \n>>> x = 10  \n>>> y = 7.0  \n>>> z = max( x,y) \nHere, max is returning the larger of two values  \nand it does not care if one has type int and the  \nother has type float.  Type -Conversion  Functions  \nThree important built -in functions convert types:  \nint, float , and str. \n \n >>> a = float(22)/float(7)  \n>>> a \n3.142857142857143  \n>>> b = int(100*a) \n>>> b \n314 \n>>> c = '100*pi = ' + str(b) \n>>> c \n'100*pi = 314'  \n        Some Obvious Functions are not \nin the “Core” Python Library!  \n>>> x = 9  \n>>> y = sqrt(x)""
 'DECOMPOSITION, \nABSTRACTION, \nFUNCTIONS\n(download slides and . pyfiles ĂŶĚ\x03 follow along!)\n6.0001 LECTURE 4\n6.0001 LECTURE 4 1LAST TIME\n\uf0a7while loops vs for loops\n\uf0a7should know how to write both kinds\n\uf0a7should know when to use them\n\uf0a7guess -and-check and approximation methods\n\uf0a7bisection method to speed up programs\n6.0001 LECTURE 4 2TODAY\n\uf0a7structuring programs and hiding details\n\uf0a7functions\n\uf0a7specifications\n\uf0a7keywords: return vs print\n\uf0a7scope\n6.0001 LECTURE 4 3HOW DO WE WRITE CODE?\n\uf0a7so far…\n•covered language mechanisms\n•know how to write different files for each computation\n•each file is some piece of code\n•each code is a sequence of instructions\n\uf0a7problems with this approach\n•easy for small -scale problems\n•messy for larger problems\n•hard to keep track of details\n•how do you know the right info is supplied to the right \npart of code\n6.0001 LECTURE 4 4GOOD PROGRAMMING\n\uf0a7more code not necessarily a good thing\n\uf0a7measure good programmers by the amount of \nfunctionality\n\uf0a7introduce functions\n\uf0a7mechanism to achieve decomposition and abstraction\n6.0001 LECTURE 4 5EXAMPLE –PROJECTOR\n\uf0a7a projector is a black box\n\uf0a7don’t know how it works\n\uf0a7know the interface: input/output\n\uf0a7connect any electronic to it that can communicate \nwith that input\n\uf0a7black box somehow converts image from input source \nto a wall, magnifying it\n\uf0a7ABSTRACTION IDEA : do not need to know how \nprojector works to use it\n6.0001 LECTURE 4 6EXAMPLE –PROJECTOR\n\uf0a7projecting large image for Olympics decomposed into \nseparate tasks for separate projectors\n\uf0a7each projector takes input and produces separate \noutput\n\uf0a7all projectors work together to produce larger image\n\uf0a7DECOMPOSITION IDEA : different devices work \ntogether to achieve an end goal\n6.0001 LECTURE 4 7APPLY THESE CONCEPTS\n6.0001 LECTURE 4 8TO PROGRAMMING!CREATE STRUCTURE with \nDECOMPOSITION\n6.0001 LECTURE 4 9\uf0a7in projector example, separate devices\n\uf0a7in programming, divide code into modules \n•are self-contained\n•used to break up code\n•intended to be reusable\n•keep code organized\n•keep code coherent\n\uf0a7this lecture, achieve decomposition with functions\n\uf0a7in a few weeks, achieve decomposition with classesSUPRESS DETAILS with \nABSTRACTION\n6.0001 LECTURE 4 10\uf0a7in projector example, instructions for how to use it are \nsufficient, no need to know how to build one\n\uf0a7in programming, think of a piece of code as a black box\n•cannot see details\n•do not need to see details\n•do not want to see details\n•hide tedious coding details\n\uf0a7achieve abstraction with function specifications or \ndocstringsFUNCTIONS\n\uf0a7write reusable pieces/chunks of code, called functions\n\uf0a7functions are not run in a program until they are \n“called ” or “ invoked ” in a program\n\uf0a7function characteristics:\n•has a name\n•has parameters (0 or more)\n•has a docstring (optional but recommended)\n•has a body\n•returns something\n6.0001 LECTURE 4 11defis_even( i):\n""""""\nInput: i, a positive int\nReturns True if iis even, otherwise False\n""""""\nprint(""inside is_even"")\nreturn i%2 == 0\nis_even(3)HOW TO WRITE and \nCALL/INVOKE A FUNCTION\n6.0001 LECTURE 4 12defis_even( i):\n"""""" \nInput: i, a positive int\nReturns True if iis even, otherwise False\n""""""\nprint(""inside is_even"")\nreturn i%2 == 0IN THE FUNCTION BODY\n6.0001 LECTURE 4 13deff( x ):\nx = x + 1\nprint(\'in f(x): x =\', x)\nreturn x\nx = 3\nz = f( x )\uf0a7formal parameter gets bound to the value of \nactual parameter when function is called \n\uf0a7new scope/frame/environment created when enter a function\n\uf0a7scope is mapping of names to objectsVARIABLE SCOPE\n6.0001 LECTURE 4 14deff( x ):\nx = x + 1\nprint(\'in f(x): x =\', x)\nreturn x\nx = 3\nz = f( x )VARIABLE SCOPE\n6.0001 LECTURE 4 15Global scope\nf\nx\nzSome \ncodef scope\nx3\n3VARIABLE SCOPE\n6.0001 LECTURE 4 16Global scope\nf\nx\nzSome \ncodef scope\nx4\n3deff( x ):\nx = x + 1\nprint(\'in f(x): x =\', x)\nreturn x\nx = 3\nz = f( x )VARIABLE SCOPE\n6.0001 LECTURE 4 17Global scope\nf\nx\nzSome \ncode\n3f scope\nx4deff( x ):\nx = x + 1\nprint(\'in f(x): x =\', x)\nreturn x\nx = 3\nz = f( x )returns 4VARIABLE SCOPE\n6.0001 LECTURE 4 18Global scope\nf\nx\nzSome \ncode\n3\n4deff( x ):\nx = x + 1']",One reason is that they hide detail and enable us to think at a higher level.,0.999999999975,1.0,1.0,0.9876793250981621
What are variable naming conventions?,"Variable naming conventions are rules that dictate how variables should be named in a programming language. In Python, variable names must be comprised of digits, uppercase letters, lowercase letters, and the underscore character ""_"". Additionally, variable names must begin with a letter or underscore. It is recommended to use short but suggestive names for variables that indicate their role or purpose.","['>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  20  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  30  After : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  130  \nt ->  30  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  160  \nt ->  30  After : Assignment vs Equations  \nIn algebra,  \n                           t = t +10  \n \ndoesn’t  make sense unless you believe  \n \n                           0 =t-t = 10  \n \nIn Python,  \n    t = t + 10  \n \nmeans add 10 to the value of t and store  \nthe result in t.  \n \n The Key 2 -Step Action Behind  \nEvery Assignment Statement  \n \n1.Evaluate the expression on the right hand  \n     side. \n \n2.Store the result in the variable named on the  \n     left hand side.  \n \n < variable name >  =  <  expression > Naming Variables  \nRule 1 . Name must be comprised of digits, upper \ncase letters, lower case letters, and the \nunderscore character  “_”  \n \nRule 2. Must begin with a letter or underscore  \n  \n>>> radius = 10  \n>>> Area = 3.14*radius**2                   \n \nradius ->  10  Area ->  314.0  \nA good name for a variable  is short but suggestive of its role:   Circle_Area   Precedence  \nQ.  In an arithmetic expression, what is  \n the order of evaluation?  \nA.  Exponentiation & negation comes before \n multiplication & division which in turn \n come before addition & subtraction.  \nIt is a good habit to use parentheses if there is the slightest ambiguity.  This:                        Is the same as:  \n  A + B*C         A + (B*C)  \n  -A**2/4         -(A**2)/4  \n  A*B/C*D        ((A*B)/C)*D  \n \n Revisit Circle Area  \nIt seems that Python evaluates (22/7) as \n3 instead of 3.142…  WHY?   \n>>> r = 10  \n>>> A = (22/7)*r**2  \n>>> print A  \n300.0                    \n \nA different kind of arithmetic. We have a related experience here.  \n11+3 = 2 in “clock arithmetic”  Integers and Decimals  \nIn math we distinguish between integer \nnumbers and decimal numbers.  \n \nInteger Numbers:    \n  100, 0, -89, 1234567  \n \nDecimal Numbers:  \n  -2.1, 100.01, 100.0, 12.345  \n \n Integers and Decimals  \n \nThere are different kinds of division.  \n \nInteger Division:    \n  30/8  is 3 with a remainder of 6  \n \nDecimal Division:  \n  30/8 is 3.75  \n \n int vs float \nIn Python, a number has a type. \n \nThe int type represents numbers as \nintegers.  \n \nThe float  type represents numbers as \ndecimals.  \n \n \n Important to understand the differences and the interactions  int Arithmetic  \nTo get the remainder, use %. Python “knows” that the values stored in x and y have \ntype int because there are no decimal points in those assignments.  >>> x = 30  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3 \n>>> r = x%y \n>>> print r  \n6                   \n float Arithmetic   \nPython “knows” that the values stored in x and y have type float because there are \ndecimal points in those assignments.  >>> x = 30.  \n>>> y = 8.  \n>>> q = x/y  \n>>> print q  \n3.75 \n Mixing float and int  \nIn Python if one operand has type float and the other has type int, then the type \nint value is converted to float and the evaluation proceeds.  >>> x = 30.  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3.75 \n Explicit Type Conversion   \n     int( -expression - ) converts the value of the expression to  int value  >>> x = 30.0  \n>>> y = 8.0  \n>>> q = int(x)/int(y) \n>>> print q  \n3 \n Explicit Type Conversion   \n     float( -expression - ) converts the value of the expression to a  float  >>> x = 30  \n>>> y = 8  \n>>> q = float(x)/float(y)  \n>>> print q  \n3.75 \n An Important Distinction   \n>>> x = 1.0/3.0  \n>>> print x  \n.333333333333  \n Integer arithmetic is exact.  \nFloat arithmetic is (usually) not exact.  Strings  \nSo far we have discussed computation with  \nnumbers.'
 '>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  20  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  30  After : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  130  \nt ->  30  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  160  \nt ->  30  After : Assignment vs Equations  \nIn algebra,  \n                           t = t +10  \n \ndoesn’t  make sense unless you believe  \n \n                           0 =t-t = 10  \n \nIn Python,  \n    t = t + 10  \n \nmeans add 10 to the value of t and store  \nthe result in t.  \n \n The Key 2 -Step Action Behind  \nEvery Assignment Statement  \n \n1.Evaluate the expression on the right hand  \n     side. \n \n2.Store the result in the variable named on the  \n     left hand side.  \n \n < variable name >  =  <  expression > Naming Variables  \nRule 1 . Name must be comprised of digits, upper \ncase letters, lower case letters, and the \nunderscore character  “_”  \n \nRule 2. Must begin with a letter or underscore  \n  \n>>> radius = 10  \n>>> Area = 3.14*radius**2                   \n \nradius ->  10  Area ->  314.0  \nA good name for a variable  is short but suggestive of its role:   Circle_Area   Precedence  \nQ.  In an arithmetic expression, what is  \n the order of evaluation?  \nA.  Exponentiation & negation comes before \n multiplication & division which in turn \n come before addition & subtraction.  \nIt is a good habit to use parentheses if there is the slightest ambiguity.  This:                        Is the same as:  \n  A + B*C         A + (B*C)  \n  -A**2/4         -(A**2)/4  \n  A*B/C*D        ((A*B)/C)*D  \n \n Revisit Circle Area  \nIt seems that Python evaluates (22/7) as \n3 instead of 3.142…  WHY?   \n>>> r = 10  \n>>> A = (22/7)*r**2  \n>>> print A  \n300.0                    \n \nA different kind of arithmetic. We have a related experience here.  \n11+3 = 2 in “clock arithmetic”  Integers and Decimals  \nIn math we distinguish between integer \nnumbers and decimal numbers.  \n \nInteger Numbers:    \n  100, 0, -89, 1234567  \n \nDecimal Numbers:  \n  -2.1, 100.01, 100.0, 12.345  \n \n Integers and Decimals  \n \nThere are different kinds of division.  \n \nInteger Division:    \n  30/8  is 3 with a remainder of 6  \n \nDecimal Division:  \n  30/8 is 3.75  \n \n int vs float \nIn Python, a number has a type. \n \nThe int type represents numbers as \nintegers.  \n \nThe float  type represents numbers as \ndecimals.  \n \n \n Important to understand the differences and the interactions  int Arithmetic  \nTo get the remainder, use %. Python “knows” that the values stored in x and y have \ntype int because there are no decimal points in those assignments.  >>> x = 30  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3 \n>>> r = x%y \n>>> print r  \n6                   \n float Arithmetic   \nPython “knows” that the values stored in x and y have type float because there are \ndecimal points in those assignments.  >>> x = 30.  \n>>> y = 8.  \n>>> q = x/y  \n>>> print q  \n3.75 \n Mixing float and int  \nIn Python if one operand has type float and the other has type int, then the type \nint value is converted to float and the evaluation proceeds.  >>> x = 30.  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3.75 \n Explicit Type Conversion   \n     int( -expression - ) converts the value of the expression to  int value  >>> x = 30.0  \n>>> y = 8.0  \n>>> q = int(x)/int(y) \n>>> print q  \n3 \n Explicit Type Conversion   \n     float( -expression - ) converts the value of the expression to a  float  >>> x = 30  \n>>> y = 8  \n>>> q = float(x)/float(y)  \n>>> print q  \n3.75 \n An Important Distinction   \n>>> x = 1.0/3.0  \n>>> print x  \n.333333333333  \n Integer arithmetic is exact.  \nFloat arithmetic is (usually) not exact.  Strings  \nSo far we have discussed computation with  \nnumbers.'
 '>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  20  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n y ->  130  \nt ->  30  After : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  130  \nt ->  30  Before : Tracking Updates  \n>>> y = 100  \n>>> t = 10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t \n>>> t = t+10  \n>>> y = y+t                    \n y ->  160  \nt ->  30  After : Assignment vs Equations  \nIn algebra,  \n                           t = t +10  \n \ndoesn’t  make sense unless you believe  \n \n                           0 =t-t = 10  \n \nIn Python,  \n    t = t + 10  \n \nmeans add 10 to the value of t and store  \nthe result in t.  \n \n The Key 2 -Step Action Behind  \nEvery Assignment Statement  \n \n1.Evaluate the expression on the right hand  \n     side. \n \n2.Store the result in the variable named on the  \n     left hand side.  \n \n < variable name >  =  <  expression > Naming Variables  \nRule 1 . Name must be comprised of digits, upper \ncase letters, lower case letters, and the \nunderscore character  “_”  \n \nRule 2. Must begin with a letter or underscore  \n  \n>>> radius = 10  \n>>> Area = 3.14*radius**2                   \n \nradius ->  10  Area ->  314.0  \nA good name for a variable  is short but suggestive of its role:   Circle_Area   Precedence  \nQ.  In an arithmetic expression, what is  \n the order of evaluation?  \nA.  Exponentiation & negation comes before \n multiplication & division which in turn \n come before addition & subtraction.  \nIt is a good habit to use parentheses if there is the slightest ambiguity.  This:                        Is the same as:  \n  A + B*C         A + (B*C)  \n  -A**2/4         -(A**2)/4  \n  A*B/C*D        ((A*B)/C)*D  \n \n Revisit Circle Area  \nIt seems that Python evaluates (22/7) as \n3 instead of 3.142…  WHY?   \n>>> r = 10  \n>>> A = (22/7)*r**2  \n>>> print A  \n300.0                    \n \nA different kind of arithmetic. We have a related experience here.  \n11+3 = 2 in “clock arithmetic”  Integers and Decimals  \nIn math we distinguish between integer \nnumbers and decimal numbers.  \n \nInteger Numbers:    \n  100, 0, -89, 1234567  \n \nDecimal Numbers:  \n  -2.1, 100.01, 100.0, 12.345  \n \n Integers and Decimals  \n \nThere are different kinds of division.  \n \nInteger Division:    \n  30/8  is 3 with a remainder of 6  \n \nDecimal Division:  \n  30/8 is 3.75  \n \n int vs float \nIn Python, a number has a type. \n \nThe int type represents numbers as \nintegers.  \n \nThe float  type represents numbers as \ndecimals.  \n \n \n Important to understand the differences and the interactions  int Arithmetic  \nTo get the remainder, use %. Python “knows” that the values stored in x and y have \ntype int because there are no decimal points in those assignments.  >>> x = 30  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3 \n>>> r = x%y \n>>> print r  \n6                   \n float Arithmetic   \nPython “knows” that the values stored in x and y have type float because there are \ndecimal points in those assignments.  >>> x = 30.  \n>>> y = 8.  \n>>> q = x/y  \n>>> print q  \n3.75 \n Mixing float and int  \nIn Python if one operand has type float and the other has type int, then the type \nint value is converted to float and the evaluation proceeds.  >>> x = 30.  \n>>> y = 8  \n>>> q = x/y  \n>>> print q  \n3.75 \n Explicit Type Conversion   \n     int( -expression - ) converts the value of the expression to  int value  >>> x = 30.0  \n>>> y = 8.0  \n>>> q = int(x)/int(y) \n>>> print q  \n3 \n Explicit Type Conversion   \n     float( -expression - ) converts the value of the expression to a  float  >>> x = 30  \n>>> y = 8  \n>>> q = float(x)/float(y)  \n>>> print q  \n3.75 \n An Important Distinction   \n>>> x = 1.0/3.0  \n>>> print x  \n.333333333333  \n Integer arithmetic is exact.  \nFloat arithmetic is (usually) not exact.  Strings  \nSo far we have discussed computation with  \nnumbers.'
 ""1 \nIntroduction to Programming  \nwith Python  \nPython Review. Modified slides from Marty Stepp  and Moshe Goldstein  2 \uf06ecode or source code : The sequence of instructions in a program.  \n \n\uf06esyntax : The set of legal structures and commands that can be \nused in a particular programming language.  \n \n\uf06eoutput : The messages printed to the user by a program.  \n \n\uf06econsole : The text box onto which output is printed.  \n\uf06eSome source code editors pop up the console as an external window, \nand others contain their own console window.  \nProgramming basics  \n3 Compiling and interpreting  \n\uf06eMany languages require you to compile (translate) your program \ninto a form that the machine understands.  \n \n \n \n \n \n \n \n\uf06ePython is instead directly interpreted into machine instructions.   compile  execute  \noutput  \n source code  \nHello.java  \n byte code  \nHello.class  \n \n interpret  \noutput  \n source code  \nHello.py  \nThe Python Interpreter  \n•Python is an interpreted \nlanguage  \n•The interpreter provides \nan interactive environment \nto play with the language  \n•Results of expressions are \nprinted on the screen  >>> 3 + 7  \n10 \n>>> 3 < 15  \nTrue \n>>> 'print me'  \n'print me'  \n>>> print 'print me'  \nprint me  \n>>>  5 Expressions  \n\uf06eexpression : A data value or set of operations to compute a value.  \n Examples:  1 + 4 * 3  \n    42 \n \n\uf06eArithmetic operators we will use:  \n\uf06e+ - * /  addition, subtraction/negation, multiplication, division  \n\uf06e%    modulus, a.k.a. remainder  \n\uf06e**   exponentiation  \n \n\uf06eprecedence : Order in which operations are computed.  \n\uf06e* / % **  have a higher precedence than + - \n \n1 + 3 * 4  is 13 \n \n\uf06eParentheses can be used to force a certain order of evaluation.  \n \n(1 + 3) * 4  is 16 6 Integer division  \n\uf06eWhen we divide integers with / , the quotient is also an integer.  \n \n        3                      52 \n   4 ) 14               27 ) 1425  \n       12                    135 \n        2                      75  \n                               54 \n                               21 \n \n\uf06eMore examples:  \n\uf06e35 / 5   is  7 \n\uf06e84 / 10   is  8 \n\uf06e156 / 100   is  1 \n \n\uf06eThe % operator computes the remainder from a division of integers.  \n \n        3                        43 \n   4 ) 14                   5 ) 218  \n       12                       20 \n        2                        18 \n                                 15 \n                                  3 7 Real numbers  \n\uf06ePython can also manipulate real numbers.  \n\uf06eExamples: 6.022  -15.9997  42.0 2.143e17  \n \n\uf06eThe operators + - * / % **  ( ) all work for real numbers.  \n\uf06eThe / produces an exact answer: 15.0 / 2.0  is 7.5 \n\uf06eThe same rules of precedence also apply to real numbers:  \nEvaluate  ( )  before  * / %  before  + - \n \n\uf06eWhen integers and reals are mixed, the result is a real number.  \n\uf06eExample:  1 / 2.0   is  0.5 \n \n\uf06eThe conversion occurs on a per -operator basis.  \n\uf06e7 / 3 * 1.2 + 3 / 2  \n\uf06e  2   * 1.2 + 3 / 2 \n\uf06e    2.4     + 3 / 2 \n\uf06e    2.4     +   1 \n\uf06e         3.4 8 Math commands  \n\uf06ePython has useful commands  (or called functions)  for performing \ncalculations.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\uf06eTo use many of these commands, you must write the following at \nthe top of your Python program:  \nfrom math import *  Command name  Description  \nabs(value) absolute value  \nceil( value) rounds up  \ncos(value) cosine, in radians  \nfloor( value) rounds down  \nlog(value) logarithm, base e \nlog10( value) logarithm, base 10  \nmax(value1, value2) larger of two values  \nmin(value1, value2) smaller of two values  \nround( value) nearest whole number  \nsin(value) sine, in radians  \nsqrt( value) square root  Constant  Description  \ne 2.7182818...  \npi 3.1415926...  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 10 Variables  \n\uf06evariable : A named piece of memory that can store a value.  \n\uf06eUsage:""]","Variables must have a name to be used Your names must always start with a letter or underscore, but they can only contain these types characters Letters (capital and lowercase) Numbers Underscores. Python contains some reserved keywords valuable to the functionality of Python ○ Your variable name cannot be a Python keyword ■ It can contain a keyword (valid: className), but it cannot be solely the keyword (invalid: class) ● Have descriptive variable names (give a hint what it will be used for)",0.999999999975,1.0,1.0,0.9630158289590481
why coding convention is essiential and what is a good coding convention?,"Coding convention is essential because it helps maintain consistency, readability, and maintainability of the code. A good coding convention includes writing clear and descriptive variable and function names, using consistent indentation, following a consistent naming convention, commenting code effectively, and adhering to a style guide such as PEP 8 for Python. By following a good coding convention, developers can easily understand and collaborate on the code, leading to better quality software.","['TESTING, DEBUGGING, \nEXCEPTIONS, ASSERTIONS\n(download slides and . pyfiles and follow along!)\n6.0001 LECTURE 7\n6.0001 LECTURE 7 1WE AIM FOR HIGH QUALITY –\nAN ANALOGY WITH SOUP\nYou are making soup but bugs keep falling in from the \nceiling. What do you do?\n\uf0a7check soup for bugs\n•testing\n\uf0a7keep lid closed\n•defensive \nprogramming\n\uf0a7clean kitchen\n•eliminate source \nof bugs\nAnalogy thanks to Prof Srini Devadas\n6.0001 LECTURE 7 2DEFENSIVE PROGRAMMING\n•Write specifications for functions\n•Modularize programs\n•Check conditions on inputs/outputs (assertions)\nTESTING/VALIDATION\n•Compare input/output \npairs to specification\n•“It’s not working!”\n•“How can I break my \nprogram?”DEBUGGING\n•Study events leading up \nto an error\n•“Why is it not working?”\n•“How can I fix my \nprogram?”\n6.0001 LECTURE 7 3SET YOURSELF UP FOR EASY \nTESTING AND DEBUGGING\n\uf0a7from the start , design code to ease this part\n\uf0a7break program up into modules that can be tested \nand debugged individually\n\uf0a7document constraints on modules\n•what do you expect the input to be?\n•what do you expect the output to be?\n\uf0a7document assumptions behind code design\n6.0001 LECTURE 7 4WHEN ARE YOU READY TO \nTEST?\n\uf0a7ensure code runs\n•remove syntax errors\n•remove static semantic errors\n•Python interpreter can usually find these for you\n\uf0a7have a set of expected results\n•an input set\n•for each input, the expected output\n6.0001 LECTURE 7 5CLASSES OF TESTS\n\uf0a7Unit testing\n•validate each piece of program\n•testing each function separately\n\uf0a7Regression testing\n•add test for bugs as you find them\n•catch reintroduced errors that were previously fixed\n\uf0a7Integration testing\n•does overall program work?\n•tend to rush to do this\n6.0001 LECTURE 7 6TESTING APPROACHES\n\uf0a7intuition about natural boundaries to the problem\ndefis_bigger (x, y):\n"""""" Assumes x and y are ints\nReturns True if y is less than x, else False """"""\n•can you come up with some natural partitions?\n\uf0a7if no natural partitions, might do random testing\n•probability that code is correct increases with more tests\n•better options below\n\uf0a7black box testing\n•explore paths through specification\n\uf0a7glass box testing\n•explore paths through code\n6.0001 LECTURE 7 7defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""\n\uf0a7designed without looking at the code\n\uf0a7can be done by someone other than the implementer to \navoid some implementer biases\n\uf0a7testing can be reused if implementation changes\n\uf0a7paths through specification \n•build test cases in different natural space partitions\n•also consider boundary conditions (empty lists, singleton \nlist, large numbers, small numbers)BLACK BOX TESTING\n6.0001 LECTURE 7 8defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""BLACK BOX TESTING\n6.0001 LECTURE 7 9CASE x eps\nboundary 0 0.0001\nperfect square 25 0.0001\nless than 1 0.05 0.0001\nirrational square root 2 0.0001\nextremes 2 1.0/2.0**64.0\nextremes 1.0/2.0**64.0 1.0/2.0**64.0\nextremes 2.0**64.0     1.0/2.0**64.0\nextremes 1.0/2.0**64.0 2.0**64.0\nextremes 2.0**64.0     2.0**64.0GLASS BOX TESTING\n\uf0a7use code directly to guide design of test cases \n\uf0a7called path -complete if every potential path through \ncode is tested at least once\n\uf0a7what are some drawbacks of this type of testing?\n•can go through loops arbitrarily many times\n•missing paths\n\uf0a7guidelines \n•branches\n•for loops\n•while loops\n6.0001 LECTURE 7 10GLASS BOX TESTING\ndefabs(x):\n"""""" Assumes x is an int\nReturns x if x>=0 and –x otherwise """"""\nif x < -1:\nreturn –x\nelse:\nreturn x\n\uf0a7a path -complete test suite could miss a bug\n\uf0a7path -complete test suite: 2 and -2\n\uf0a7but abs( -1) incorrectly returns -1\n\uf0a7should still test boundary cases\n6.0001 LECTURE 7 11DEBUGGING\n\uf0a7steep learning curve\n\uf0a7goal is to have a bug -free program\n\uf0a7tools\n•built in to IDLE and Anaconda\n•Python Tutor\n•print statement\n•use your brain, be systematic in your hunt\n6.0001 LECTURE 7 12PRINT STATEMENTS\n\uf0a7good way to test hypothesis\n\uf0a7when to print\n•enter function\n•parameters\n•function results'
 'TESTING, DEBUGGING, \nEXCEPTIONS, ASSERTIONS\n(download slides and . pyfiles and follow along!)\n6.0001 LECTURE 7\n6.0001 LECTURE 7 1WE AIM FOR HIGH QUALITY –\nAN ANALOGY WITH SOUP\nYou are making soup but bugs keep falling in from the \nceiling. What do you do?\n\uf0a7check soup for bugs\n•testing\n\uf0a7keep lid closed\n•defensive \nprogramming\n\uf0a7clean kitchen\n•eliminate source \nof bugs\nAnalogy thanks to Prof Srini Devadas\n6.0001 LECTURE 7 2DEFENSIVE PROGRAMMING\n•Write specifications for functions\n•Modularize programs\n•Check conditions on inputs/outputs (assertions)\nTESTING/VALIDATION\n•Compare input/output \npairs to specification\n•“It’s not working!”\n•“How can I break my \nprogram?”DEBUGGING\n•Study events leading up \nto an error\n•“Why is it not working?”\n•“How can I fix my \nprogram?”\n6.0001 LECTURE 7 3SET YOURSELF UP FOR EASY \nTESTING AND DEBUGGING\n\uf0a7from the start , design code to ease this part\n\uf0a7break program up into modules that can be tested \nand debugged individually\n\uf0a7document constraints on modules\n•what do you expect the input to be?\n•what do you expect the output to be?\n\uf0a7document assumptions behind code design\n6.0001 LECTURE 7 4WHEN ARE YOU READY TO \nTEST?\n\uf0a7ensure code runs\n•remove syntax errors\n•remove static semantic errors\n•Python interpreter can usually find these for you\n\uf0a7have a set of expected results\n•an input set\n•for each input, the expected output\n6.0001 LECTURE 7 5CLASSES OF TESTS\n\uf0a7Unit testing\n•validate each piece of program\n•testing each function separately\n\uf0a7Regression testing\n•add test for bugs as you find them\n•catch reintroduced errors that were previously fixed\n\uf0a7Integration testing\n•does overall program work?\n•tend to rush to do this\n6.0001 LECTURE 7 6TESTING APPROACHES\n\uf0a7intuition about natural boundaries to the problem\ndefis_bigger (x, y):\n"""""" Assumes x and y are ints\nReturns True if y is less than x, else False """"""\n•can you come up with some natural partitions?\n\uf0a7if no natural partitions, might do random testing\n•probability that code is correct increases with more tests\n•better options below\n\uf0a7black box testing\n•explore paths through specification\n\uf0a7glass box testing\n•explore paths through code\n6.0001 LECTURE 7 7defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""\n\uf0a7designed without looking at the code\n\uf0a7can be done by someone other than the implementer to \navoid some implementer biases\n\uf0a7testing can be reused if implementation changes\n\uf0a7paths through specification \n•build test cases in different natural space partitions\n•also consider boundary conditions (empty lists, singleton \nlist, large numbers, small numbers)BLACK BOX TESTING\n6.0001 LECTURE 7 8defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""BLACK BOX TESTING\n6.0001 LECTURE 7 9CASE x eps\nboundary 0 0.0001\nperfect square 25 0.0001\nless than 1 0.05 0.0001\nirrational square root 2 0.0001\nextremes 2 1.0/2.0**64.0\nextremes 1.0/2.0**64.0 1.0/2.0**64.0\nextremes 2.0**64.0     1.0/2.0**64.0\nextremes 1.0/2.0**64.0 2.0**64.0\nextremes 2.0**64.0     2.0**64.0GLASS BOX TESTING\n\uf0a7use code directly to guide design of test cases \n\uf0a7called path -complete if every potential path through \ncode is tested at least once\n\uf0a7what are some drawbacks of this type of testing?\n•can go through loops arbitrarily many times\n•missing paths\n\uf0a7guidelines \n•branches\n•for loops\n•while loops\n6.0001 LECTURE 7 10GLASS BOX TESTING\ndefabs(x):\n"""""" Assumes x is an int\nReturns x if x>=0 and –x otherwise """"""\nif x < -1:\nreturn –x\nelse:\nreturn x\n\uf0a7a path -complete test suite could miss a bug\n\uf0a7path -complete test suite: 2 and -2\n\uf0a7but abs( -1) incorrectly returns -1\n\uf0a7should still test boundary cases\n6.0001 LECTURE 7 11DEBUGGING\n\uf0a7steep learning curve\n\uf0a7goal is to have a bug -free program\n\uf0a7tools\n•built in to IDLE and Anaconda\n•Python Tutor\n•print statement\n•use your brain, be systematic in your hunt\n6.0001 LECTURE 7 12PRINT STATEMENTS\n\uf0a7good way to test hypothesis\n\uf0a7when to print\n•enter function\n•parameters\n•function results'
 'TESTING, DEBUGGING, \nEXCEPTIONS, ASSERTIONS\n(download slides and . pyfiles and follow along!)\n6.0001 LECTURE 7\n6.0001 LECTURE 7 1WE AIM FOR HIGH QUALITY –\nAN ANALOGY WITH SOUP\nYou are making soup but bugs keep falling in from the \nceiling. What do you do?\n\uf0a7check soup for bugs\n•testing\n\uf0a7keep lid closed\n•defensive \nprogramming\n\uf0a7clean kitchen\n•eliminate source \nof bugs\nAnalogy thanks to Prof Srini Devadas\n6.0001 LECTURE 7 2DEFENSIVE PROGRAMMING\n•Write specifications for functions\n•Modularize programs\n•Check conditions on inputs/outputs (assertions)\nTESTING/VALIDATION\n•Compare input/output \npairs to specification\n•“It’s not working!”\n•“How can I break my \nprogram?”DEBUGGING\n•Study events leading up \nto an error\n•“Why is it not working?”\n•“How can I fix my \nprogram?”\n6.0001 LECTURE 7 3SET YOURSELF UP FOR EASY \nTESTING AND DEBUGGING\n\uf0a7from the start , design code to ease this part\n\uf0a7break program up into modules that can be tested \nand debugged individually\n\uf0a7document constraints on modules\n•what do you expect the input to be?\n•what do you expect the output to be?\n\uf0a7document assumptions behind code design\n6.0001 LECTURE 7 4WHEN ARE YOU READY TO \nTEST?\n\uf0a7ensure code runs\n•remove syntax errors\n•remove static semantic errors\n•Python interpreter can usually find these for you\n\uf0a7have a set of expected results\n•an input set\n•for each input, the expected output\n6.0001 LECTURE 7 5CLASSES OF TESTS\n\uf0a7Unit testing\n•validate each piece of program\n•testing each function separately\n\uf0a7Regression testing\n•add test for bugs as you find them\n•catch reintroduced errors that were previously fixed\n\uf0a7Integration testing\n•does overall program work?\n•tend to rush to do this\n6.0001 LECTURE 7 6TESTING APPROACHES\n\uf0a7intuition about natural boundaries to the problem\ndefis_bigger (x, y):\n"""""" Assumes x and y are ints\nReturns True if y is less than x, else False """"""\n•can you come up with some natural partitions?\n\uf0a7if no natural partitions, might do random testing\n•probability that code is correct increases with more tests\n•better options below\n\uf0a7black box testing\n•explore paths through specification\n\uf0a7glass box testing\n•explore paths through code\n6.0001 LECTURE 7 7defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""\n\uf0a7designed without looking at the code\n\uf0a7can be done by someone other than the implementer to \navoid some implementer biases\n\uf0a7testing can be reused if implementation changes\n\uf0a7paths through specification \n•build test cases in different natural space partitions\n•also consider boundary conditions (empty lists, singleton \nlist, large numbers, small numbers)BLACK BOX TESTING\n6.0001 LECTURE 7 8defsqrt(x, eps):\n"""""" Assumes x, eps floats, x >= 0, eps > 0\nReturns res such that x -eps <= res*res <= x+eps""""""BLACK BOX TESTING\n6.0001 LECTURE 7 9CASE x eps\nboundary 0 0.0001\nperfect square 25 0.0001\nless than 1 0.05 0.0001\nirrational square root 2 0.0001\nextremes 2 1.0/2.0**64.0\nextremes 1.0/2.0**64.0 1.0/2.0**64.0\nextremes 2.0**64.0     1.0/2.0**64.0\nextremes 1.0/2.0**64.0 2.0**64.0\nextremes 2.0**64.0     2.0**64.0GLASS BOX TESTING\n\uf0a7use code directly to guide design of test cases \n\uf0a7called path -complete if every potential path through \ncode is tested at least once\n\uf0a7what are some drawbacks of this type of testing?\n•can go through loops arbitrarily many times\n•missing paths\n\uf0a7guidelines \n•branches\n•for loops\n•while loops\n6.0001 LECTURE 7 10GLASS BOX TESTING\ndefabs(x):\n"""""" Assumes x is an int\nReturns x if x>=0 and –x otherwise """"""\nif x < -1:\nreturn –x\nelse:\nreturn x\n\uf0a7a path -complete test suite could miss a bug\n\uf0a7path -complete test suite: 2 and -2\n\uf0a7but abs( -1) incorrectly returns -1\n\uf0a7should still test boundary cases\n6.0001 LECTURE 7 11DEBUGGING\n\uf0a7steep learning curve\n\uf0a7goal is to have a bug -free program\n\uf0a7tools\n•built in to IDLE and Anaconda\n•Python Tutor\n•print statement\n•use your brain, be systematic in your hunt\n6.0001 LECTURE 7 12PRINT STATEMENTS\n\uf0a7good way to test hypothesis\n\uf0a7when to print\n•enter function\n•parameters\n•function results'
 '\uf06eif/else  statement : Executes one block of statements if a certain \ncondition is True, and a second block of statements if it is False.  \n \n\uf06eSyntax:  \n if condition : \n     statements  \n else: \n     statements  \n \n\uf06eExample:  \n gpa = 1.4  \n if gpa > 2.0:  \n     print ""Welcome to Mars University!""  \n else: \n     print ""Your application is denied.""  \n \n\uf06eMultiple conditions can be chained with elif (""else if""):  \n if condition : \n     statements  \n elif condition : \n     statements  \n else: \n     statements  \n \nExample of If Statements  \nimport math  \nx = 30  \nif x <= 15 :  \n    y = x + 15  \nelif x <= 30  :  \n    y = x + 30  \nelse : \n    y = x  \nprint ‘y = ‘,  \nprint math.sin(y)  \nIn file ifstatement.py  >>> import ifstatement  \ny =  0.999911860107  \n>>>  \nIn interpreter  23 while  \n\uf06ewhile  loop: Executes a group of statements as long as a condition is True.  \n\uf06egood for indefinite loops (repeat an unknown number of times)  \n \n\uf06eSyntax:  \n while condition : \n     statements  \n \n\uf06eExample:  \n number = 1  \n while number < 200:  \n     print number,  \n     number = number * 2  \n \n\uf06eOutput:  \n 1 2 4 8 16 32 64 128  \nWhile Loops  \nx = 1  \nwhile  x < 10 :  \n    print x  \n    x = x + 1  >>> import whileloop  \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n>>> \uf06eIn whileloop.py  \n\uf06eIn interpreter  25 Logic  \n\uf06eMany logical expressions use relational operators : \n \n \n \n \n \n \n \n \n\uf06eLogical expressions can be combined with logical operators : \n \n \n \n \n \n\uf06eExercise: Write code to display and count the factors of a number.  Operator  Example  Result  \nand 9 != 6 and 2 < 3  True \nor 2 == 3 or -1 < 5 True \nnot not 7 > 0  False Operator  Meaning  Example  Result  \n== equals  1 + 1 == 2  True \n!= does not equal  3.2 != 2.5  True \n< less than  10 < 5 False \n> greater than  10 > 5 True \n<= less than or equal to  126 <= 100  False \n>= greater than or equal to  5.0 >= 5.0  True Loop Control Statements  \nbreak  Jumps out of the closest \nenclosing loop  \ncontinue  Jumps to the top of the closest \nenclosing loop  \npass Does nothing, empty statement \nplaceholder  More Examples For Loops  \n\uf06eSimilar to perl for loops, iterating through a \nlist of values  \n%python forloop1.py  \n1 \n7 \n13 \n2 for x in [1,7,13,2]:  \n    print x  forloop1.py   \n% python forloop2.py  \n0 \n1 \n2 \n3 \n4 for x in range(5) :  \n    print x  forloop2.py  \nrange(N) generates a list of numbers [0,1, …, n -1]  \n28 \nMore Data Types  Everything is an object  \n\uf06eEverything means \neverything, \nincluding functions  \nand classes  (more \non this later!)  \n\uf06eData type  is a \nproperty of the \nobject and not of \nthe variable  >>> x = 7  \n>>> x  \n7 \n>>> x = \'hello\'  \n>>> x  \n\'hello\'  \n>>>  \n Numbers: Integers  \n\uf06eInteger – the \nequivalent of a C long  \n\uf06eLong Integer – an \nunbounded integer \nvalue.  >>> 132224  \n132224  \n>>> 132323 ** \n2 \n17509376329L  \n>>>  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 Numbers: Complex  \n\uf06eBuilt into Python  \n\uf06eSame operations are \nsupported as integer \nand float  >>> x = 3 + 2j  \n>>> y = -1j \n>>> x + y  \n(3+1j)  \n>>> x * y  \n(2-3j) String Literals  \n\uf06e+ is overloaded to do \nconcatenation  >>> x = \'hello\'  \n>>> x = x + \' there\'  \n>>> x  \n\'hello there\'  \n String Literals  \n\uf06eCan use single or double quotes, and \nthree double quotes for a multi -line \nstring  \n>>> \'I am a string\'  \n\'I am a string\'  \n>>> ""So am I!""  \n\'So am I!\'  Substrings and Methods  \n>>> s = \'012345\'  \n>>> s[3]  \n\'3\' \n>>> s[1:4]  \n\'123\' \n>>> s[2:]  \n\'2345\'  \n>>> s[:4]  \n\'0123\'  \n>>> s[ -2] \n\'4\' • len(String) – returns the \nnumber of characters in \nthe String  \n \n• str(Object) – returns a \nString representation of \nthe Object  \n>>> len(x)  \n6 \n>>> \nstr(10.3)  \n\'10.3\'  String Formatting  \n\uf06eSimilar to C’s printf  \n\uf06e<formatted string> % <elements to \ninsert>  \n\uf06eCan usually just use %s for everything,']",Coding convention is essentially how someone writes code • Good coding convention dictates: • Good whitespace (blank lines between different sections of code) • Increases readability • Good commenting • Makes inheriting code easier for those involved • Makes looking at old code easier to follow • Boils down to a matter of opinion • Gets more apparent the more complicated the programs become.,0.999999999975,0.75,1.0,0.9462869252251696
Can you show me some syntax notes when using Python?,"Here are some syntax notes when using Python:
- Syntax refers to the set of legal structures and commands that can be used in a particular programming language.
- Python is directly interpreted into machine instructions, unlike languages that require compilation.
- Expressions in Python involve data values or operations to compute a value.
- Arithmetic operators in Python include +, -, *, /, %, and **.
- Precedence in Python dictates the order in which operations are computed.
- Parentheses can be used to force a certain order of evaluation in Python.
- Python can manipulate both integers and real numbers.
- Python has useful math commands and functions for performing calculations.
- Variables in Python are named pieces of memory that can store values.","[""1 \nIntroduction to Programming  \nwith Python  \nPython Review. Modified slides from Marty Stepp  and Moshe Goldstein  2 \uf06ecode or source code : The sequence of instructions in a program.  \n \n\uf06esyntax : The set of legal structures and commands that can be \nused in a particular programming language.  \n \n\uf06eoutput : The messages printed to the user by a program.  \n \n\uf06econsole : The text box onto which output is printed.  \n\uf06eSome source code editors pop up the console as an external window, \nand others contain their own console window.  \nProgramming basics  \n3 Compiling and interpreting  \n\uf06eMany languages require you to compile (translate) your program \ninto a form that the machine understands.  \n \n \n \n \n \n \n \n\uf06ePython is instead directly interpreted into machine instructions.   compile  execute  \noutput  \n source code  \nHello.java  \n byte code  \nHello.class  \n \n interpret  \noutput  \n source code  \nHello.py  \nThe Python Interpreter  \n•Python is an interpreted \nlanguage  \n•The interpreter provides \nan interactive environment \nto play with the language  \n•Results of expressions are \nprinted on the screen  >>> 3 + 7  \n10 \n>>> 3 < 15  \nTrue \n>>> 'print me'  \n'print me'  \n>>> print 'print me'  \nprint me  \n>>>  5 Expressions  \n\uf06eexpression : A data value or set of operations to compute a value.  \n Examples:  1 + 4 * 3  \n    42 \n \n\uf06eArithmetic operators we will use:  \n\uf06e+ - * /  addition, subtraction/negation, multiplication, division  \n\uf06e%    modulus, a.k.a. remainder  \n\uf06e**   exponentiation  \n \n\uf06eprecedence : Order in which operations are computed.  \n\uf06e* / % **  have a higher precedence than + - \n \n1 + 3 * 4  is 13 \n \n\uf06eParentheses can be used to force a certain order of evaluation.  \n \n(1 + 3) * 4  is 16 6 Integer division  \n\uf06eWhen we divide integers with / , the quotient is also an integer.  \n \n        3                      52 \n   4 ) 14               27 ) 1425  \n       12                    135 \n        2                      75  \n                               54 \n                               21 \n \n\uf06eMore examples:  \n\uf06e35 / 5   is  7 \n\uf06e84 / 10   is  8 \n\uf06e156 / 100   is  1 \n \n\uf06eThe % operator computes the remainder from a division of integers.  \n \n        3                        43 \n   4 ) 14                   5 ) 218  \n       12                       20 \n        2                        18 \n                                 15 \n                                  3 7 Real numbers  \n\uf06ePython can also manipulate real numbers.  \n\uf06eExamples: 6.022  -15.9997  42.0 2.143e17  \n \n\uf06eThe operators + - * / % **  ( ) all work for real numbers.  \n\uf06eThe / produces an exact answer: 15.0 / 2.0  is 7.5 \n\uf06eThe same rules of precedence also apply to real numbers:  \nEvaluate  ( )  before  * / %  before  + - \n \n\uf06eWhen integers and reals are mixed, the result is a real number.  \n\uf06eExample:  1 / 2.0   is  0.5 \n \n\uf06eThe conversion occurs on a per -operator basis.  \n\uf06e7 / 3 * 1.2 + 3 / 2  \n\uf06e  2   * 1.2 + 3 / 2 \n\uf06e    2.4     + 3 / 2 \n\uf06e    2.4     +   1 \n\uf06e         3.4 8 Math commands  \n\uf06ePython has useful commands  (or called functions)  for performing \ncalculations.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\uf06eTo use many of these commands, you must write the following at \nthe top of your Python program:  \nfrom math import *  Command name  Description  \nabs(value) absolute value  \nceil( value) rounds up  \ncos(value) cosine, in radians  \nfloor( value) rounds down  \nlog(value) logarithm, base e \nlog10( value) logarithm, base 10  \nmax(value1, value2) larger of two values  \nmin(value1, value2) smaller of two values  \nround( value) nearest whole number  \nsin(value) sine, in radians  \nsqrt( value) square root  Constant  Description  \ne 2.7182818...  \npi 3.1415926...  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 10 Variables  \n\uf06evariable : A named piece of memory that can store a value.  \n\uf06eUsage:""
 ""1 \nIntroduction to Programming  \nwith Python  \nPython Review. Modified slides from Marty Stepp  and Moshe Goldstein  2 \uf06ecode or source code : The sequence of instructions in a program.  \n \n\uf06esyntax : The set of legal structures and commands that can be \nused in a particular programming language.  \n \n\uf06eoutput : The messages printed to the user by a program.  \n \n\uf06econsole : The text box onto which output is printed.  \n\uf06eSome source code editors pop up the console as an external window, \nand others contain their own console window.  \nProgramming basics  \n3 Compiling and interpreting  \n\uf06eMany languages require you to compile (translate) your program \ninto a form that the machine understands.  \n \n \n \n \n \n \n \n\uf06ePython is instead directly interpreted into machine instructions.   compile  execute  \noutput  \n source code  \nHello.java  \n byte code  \nHello.class  \n \n interpret  \noutput  \n source code  \nHello.py  \nThe Python Interpreter  \n•Python is an interpreted \nlanguage  \n•The interpreter provides \nan interactive environment \nto play with the language  \n•Results of expressions are \nprinted on the screen  >>> 3 + 7  \n10 \n>>> 3 < 15  \nTrue \n>>> 'print me'  \n'print me'  \n>>> print 'print me'  \nprint me  \n>>>  5 Expressions  \n\uf06eexpression : A data value or set of operations to compute a value.  \n Examples:  1 + 4 * 3  \n    42 \n \n\uf06eArithmetic operators we will use:  \n\uf06e+ - * /  addition, subtraction/negation, multiplication, division  \n\uf06e%    modulus, a.k.a. remainder  \n\uf06e**   exponentiation  \n \n\uf06eprecedence : Order in which operations are computed.  \n\uf06e* / % **  have a higher precedence than + - \n \n1 + 3 * 4  is 13 \n \n\uf06eParentheses can be used to force a certain order of evaluation.  \n \n(1 + 3) * 4  is 16 6 Integer division  \n\uf06eWhen we divide integers with / , the quotient is also an integer.  \n \n        3                      52 \n   4 ) 14               27 ) 1425  \n       12                    135 \n        2                      75  \n                               54 \n                               21 \n \n\uf06eMore examples:  \n\uf06e35 / 5   is  7 \n\uf06e84 / 10   is  8 \n\uf06e156 / 100   is  1 \n \n\uf06eThe % operator computes the remainder from a division of integers.  \n \n        3                        43 \n   4 ) 14                   5 ) 218  \n       12                       20 \n        2                        18 \n                                 15 \n                                  3 7 Real numbers  \n\uf06ePython can also manipulate real numbers.  \n\uf06eExamples: 6.022  -15.9997  42.0 2.143e17  \n \n\uf06eThe operators + - * / % **  ( ) all work for real numbers.  \n\uf06eThe / produces an exact answer: 15.0 / 2.0  is 7.5 \n\uf06eThe same rules of precedence also apply to real numbers:  \nEvaluate  ( )  before  * / %  before  + - \n \n\uf06eWhen integers and reals are mixed, the result is a real number.  \n\uf06eExample:  1 / 2.0   is  0.5 \n \n\uf06eThe conversion occurs on a per -operator basis.  \n\uf06e7 / 3 * 1.2 + 3 / 2  \n\uf06e  2   * 1.2 + 3 / 2 \n\uf06e    2.4     + 3 / 2 \n\uf06e    2.4     +   1 \n\uf06e         3.4 8 Math commands  \n\uf06ePython has useful commands  (or called functions)  for performing \ncalculations.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\uf06eTo use many of these commands, you must write the following at \nthe top of your Python program:  \nfrom math import *  Command name  Description  \nabs(value) absolute value  \nceil( value) rounds up  \ncos(value) cosine, in radians  \nfloor( value) rounds down  \nlog(value) logarithm, base e \nlog10( value) logarithm, base 10  \nmax(value1, value2) larger of two values  \nmin(value1, value2) smaller of two values  \nround( value) nearest whole number  \nsin(value) sine, in radians  \nsqrt( value) square root  Constant  Description  \ne 2.7182818...  \npi 3.1415926...  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 10 Variables  \n\uf06evariable : A named piece of memory that can store a value.  \n\uf06eUsage:""
 ""1 \nIntroduction to Programming  \nwith Python  \nPython Review. Modified slides from Marty Stepp  and Moshe Goldstein  2 \uf06ecode or source code : The sequence of instructions in a program.  \n \n\uf06esyntax : The set of legal structures and commands that can be \nused in a particular programming language.  \n \n\uf06eoutput : The messages printed to the user by a program.  \n \n\uf06econsole : The text box onto which output is printed.  \n\uf06eSome source code editors pop up the console as an external window, \nand others contain their own console window.  \nProgramming basics  \n3 Compiling and interpreting  \n\uf06eMany languages require you to compile (translate) your program \ninto a form that the machine understands.  \n \n \n \n \n \n \n \n\uf06ePython is instead directly interpreted into machine instructions.   compile  execute  \noutput  \n source code  \nHello.java  \n byte code  \nHello.class  \n \n interpret  \noutput  \n source code  \nHello.py  \nThe Python Interpreter  \n•Python is an interpreted \nlanguage  \n•The interpreter provides \nan interactive environment \nto play with the language  \n•Results of expressions are \nprinted on the screen  >>> 3 + 7  \n10 \n>>> 3 < 15  \nTrue \n>>> 'print me'  \n'print me'  \n>>> print 'print me'  \nprint me  \n>>>  5 Expressions  \n\uf06eexpression : A data value or set of operations to compute a value.  \n Examples:  1 + 4 * 3  \n    42 \n \n\uf06eArithmetic operators we will use:  \n\uf06e+ - * /  addition, subtraction/negation, multiplication, division  \n\uf06e%    modulus, a.k.a. remainder  \n\uf06e**   exponentiation  \n \n\uf06eprecedence : Order in which operations are computed.  \n\uf06e* / % **  have a higher precedence than + - \n \n1 + 3 * 4  is 13 \n \n\uf06eParentheses can be used to force a certain order of evaluation.  \n \n(1 + 3) * 4  is 16 6 Integer division  \n\uf06eWhen we divide integers with / , the quotient is also an integer.  \n \n        3                      52 \n   4 ) 14               27 ) 1425  \n       12                    135 \n        2                      75  \n                               54 \n                               21 \n \n\uf06eMore examples:  \n\uf06e35 / 5   is  7 \n\uf06e84 / 10   is  8 \n\uf06e156 / 100   is  1 \n \n\uf06eThe % operator computes the remainder from a division of integers.  \n \n        3                        43 \n   4 ) 14                   5 ) 218  \n       12                       20 \n        2                        18 \n                                 15 \n                                  3 7 Real numbers  \n\uf06ePython can also manipulate real numbers.  \n\uf06eExamples: 6.022  -15.9997  42.0 2.143e17  \n \n\uf06eThe operators + - * / % **  ( ) all work for real numbers.  \n\uf06eThe / produces an exact answer: 15.0 / 2.0  is 7.5 \n\uf06eThe same rules of precedence also apply to real numbers:  \nEvaluate  ( )  before  * / %  before  + - \n \n\uf06eWhen integers and reals are mixed, the result is a real number.  \n\uf06eExample:  1 / 2.0   is  0.5 \n \n\uf06eThe conversion occurs on a per -operator basis.  \n\uf06e7 / 3 * 1.2 + 3 / 2  \n\uf06e  2   * 1.2 + 3 / 2 \n\uf06e    2.4     + 3 / 2 \n\uf06e    2.4     +   1 \n\uf06e         3.4 8 Math commands  \n\uf06ePython has useful commands  (or called functions)  for performing \ncalculations.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\uf06eTo use many of these commands, you must write the following at \nthe top of your Python program:  \nfrom math import *  Command name  Description  \nabs(value) absolute value  \nceil( value) rounds up  \ncos(value) cosine, in radians  \nfloor( value) rounds down  \nlog(value) logarithm, base e \nlog10( value) logarithm, base 10  \nmax(value1, value2) larger of two values  \nmin(value1, value2) smaller of two values  \nround( value) nearest whole number  \nsin(value) sine, in radians  \nsqrt( value) square root  Constant  Description  \ne 2.7182818...  \npi 3.1415926...  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 10 Variables  \n\uf06evariable : A named piece of memory that can store a value.  \n\uf06eUsage:""
 '\uf06eif/else  statement : Executes one block of statements if a certain \ncondition is True, and a second block of statements if it is False.  \n \n\uf06eSyntax:  \n if condition : \n     statements  \n else: \n     statements  \n \n\uf06eExample:  \n gpa = 1.4  \n if gpa > 2.0:  \n     print ""Welcome to Mars University!""  \n else: \n     print ""Your application is denied.""  \n \n\uf06eMultiple conditions can be chained with elif (""else if""):  \n if condition : \n     statements  \n elif condition : \n     statements  \n else: \n     statements  \n \nExample of If Statements  \nimport math  \nx = 30  \nif x <= 15 :  \n    y = x + 15  \nelif x <= 30  :  \n    y = x + 30  \nelse : \n    y = x  \nprint ‘y = ‘,  \nprint math.sin(y)  \nIn file ifstatement.py  >>> import ifstatement  \ny =  0.999911860107  \n>>>  \nIn interpreter  23 while  \n\uf06ewhile  loop: Executes a group of statements as long as a condition is True.  \n\uf06egood for indefinite loops (repeat an unknown number of times)  \n \n\uf06eSyntax:  \n while condition : \n     statements  \n \n\uf06eExample:  \n number = 1  \n while number < 200:  \n     print number,  \n     number = number * 2  \n \n\uf06eOutput:  \n 1 2 4 8 16 32 64 128  \nWhile Loops  \nx = 1  \nwhile  x < 10 :  \n    print x  \n    x = x + 1  >>> import whileloop  \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n>>> \uf06eIn whileloop.py  \n\uf06eIn interpreter  25 Logic  \n\uf06eMany logical expressions use relational operators : \n \n \n \n \n \n \n \n \n\uf06eLogical expressions can be combined with logical operators : \n \n \n \n \n \n\uf06eExercise: Write code to display and count the factors of a number.  Operator  Example  Result  \nand 9 != 6 and 2 < 3  True \nor 2 == 3 or -1 < 5 True \nnot not 7 > 0  False Operator  Meaning  Example  Result  \n== equals  1 + 1 == 2  True \n!= does not equal  3.2 != 2.5  True \n< less than  10 < 5 False \n> greater than  10 > 5 True \n<= less than or equal to  126 <= 100  False \n>= greater than or equal to  5.0 >= 5.0  True Loop Control Statements  \nbreak  Jumps out of the closest \nenclosing loop  \ncontinue  Jumps to the top of the closest \nenclosing loop  \npass Does nothing, empty statement \nplaceholder  More Examples For Loops  \n\uf06eSimilar to perl for loops, iterating through a \nlist of values  \n%python forloop1.py  \n1 \n7 \n13 \n2 for x in [1,7,13,2]:  \n    print x  forloop1.py   \n% python forloop2.py  \n0 \n1 \n2 \n3 \n4 for x in range(5) :  \n    print x  forloop2.py  \nrange(N) generates a list of numbers [0,1, …, n -1]  \n28 \nMore Data Types  Everything is an object  \n\uf06eEverything means \neverything, \nincluding functions  \nand classes  (more \non this later!)  \n\uf06eData type  is a \nproperty of the \nobject and not of \nthe variable  >>> x = 7  \n>>> x  \n7 \n>>> x = \'hello\'  \n>>> x  \n\'hello\'  \n>>>  \n Numbers: Integers  \n\uf06eInteger – the \nequivalent of a C long  \n\uf06eLong Integer – an \nunbounded integer \nvalue.  >>> 132224  \n132224  \n>>> 132323 ** \n2 \n17509376329L  \n>>>  Numbers: Floating Point  \n\uf06eint(x) converts x to \nan integer  \n\uf06efloat(x) converts x \nto a floating point  \n\uf06eThe interpreter \nshows  \na lot of digits  >>> 1.23232  \n1.2323200000000001  \n>>> print 1.23232  \n1.23232  \n>>> 1.3E7  \n13000000.0  \n>>> int(2.0)  \n2 \n>>> float(2)  \n2.0 Numbers: Complex  \n\uf06eBuilt into Python  \n\uf06eSame operations are \nsupported as integer \nand float  >>> x = 3 + 2j  \n>>> y = -1j \n>>> x + y  \n(3+1j)  \n>>> x * y  \n(2-3j) String Literals  \n\uf06e+ is overloaded to do \nconcatenation  >>> x = \'hello\'  \n>>> x = x + \' there\'  \n>>> x  \n\'hello there\'  \n String Literals  \n\uf06eCan use single or double quotes, and \nthree double quotes for a multi -line \nstring  \n>>> \'I am a string\'  \n\'I am a string\'  \n>>> ""So am I!""  \n\'So am I!\'  Substrings and Methods  \n>>> s = \'012345\'  \n>>> s[3]  \n\'3\' \n>>> s[1:4]  \n\'123\' \n>>> s[2:]  \n\'2345\'  \n>>> s[:4]  \n\'0123\'  \n>>> s[ -2] \n\'4\' • len(String) – returns the \nnumber of characters in \nthe String  \n \n• str(Object) – returns a \nString representation of \nthe Object  \n>>> len(x)  \n6 \n>>> \nstr(10.3)  \n\'10.3\'  String Formatting  \n\uf06eSimilar to C’s printf  \n\uf06e<formatted string> % <elements to \ninsert>  \n\uf06eCan usually just use %s for everything,']","Anything you want to directly print must be inside quotations • print(Hello World) will not work • You can print a blank line through print) • You can have compound print statements through two avenues: + and, • + and, must be outside of the quotations to work • + conjoins statements directly (no space between) • , adds a space between statements • Examples online may use Python version 2, which doesn't use parentheses in print statements • Python version 3 requires parentheses • If an example you find online doesn't work for you, check the version.",0.999999999975,1.0,1.0,0.9650419900644353
