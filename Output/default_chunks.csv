" 
1 
Introduction to Programming  
with Python  
Python Review. Modified slides from Marty Stepp  and Moshe Goldstein  2 code or source code : The sequence of instructions in a program.  
 
syntax : The set of legal structures and commands that can be 
used in a particular programming language.  
 
output : The messages printed to the user by a program.  
 
console : The text box onto which output is printed.  
Some source code editors pop up the console as an external window, 
and others contain their"
" own console window.  
Programming basics  
3 Compiling and interpreting  
Many languages require you to compile (translate) your program 
into a form that the machine understands.  
 
 
 
 
 
 
 
Python is instead directly interpreted into machine instructions.   compile  execute  
output  
 source code  
Hello.java  
 byte code  
Hello.class  
 
 interpret  
output  
 source code  
Hello.py  
The Python Interpreter  
•Python is an interpreted 
language  
•The interpreter provides 
an interactive environ"
"ment 
to play with the language  
•Results of expressions are 
printed on the screen  >>> 3 + 7  
10 
>>> 3 < 15  
True 
>>> 'print me'  
'print me'  
>>> print 'print me'  
print me  
>>>  5 Expressions  
expression : A data value or set of operations to compute a value.  
 Examples:  1 + 4 * 3  
    42 
 
Arithmetic operators we will use:  
+ - * /  addition, subtraction/negation, multiplication, division  
%    modulus, a.k.a. remainder  
**   exponentiation  
 
precedence : Order in which operatio"
"ns are computed.  
* / % **  have a higher precedence than + - 
 
1 + 3 * 4  is 13 
 
Parentheses can be used to force a certain order of evaluation.  
 
(1 + 3) * 4  is 16 6 Integer division  
When we divide integers with / , the quotient is also an integer.  
 
        3                      52 
   4 ) 14               27 ) 1425  
       12                    135 
        2                      75  
                               54 
                               21 
 
More examples:  
35 / 5   is  "
"7 
84 / 10   is  8 
156 / 100   is  1 
 
The % operator computes the remainder from a division of integers.  
 
        3                        43 
   4 ) 14                   5 ) 218  
       12                       20 
        2                        18 
                                 15 
                                  3 7 Real numbers  
Python can also manipulate real numbers.  
Examples: 6.022  -15.9997  42.0 2.143e17  
 
The operators + - * / % **  ( ) all work for real numbers.  
The / "
"produces an exact answer: 15.0 / 2.0  is 7.5 
The same rules of precedence also apply to real numbers:  
Evaluate  ( )  before  * / %  before  + - 
 
When integers and reals are mixed, the result is a real number.  
Example:  1 / 2.0   is  0.5 
 
The conversion occurs on a per -operator basis.  
7 / 3 * 1.2 + 3 / 2  
  2   * 1.2 + 3 / 2 
    2.4     + 3 / 2 
    2.4     +   1 
         3.4 8 Math commands  
Python has useful commands  (or called functions)  for performing 
calculations.  
 
 
 
 
"
" 
 
 
 
 
 
 
 
 
 
To use many of these commands, you must write the following at 
the top of your Python program:  
from math import *  Command name  Description  
abs(value) absolute value  
ceil( value) rounds up  
cos(value) cosine, in radians  
floor( value) rounds down  
log(value) logarithm, base e 
log10( value) logarithm, base 10  
max(value1, value2) larger of two values  
min(value1, value2) smaller of two values  
round( value) nearest whole number  
sin(value) sine, in radians  
sqrt( value) "
"square root  Constant  Description  
e 2.7182818...  
pi 3.1415926...  Numbers: Floating Point  
int(x) converts x to 
an integer  
float(x) converts x 
to a floating point  
The interpreter 
shows  
a lot of digits  >>> 1.23232  
1.2323200000000001  
>>> print 1.23232  
1.23232  
>>> 1.3E7  
13000000.0  
>>> int(2.0)  
2 
>>> float(2)  
2.0 10 Variables  
variable : A named piece of memory that can store a value.  
Usage:  
Compute an expression's result,  
store that result into a variable,  
and "
"use that variable later in the program.  
 
assignment statement : Stores a value into a variable.  
Syntax:  
 
  name = value 
 
Examples:  x = 5 
    gpa = 3.14  
 
     x   5         gpa    3.14  
 
A variable that has been given a value can be used in expressions.  
  x + 4  is 9 
 
Exercise: Evaluate the quadratic equation for a given a, b, and c. 
 
  Example  
>>> x = 7  
>>> x  
7 
>>> x+7  
14 
>>> x = 'hello'  
>>> x  
'hello'  
>>>  
 12 print  : Produces text output on the console.  
 
S"
"yntax:  
 print "" Message "" 
 print Expression  
Prints the given text message or expression value on the console, and 
moves the cursor down to the next line.  
 
 print Item1, Item2, ..., ItemN 
Prints several messages and/or expressions on the same line.  
 
Examples:  
 print ""Hello, world!""  
 age = 45  
 print ""You have"", 65 - age, ""years until retirement""  
 
Output:  
 
 Hello, world!  
 You have 20 years until retirement  print  Example: print Statement  
>>> print 'hello'  
hello 
>>> print 'he"
"llo', 'there'  
hello there  
 •Elements separated by 
commas print with a space 
between them  
•A comma at the end of the 
statement (print ‘hello’,) 
will not print a newline 
character  14 input  : Reads a number from user input.  
You can assign (store) the result of input  into a variable.  
Example:  
 age = input(""How old are you? "")  
 print ""Your age is"", age  
 print ""You have"", 65 - age, ""years until retirement""  
 
 Output:  
 
 How old are you? 53 
 Your age is 53  
 You have 12 years until"
" retirement  
 
 
 
Exercise: Write a Python program that prompts the user for 
his/her amount of money, then reports how many Nintendo Wiis 
the person can afford, and how much more money he/she will 
need to afford an additional Wii.  input Input: Example  
print ""What's your name?""  
name = raw_input(""> "")  
 
print ""What year were you born?""  
birthyear = int(raw_input(""> ""))  
 
print ""Hi “, name, “!”, “You are “, 2016 – birthyear  
% python input.py  
What's your name?  
> Michael  
What year were yo"
"u born?  
>1980  
Hi Michael! You are 31   
16 
Repetition (loops)  
and Selection (if/else)  17 The for loop 
for loop: Repeats a set of statements over a group of values.  
 
Syntax:  
 
 for variableName  in groupOfValues : 
     statements  
 
We indent the statements to be repeated with tabs or spaces.  
variableName  gives a name to each value, so you can refer to it in the statements . 
groupOfValues  can be a range of integers, specified with the range  function.  
 
Example:  
 
 for x in ran"
"ge(1, 6):  
     print x, ""squared is"", x * x  
 
 Output:  
 1 squared is 1  
 2 squared is 4  
 3 squared is 9  
 4 squared is 16  
 5 squared is 25  18 range 
The range  function specifies a range of integers:  
range( start, stop)  - the integers between start  (inclusive)  
      and stop (exclusive)  
 
It can also accept a third value specifying the change between values.  
range( start, stop, step) - the integers between start  (inclusive)  
      and stop (exclusive) by step 
 
Example:  
 for"
" x in range(5, 0, -1): 
     print x 
 print ""Blastoff!""  
 
 Output:  
 5 
 4 
 3  
 2 
 1 
 Blastoff!  
 
Exercise: How would we print the ""99 Bottles of Beer"" song?  19 Cumulative loops  
Some loops incrementally compute a value that is initialized outside 
the loop.  This is sometimes called a cumulative sum . 
 
 sum = 0 
 for i in range(1, 11):  
     sum = sum + (i * i)  
 print ""sum of first 10 squares is"", sum  
 
 Output: 
 sum of first 10 squares is 385  
 
 
 
Exercise: Write a Python program"
" that computes the factorial of an 
integer.  20 if 
if statement : Executes a group of statements only if a certain 
condition is true.  Otherwise, the statements are skipped.  
 
Syntax:  
 if condition : 
     statements  
 
Example:  
 gpa = 3.4  
 if gpa > 2.0:  
     print ""Your application is accepted.""  
21 
if/else 
if/else  statement : Executes one block of statements if a certain 
condition is True, and a second block of statements if it is False.  
 
Syntax:  
 if condition : 
     statemen"
"ts  
 else: 
     statements  
 
Example:  
 gpa = 1.4  
 if gpa > 2.0:  
     print ""Welcome to Mars University!""  
 else: 
     print ""Your application is denied.""  
 
Multiple conditions can be chained with elif (""else if""):  
 if condition : 
     statements  
 elif condition : 
     statements  
 else: 
     statements  
 
Example of If Statements  
import math  
x = 30  
if x <= 15 :  
    y = x + 15  
elif x <= 30  :  
    y = x + 30  
else : 
    y = x  
print ‘y = ‘,  
print math.sin(y)  
In file"
" ifstatement.py  >>> import ifstatement  
y =  0.999911860107  
>>>  
In interpreter  23 while  
while  loop: Executes a group of statements as long as a condition is True.  
good for indefinite loops (repeat an unknown number of times)  
 
Syntax:  
 while condition : 
     statements  
 
Example:  
 number = 1  
 while number < 200:  
     print number,  
     number = number * 2  
 
Output:  
 1 2 4 8 16 32 64 128  
While Loops  
x = 1  
while  x < 10 :  
    print x  
    x = x + 1  >>> import whil"
"eloop  
1 
2 
3 
4 
5 
6 
7 
8 
9 
>>> In whileloop.py  
In interpreter  25 Logic  
Many logical expressions use relational operators : 
 
 
 
 
 
 
 
 
Logical expressions can be combined with logical operators : 
 
 
 
 
 
Exercise: Write code to display and count the factors of a number.  Operator  Example  Result  
and 9 != 6 and 2 < 3  True 
or 2 == 3 or -1 < 5 True 
not not 7 > 0  False Operator  Meaning  Example  Result  
== equals  1 + 1 == 2  True 
!= does not equal  3.2 != 2.5  True 
< less t"
"han  10 < 5 False 
> greater than  10 > 5 True 
<= less than or equal to  126 <= 100  False 
>= greater than or equal to  5.0 >= 5.0  True Loop Control Statements  
break  Jumps out of the closest 
enclosing loop  
continue  Jumps to the top of the closest 
enclosing loop  
pass Does nothing, empty statement 
placeholder  More Examples For Loops  
Similar to perl for loops, iterating through a 
list of values  
%python forloop1.py  
1 
7 
13 
2 for x in [1,7,13,2]:  
    print x  forloop1.py   
% python fo"
"rloop2.py  
0 
1 
2 
3 
4 for x in range(5) :  
    print x  forloop2.py  
range(N) generates a list of numbers [0,1, …, n -1]  
28 
More Data Types  Everything is an object  
Everything means 
everything, 
including functions  
and classes  (more 
on this later!)  
Data type  is a 
property of the 
object and not of 
the variable  >>> x = 7  
>>> x  
7 
>>> x = 'hello'  
>>> x  
'hello'  
>>>  
 Numbers: Integers  
Integer – the 
equivalent of a C long  
Long Integer – an 
unbounded integer 
value.  >>"
"> 132224  
132224  
>>> 132323 ** 
2 
17509376329L  
>>>  Numbers: Floating Point  
int(x) converts x to 
an integer  
float(x) converts x 
to a floating point  
The interpreter 
shows  
a lot of digits  >>> 1.23232  
1.2323200000000001  
>>> print 1.23232  
1.23232  
>>> 1.3E7  
13000000.0  
>>> int(2.0)  
2 
>>> float(2)  
2.0 Numbers: Complex  
Built into Python  
Same operations are 
supported as integer 
and float  >>> x = 3 + 2j  
>>> y = -1j 
>>> x + y  
(3+1j)  
>>> x * y  
(2-3j) String Litera"
"ls  
+ is overloaded to do 
concatenation  >>> x = 'hello'  
>>> x = x + ' there'  
>>> x  
'hello there'  
 String Literals  
Can use single or double quotes, and 
three double quotes for a multi -line 
string  
>>> 'I am a string'  
'I am a string'  
>>> ""So am I!""  
'So am I!'  Substrings and Methods  
>>> s = '012345'  
>>> s[3]  
'3' 
>>> s[1:4]  
'123' 
>>> s[2:]  
'2345'  
>>> s[:4]  
'0123'  
>>> s[ -2] 
'4' • len(String) – returns the 
number of characters in 
the String  
 
• str(Object) – retur"
"ns a 
String representation of 
the Object  
>>> len(x)  
6 
>>> 
str(10.3)  
'10.3'  String Formatting  
Similar to C’s printf  
<formatted string> % <elements to 
insert>  
Can usually just use %s for everything, 
it will convert the object to its String 
representation.  
>>> ""One, %d, three"" % 2  
'One, 2, three'  
>>> ""%d, two, %s"" % (1,3)  
'1, two, 3'  
>>> ""%s two %s"" % (1, 'three')  
'1 two three'  
>>>  Types for Data Collection  
List, Set, and Dictionary  
List 
Unordered list  Ordered  Pa"
"irs of values  Lists 
Ordered collection of 
data 
Data can be of 
different types  
Lists are mutable  
Issues with shared 
references and 
mutability  
Same subset 
operations as Strings  >>> x = [1,'hello', (3 + 2j)]  
>>> x  
[1, 'hello', (3+2j)]  
>>> x[2]  
(3+2j)  
>>> x[0:2]  
[1, 'hello']  
 List Functions  
list.append(x)  
Add item at the end of the list.  
list.insert(i,x)  
Insert item at a given position.  
Similar to a[i:i]=[x]  
list.remove(x)  
Removes first item from the list w"
"ith value x  
list.pop(i)  
Remove item at position I and return it. If no index I is given then 
remove the first item in the list.  
list.index(x)  
Return the index in the list of the first item with value x.  
list.count(x)  
Return the number of time x appears in the list  
list.sort()  
Sorts items in the list in ascending order  
list.reverse()  
Reverses items in the list  
 Lists: Modifying Content  
x[i] = a    reassigns 
the ith element to the 
value a  
Since x and y point to 
the sa"
"me list object, 
both are changed  
The method append  
also modifies the list  >>> x = [1,2,3]  
>>> y = x  
>>> x[1] = 15  
>>> x  
[1, 15, 3]  
>>> y  
[1, 15, 3]  
>>> x.append(12)  
>>> y  
[1, 15, 3, 12]  
 Lists: Modifying Contents  
The method 
append  
modifies the list 
and returns 
None  
List addition 
(+) returns a 
new list  
 >>> x = [1,2,3]  
>>> y = x  
>>> z = x.append(12)  
>>> z == None  
True 
>>> y  
[1, 2, 3, 12]  
>>> x = x + [9,10]  
>>> x  
[1, 2, 3, 12, 9, 10]  
>>> y  
[1, 2, "
"3, 12]  
>>> Using Lists as Stacks  
You can use a list as a stack  
>>> a = [""a"", ""b"", ""c“,”d”]  
>>> a  
['a', 'b', 'c', 'd']  
>>> a.append(""e"")  
>>> a  
['a', 'b', 'c', 'd', 'e']  
>>> a.pop()  
'e' 
>>> a.pop()  
'd' 
>>> a = [""a"", ""b"", ""c""]  
>>>  Tuples 
Tuples are immutable  
versions of lists  
One strange point is 
the format to make a 
tuple with one 
element:  
 ‘,’ is needed to 
differentiate from the 
mathematical 
expression (2)  >>> x = (1,2,3)  
>>> x[1:]  
(2, 3)  
>>> y = (2,)  
>>> y"
"  
(2,) 
>>>  
 Sets 
A set is another python data structure that is an unordered 
collection with no duplicates.  
>>> setA=set([""a"",""b"",""c"",""d""])  
>>> setB=set([""c"",""d"",""e"",""f""])  
>>> ""a"" in setA  
True 
>>> ""a"" in setB  
False Sets 
>>> setA - setB 
{'a', 'b'}  
>>> setA | setB  
{'a', 'c', 'b', 'e', 'd', 'f'}  
>>> setA & setB  
{'c', 'd'}  
>>> setA ^ setB  
{'a', 'b', 'e', 'f'}  
>>>  
 Dictionaries  
A set of key -value pairs  
Dictionaries are mutable  
>>> d= {‘one’ : 1, 'two' : 2, ‘three’ : 3"
"}  
>>> d[‘three’]  
3 
 Dictionaries: Add/Modify  
>>> d  
{1: 'hello', 'two': 42, 'blah': [1, 2, 3]}  
>>> d['two'] = 99  
>>> d  
{1: 'hello', 'two': 99, 'blah': [1, 2, 3]}  
>>> d[7] = 'new entry'  
>>> d  
{1: 'hello', 7: 'new entry', 'two': 99, 'blah': [1, 2, 3]}  Entries can be changed by assigning to 
that entry  
 
•Assigning to a key that does not exist 
adds an entry  Dictionaries: Deleting Elements  
The del method deletes an element from a 
dictionary  
>>> d  
{1: 'hello', 2: 'there', 10: 'w"
"orld'}  
>>> del(d[2])  
>>> d  
{1: 'hello', 10: 'world'}  
 Iterating over a dictionary  
>>>address={'Wayne': 'Young 678', 'John': 'Oakwood 345', 
'Mary': 'Kingston 564'}  
 >>>for k in address.keys():  
            print(k,"":"", address[k])  
 
Wayne : Young 678  
John : Oakwood 345  
Mary : Kingston 564  
>>>  
 
>>> for k in sorted(address.keys()):  
 print(k,"":"", address[k])  
 
John : Oakwood 345  
Mary : Kingston 564  
Wayne : Young 678  
>>>  Copying Dictionaries and Lists  
The built -in 
list fu"
"nction 
will copy a list  
The dictionary 
has a method 
called copy  >>> l1 = [1]  
>>> l2 = list(l1)  
>>> l1[0] = 22  
>>> l1  
[22] 
>>> l2  
[1] 
 >>> d = {1 : 10}  
>>> d2 = d.copy()  
>>> d[1] = 22  
>>> d  
{1: 22}  
>>> d2  
{1: 10}  
 Data Type Summary  
Lists, Tuples, and Dictionaries can store 
any type (including other lists, tuples, 
and dictionaries!)  
Only lists and dictionaries are mutable  
All variables are references  Integers: 2323, 3234L  
Floating Point: 32.3, 3.1E2  
Complex: 3 "
"+ 2j, 1j  
Lists: l =  [ 1,2,3]  
Tuples: t = (1,2,3)  
Dictionaries: d = {‘hello’ : ‘there’, 2 : 15}   
52 
Functions  Function Basics  
 def max(x,y) :  
    if x < y :  
        return x  
    else :  
        return y  >>> import functionbasics  
>>> max(3,5)  
5 
>>> max('hello', 'there')  
'there'  
>>> max(3, 'hello')  
'hello'  
functionbasics.py  Functions are objects  
Can be assigned to a variable  
Can be passed as a parameter  
Can be returned from a function  
•Functions are treated like an"
"y other 
variable in Python, the def statement 
simply assigns a function to a variable  Function names are like any 
variable  
Functions are 
objects  
The same 
reference rules 
hold for them as 
for other objects  >>> x = 10  
>>> x  
10 
>>> def x () :  
...     print 'hello'  
>>> x  
<function x at 0x619f0>  
>>> x()  
hello 
>>> x = 'blah'  
>>> x  
'blah'  Functions as Parameters  
def foo(f, a) :  
    return f(a)  
 
def bar(x) :  
    return x * x  >>> from funcasparam import *  
>>> foo(bar, "
"3)  
9 
 
Note that the function foo takes two 
parameters and applies the first as a 
function with the second as its 
parameter  funcasparam.py  Higher-Order Functions  
map(func,seq)  – for all i, applies func(seq[i]) and returns the 
corresponding sequence of the calculated results.  
def double(x):  
    return 2*x  >>> from highorder import *  
>>> lst = range(10)  
>>> lst  
[0,1,2,3,4,5,6,7,8,9]  
>>> map(double,lst)  
[0,2,4,6,8,10,12,14,16,18]  highorder.py  Higher-Order Functions  
filter(bool"
"func,seq)  – returns a sequence containing all those 
items in seq for which boolfunc is True.  
def even(x):  
    return ((x%2 == 
0) >>> from highorder import *  
>>> lst = range(10)  
>>> lst  
[0,1,2,3,4,5,6,7,8,9]  
>>> filter(even,lst)  
[0,2,4,6,8]  highorder.py  Higher-Order Functions  
reduce(func,seq)  – applies func to the items of seq, from left 
to right, two -at-time, to reduce the seq to a single value.  
def plus(x,y):  
    return (x + y)  >>> from highorder import *  
>>> lst = [‘h’,’e"
"’,’l’,’l’,’o’]  
>>> reduce(plus,lst)  
‘hello’  
highorder.py  Functions Inside Functions  
Since they are like any other object, you 
can have functions inside functions  
def foo (x,y) :  
    def bar (z) :  
        return z * 2  
    return bar(x) + y   
>>> from funcinfunc import *  
>>> foo(2,3)  
7 
funcinfunc.py  Functions Returning Functions  
def foo (x) :  
    def bar(y) :  
        return x + y  
    return bar  
# main  
f = foo(3)  
print f  
print f(2)  % python funcreturnfunc.py  
<func"
"tion bar at 0x612b0>  
5 
 
funcreturnfunc.py  Parameters: Defaults  
Parameters can be 
assigned default 
values  
They are 
overridden if a 
parameter is given 
for them  
The type of the 
default doesn’t 
limit the type of a 
parameter  >>> def foo(x = 3) :  
...     print x  
...  
>>> foo()  
3 
>>> foo(10)  
10 
>>> foo('hello')  
hello Parameters: Named  
Call by name  
Any positional 
arguments 
must come 
before named 
ones in a call  >>> def foo (a,b,c) :  
...     print a, b, c  
.."
".  
>>> foo(c = 10, a = 2, b = 14)  
2 14 10  
>>> foo(3, c = 2, b = 19)  
3 19 2  Anonymous Functions  
A lambda 
expression 
returns a 
function object  
The body can 
only be a simple 
expression, not 
complex 
statements  >>> f = lambda x,y : x + y  
>>> f(2,3)  
5 
>>> lst = ['one', lambda x : x * x, 3]  
>>> lst[1](4)  
16 
 Modules  
The highest level structure of Python  
Each file with the py suffix is a module  
Each module has its own namespace  Modules: Imports  
import mymodule  Brings all"
" elements 
of mymodule in, but 
must refer to as 
mymodule.<elem>  
from mymodule import x  Imports x from 
mymodule right into 
this namespace  
from mymodule import *  Imports all elements 
of mymodule into 
this namespace   
67 
Text and File Processing  68 string : A sequence of text characters in a program.  
Strings start and end with quotation mark "" or apostrophe ' characters.  
Examples:  
 
""hello"" 
""This is a string""  
""This, too, is a string.   It can be very long!""  
 
A string may not span"
" across multiple lines or contain a "" character.  
""This is not  
a legal String.""  
 ""This is not a ""legal"" String either.""  
 
A string can represent characters by preceding them with a backslash.  
\t tab character  
\n new line character  
\"" quotation mark character  
\\ backslash character  
 
Example:  ""Hello\tthere\nHow are you?""  Strings  69 Indexes  
Characters in a string are numbered with indexes  starting at 0:  
Example:  
 name = ""P. Diddy""  
 
  
 
 
Accessing an individual characte"
"r of a string:  
 variableName  [ index  ] 
 
Example:  
 print name, ""starts with"", name[0] 
 
 Output:  
 P. Diddy starts with P  index  0 1 2 3 4 5 6 7 
character  P .   D i d d y 70 String properties  
len(string)  - number of characters in a string  
       (including spaces)  
str.lower( string) - lowercase version of a string  
str.upper( string) - uppercase version of a string  
 
Example:  
 name = ""Martin Douglas Stepp""  
 length = len(name)  
 big_name = str.upper(name)  
 print big_name, ""h"
"as"", length, ""characters""  
 
 Output:  
 MARTIN DOUGLAS STEPP has 20 characters  71 raw_input  : Reads a string of text from user input.  
Example:  
 name = raw_input(""Howdy, pardner. What's yer name? "")  
 print name, ""... what a silly name!""  
 
 Output:  
 
 Howdy, pardner. What's yer name? Paris Hilton  
 Paris Hilton ... what a silly name!  raw_input  72 Text processing  
text processing : Examining, editing, formatting text.  
often uses loops that examine the characters of a string one by one  "
"
 
A for loop can examine each character in a string in sequence.  
 
Example:  
  
 for c in ""booyah"":  
     print c 
 
 Output:  
 b 
 o 
 o 
 y 
 a 
 h 73 Strings and numbers  
ord(text)  - converts a string into a number.  
Example: ord(""a"")  is 97,  ord(""b"")  is 98, ... 
 
Characters map to numbers using standardized mappings such as 
ASCII  and Unicode . 
 
chr(number ) - converts a number into a string.  
Example: chr(99)  is ""c"" 
 
 
Exercise:  Write a program that performs a rotation cyphe"
"r.  
e.g. ""Attack""  when rotated by 1 becomes ""buubdl""  74 File processing  
Many programs handle data, which often comes from files.  
 
Reading the entire contents of a file:  
 
variableName  = open("" filename "").read()  
 
 
Example:  
file_text = open(""bankaccount.txt"").read()  75 Line-by-line processing  
Reading a file line -by-line: 
 
for line in open("" filename "").readlines():  
    statements  
 
Example:  
count = 0  
for line in open(""bankaccount.txt"").readlines():  
    count = count + 1  "
"
print ""The file contains"", count, ""lines.""  
 
 
 
Exercise: Write a program to process a file of DNA text, such as:  
 ATGCAATTGCTCGATTAG  
Count the percent of C+G present in the DNA.   
76 
Objects and Classes  Defining a Class  
Python program may own many objects  
An object is an item with fields supported by a set of method functions.  
An object can have several fields (or called attribute variables) describing 
such an object  
These fields can be accessed or modified by object methods  
A "
"class defines what objects look like and what functions can operate 
on these object.  
 
Declaring a class:  
 
 class name: 
     statements  
Example:  
 
 class UCSBstudent:  
    age = 21  
    schoolname=‘UCSB’  
      
 Fields  
 name = value  
 
Example:  
 
 class Point:  
     x = 0 
     y = 0 
 
 # main 
 p1 = Point()  
 p1.x = 2  
 p1.y = -5 
 
can be declared directly inside class (as shown here)  
or in constructors (more common)  
 
Python does not really have encapsulation or private f"
"ields  
relies on caller to ""be nice"" and not mess with objects' contents  point.py  
1 
2 
3 class Point:  
    x = 0 
    y = 0 Using a Class  
 import class  
 
client programs must import the classes they use  
point_main.py  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 from Point import *  
 
# main 
p1 = Point()  
p1.x = 7  
p1.y = -3 
 
p2 = Point()  
p2.x = 7  
p2.y = 1  
 
# Python objects are dynamic (can add fields any time!)  
p1.name = ""Tyler Durden"" Object Methods  
 def name(self, parameter , ..., parame"
"ter ): 
     statements  
 
self must be the first parameter to any object method  
represents the ""implicit parameter"" ( this in Java)  
 
 
must access the object's fields through the self reference  
 
 class Point:  
     def move(self, dx, dy):  
         self.x += dx  
         self.y += dy  
      Exercise Answer  
 
point.py  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 from math import *  
 
class Point:  
    x = 0 
    y = 0 
 
    def set_location (self, x, y):  
        self.x "
"= x 
        self.y = y 
 
    def distance_from_origin (self): 
        return sqrt(self.x * self.x + self.y * self.y) 
 
    def distance(self, other):  
        dx = self.x - other.x 
        dy = self.y - other.y 
        return sqrt(dx * dx + dy * dy) Calling Methods  
A client can call the methods of an object in two ways:  
(the value of self can be an implicit or explicit parameter)  
 
 1) object.method(parameters ) 
  or 
 2) Class.method(object, parameters ) 
 
Example:  
p = Point(3, -4) 
p.m"
"ove(1, 5) 
Point.move (p, 1, 5) Constructors  
 def __init__ (self , parameter , ..., parameter ): 
     statements  
 
a constructor is a special method with the name __init__  
 
Example:  
 
 class Point:  
     def __init__(self, x, y):  
         self.x = x  
         self.y = y  
     ... 
 
How would we make it possible to construct a  
Point()  with no parameters to get (0, 0)?  toString  and __str__ 
 def __str__(self): 
     return string  
 
equivalent to Java's toString  (converts object to "
"a string)  
invoked automatically when str or print  is called  
 
Exercise: Write a __str__  method for Point  objects that returns strings 
like  ""(3, -14)"" 
 
def __str__(self):  
    return ""("" + str(self.x) + "", "" + str(self.y) + "")""  Complete Point Class  
 point.py  
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 from math import *  
 
class Point:  
    def __init__(self, x, y):  
        self.x = x 
        self.y = y 
 
    def distance_from_origin (self): 
        retu"
"rn sqrt(self.x * self.x + self.y * self.y) 
 
    def distance(self, other):  
        dx = self.x - other.x 
        dy = self.y - other.y 
        return sqrt(dx * dx + dy * dy) 
 
    def move(self, dx, dy): 
        self.x += dx 
        self.y += dy 
 
    def __str__(self):  
        return ""("" + str(self.x) + "", "" + str(self.y) + "")"" Operator Overloading  
operator overloading : You can define functions so that Python's 
built-in operators can be used with your class.  
See also: http://docs.python"
".org/ref/customization.html  
 
Operator  Class Method  
- __neg__(self, other)  
+ __pos__(self, other)  
* __mul__(self, other)  
/ __truediv__(self, other)  
Unary Operators  
- __neg__(self)  
+ __pos__(self)  Operator  Class Method  
== __eq__(self, other)  
!= __ne__(self, other)  
< __lt__(self, other)  
> __gt__(self, other)  
<= __le__(self, other)  
>= __ge__(self, other)  Generating Exceptions  
 raise ExceptionType (""message "") 
 
useful when the client uses your object improperly  
types: Ar"
"ithmeticError , AssertionError , IndexError , 
NameError , SyntaxError , TypeError , ValueError  
 
Example:  
 
 class BankAccount:  
     ... 
     def deposit(self, amount):  
         if amount < 0:  
              raise ValueError(""negative amount"")  
         ... Inheritance  
 class name(superclass ): 
     statements  
 
Example:  
 class Point3D( Point):   # Point3D extends Point  
     z = 0 
     ... 
 
 
Python also supports multiple inheritance  
  
 class name(superclass , ..., superclass )"
": 
     statements  
 
 (if > 1 superclass has the same field/method, conflicts are resolved in left -to-right order)  Calling Superclass Methods  
methods:  class.method(object, parameters ) 
 
constructors:  class.__init__( parameters ) 
 
 
 class Point3D(Point):  
     z = 0 
     def __init__(self, x, y, z):  
         Point.__init__(self, x, y)  
         self.z = z  
 
     def move(self, dx, dy, dz):  
         Point.move(self, dx, dy)  
         self.z += dz  "
"1. The Assignment Statement  
and Types  
 Topics:  
 Python’s Interactive Mode  
 Variables  
 Expressions  
 Assignment  
 Strings, Ints, and Floats  
 The Python Interactive Shell  
Python can be used in a way that reminds  
you of a calculator. In the ``command shell  
of your system simply type  
 
python 
 
and you will be met with a prompt…  
 
 
 
  
>>>                    
 Let’s Compute the Area of a 
Circle Using Python  
 
 
 
 
  
>>> r = 10  
>>> A = 3.14*r*r  
>>> print A  
314.0             "
"       
 Programming vs Math  
 
 
 
 
  
>>> r = 10  
>>> A = 3.14*r*r  
>>> print A  
314.0                    
 
Notation is different.  
 
In Python, you can’t say A = 3.14xrxr  Programming vs Math  
 
 
 
 
  
>>> r = 10  
>>> A = 3.14*r**2  
>>> print A  
314.0                    
 
Notation is different.  
 
In Python you indicate exponentiation with **  Programming vs Math  
 
 
 
 
  
>>> r = 10  
>>> A = 3.14*r**2  
>>> print A  
314.0                    
 
r and A are variables . In algebra, we h"
"ave  
the notion of a variable too. But there are  
some big differences.  Variables  
A variable is a named memory location. Think of a 
variable as a box.  
It contains a value. Think of the value as the 
contents  of the box.  
  
>>> r = 10  
>>> A = 3.14*r**2                   
 
r ->  10   314.0  A -> 
“ The value of  r is 10. The value of A is 314.0.”  The Assignment Statement  
The  “= “ symbol indicates assignment.  
The assignment statement r = 10 creates the 
variable r and assigns to it the valu"
"e of 10.  
  
>>> r = 10                    
 
r ->  10  
 Formal:   “ r is assigned the value of 10”        Informal:   “r gets 10”  The Assignment Statement  
A variable can be used in an expression  like 
   3.14*r**2 . 
The expression is evaluated and then stored.  
  
>>> r = 10  
>>> A = 3.14*r**2                   
 
r ->  10  
Assignment Statement:      WHERE TO PUT IT    =    RECIPE FOR A VALUE   A ->  314.0  Order is Important  
Math is less fussy:  
 
           A = 3.14*r**2  where r = 10  
 
  "
"
>>> A = 3.14*r**2  
>>> r = 10  
NameError : name ‘r’ is not defined                   
 Assignment vs. “Is Equal to”  
In Math “=“ is used to say what is on the left 
equals what is on the right.  
 
In Python, “=“ prescribes an action, “evaluate 
the expression on the right and assign its 
value to the variable named on the left.”  
 
  
>>> r = 10  
>>> 3.14*r**2 = A  
SyntaxError : can’t assign to an 
operator                    
 The Assignment Statement  
Here we are assigning to S  the area of a  
s"
"emicircle that has radius 10.  
  
>>> r = 10  
>>> A = 3.14*r**2  
>>> S = A/2                    
 r ->  10  
Assignment Statement:      WHERE TO PUT IT    =    RECIPE FOR A VALUE   A ->  314.0  
 157.0  S -> The Assignment Statement  
Here we are assigning to A  the area of a 
semicircle that has radius 10.  
No new rules in the third assignment. The “recipe” 
is A/2. The target of the assignment is A.  
 
  
>>> r = 10  
>>> A = 3.14*r**2  
>>> A = A/2                    
 r ->  10  
“A has been overwri"
"tten by A/2”   A ->  157.0  Tracking Updates  
>>> y = 100  
 Before : Tracking Updates  
>>> y = 100 
 
y ->  100  After : Tracking Updates  
>>> y = 100  
>>> t = 10 
 
y ->  100  Before : Tracking Updates  
>>> y = 100  
>>> t = 10 
 
y ->  100  
t ->  10  After : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
 y ->  100  
t ->  10  Before : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
 y ->  110  
t ->  10  After : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> "
"t = t+10  
 y ->  110  
t ->  10  Before : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10  
 y ->  110  
t ->  20  After : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10;  
>>> y = y+t 
 y ->  110  
t ->  20  Before : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10;  
>>> y = y+t 
 y ->  130  
t ->  20  After : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t 
>>> t = t+10  
 y ->  130  
t ->  20  "
"Before : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t 
>>> t = t+10  
 y ->  130  
t ->  30  After : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t                    
 y ->  130  
t ->  30  Before : Tracking Updates  
>>> y = 100  
>>> t = 10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t 
>>> t = t+10  
>>> y = y+t                    
 y ->  160  
t ->  30  After : Assignment vs Equations  
In algebra,  "
"
                           t = t +10  
 
doesn’t  make sense unless you believe  
 
                           0 =t-t = 10  
 
In Python,  
    t = t + 10  
 
means add 10 to the value of t and store  
the result in t.  
 
 The Key 2 -Step Action Behind  
Every Assignment Statement  
 
1.Evaluate the expression on the right hand  
     side. 
 
2.Store the result in the variable named on the  
     left hand side.  
 
 < variable name >  =  <  expression > Naming Variables  
Rule 1 . Name must be comprised"
" of digits, upper 
case letters, lower case letters, and the 
underscore character  “_”  
 
Rule 2. Must begin with a letter or underscore  
  
>>> radius = 10  
>>> Area = 3.14*radius**2                   
 
radius ->  10  Area ->  314.0  
A good name for a variable  is short but suggestive of its role:   Circle_Area   Precedence  
Q.  In an arithmetic expression, what is  
 the order of evaluation?  
A.  Exponentiation & negation comes before 
 multiplication & division which in turn 
 come before additio"
"n & subtraction.  
It is a good habit to use parentheses if there is the slightest ambiguity.  This:                        Is the same as:  
  A + B*C         A + (B*C)  
  -A**2/4         -(A**2)/4  
  A*B/C*D        ((A*B)/C)*D  
 
 Revisit Circle Area  
It seems that Python evaluates (22/7) as 
3 instead of 3.142…  WHY?   
>>> r = 10  
>>> A = (22/7)*r**2  
>>> print A  
300.0                    
 
A different kind of arithmetic. We have a related experience here.  
11+3 = 2 in “clock arithmetic”  Integ"
"ers and Decimals  
In math we distinguish between integer 
numbers and decimal numbers.  
 
Integer Numbers:    
  100, 0, -89, 1234567  
 
Decimal Numbers:  
  -2.1, 100.01, 100.0, 12.345  
 
 Integers and Decimals  
 
There are different kinds of division.  
 
Integer Division:    
  30/8  is 3 with a remainder of 6  
 
Decimal Division:  
  30/8 is 3.75  
 
 int vs float 
In Python, a number has a type. 
 
The int type represents numbers as 
integers.  
 
The float  type represents numbers as 
decimals. "
" 
 
 
 Important to understand the differences and the interactions  int Arithmetic  
To get the remainder, use %. Python “knows” that the values stored in x and y have 
type int because there are no decimal points in those assignments.  >>> x = 30  
>>> y = 8  
>>> q = x/y  
>>> print q  
3 
>>> r = x%y 
>>> print r  
6                   
 float Arithmetic   
Python “knows” that the values stored in x and y have type float because there are 
decimal points in those assignments.  >>> x = 30.  
>>> y = 8.  
"
">>> q = x/y  
>>> print q  
3.75 
 Mixing float and int  
In Python if one operand has type float and the other has type int, then the type 
int value is converted to float and the evaluation proceeds.  >>> x = 30.  
>>> y = 8  
>>> q = x/y  
>>> print q  
3.75 
 Explicit Type Conversion   
     int( -expression - ) converts the value of the expression to  int value  >>> x = 30.0  
>>> y = 8.0  
>>> q = int(x)/int(y) 
>>> print q  
3 
 Explicit Type Conversion   
     float( -expression - ) converts the val"
"ue of the expression to a  float  >>> x = 30  
>>> y = 8  
>>> q = float(x)/float(y)  
>>> print q  
3.75 
 An Important Distinction   
>>> x = 1.0/3.0  
>>> print x  
.333333333333  
 Integer arithmetic is exact.  
Float arithmetic is (usually) not exact.  Strings  
So far we have discussed computation with  
numbers.  
 
Now we discuss computation with text.  
 
We use strings  to represent text.  
 
 You are a “string processor” when you realize  7/4 means July 4 and not 1.75!     Strings  
Strings are q"
"uoted characters. Here are three  
examples:   
>>> s1 = ‘ abc’ 
>>> s2 = ‘ABC’  
>>> s3 = ‘ A B C ‘  
 
 s1, s2, and s3 are variables with string value.  Strings  
Strings are quoted characters. Here are three  
examples:   
>>> s1 = ‘ abc’ 
>>> s2 = ‘ABC’  
>>> s3 = ‘ A B C ‘  
 
The values in s1,s2,and s3 are all different.  
Upper and lower case matters. Blanks matter  Strings  
Nothing special about letters…  
>>> Digits = ‘1234567890’  
>>> Punctuation = ‘!:;.?’  
>>> Special = @#$%^&*()_ -+=‘ 
 
 Bas"
"ically any keystroke but there are some  
exceptions and special rules. More later.  
 Here is one :  ‘Sophie”’”s  Choice’    i.e., Sophie’s Choice      Strings are Indexed  
 >>> s = ‘The Beatles’  
 
The characters in a string can be referenced  
through their indices.  Called “subscripting”.  
 Subcripting  from zero creates a disconnect:  ‘T’ is not the first character.        e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  Strings are Indexed  
"
">>> s =‘The Beatles’  
>>> t = s[4]  
 
 The square bracket notation is used. Note, a single character is a string.        e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  
t -->  B  
 0    String Slicing  
>>> s =‘The Beatles’  
>>> t = s[4:8]  
 
 We say that “t is a slice of s”.        e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  
t -->  B  
 0    1     2     3      e   a   t  String Slic"
"ing  
>>> s =‘The Beatles’  
>>> t = s[4:]  
 
Same as  s[4:11]. Handy notation when you want an “ending slice.”   e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  
t -->  B  
 0    1     2     3    4    5     6      e   a   t   l   e   s  String Slicing  
>>> s =‘The Beatles’  
>>> t = s[:4]  
 
 e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  
t -->  T  
 0    1    2     3      h   e      
Sa"
"me as  s[0:4]. Handy notation when you want a “beginning slice”.  String Slicing  
>>> s =‘The Beatles’  
>>> t = s[11]  
IndexError : string index out of 
range 
 
 e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8    9   10  
Subscripting errors are EXTREMELY common.  The is no s[11]. An illegal to access . String Slicing  
>>> s =‘The Beatles’  
>>> t = s[8:20]  
 
 e   s   T   h   l   e   B   a       e   t  s --> 
 0    1    2     3    4    5     6    7    8 "
"   9   10  
t -->  l  
 0    1    2           e   s  
It is “OK” to shoot beyond the end of the source string.  Strings Can Be Combined  
 e   s   T   h   l   e   B   a   e   t  s --> 
Concatenation is the string analog of addition except  
s1+s2  and s2+s1  are different.   >>> s1 = ‘The’  
>>> s2 = ‘Beatles’  
>>> s = s1+s2  
 
This is called concatenation . Concatenation  
 e   s   T   h   l   e   B   a       e   t  s --> 
No limit to the number of input strings:  s = s2+s2+s2+s2+s2  >>> s1 = ‘The’  
>>>"
" s2 = ‘Beatles’  
>>> s = s1 + ‘ ‘ + s2  
 
We “added” in a blank.  Types  
 
Strings are a type: str 
 
So at this point we introduced 3 types:  
 
 int   for integers, e.g.,  -12 
 float    for decimals, e.g., 9.12 , -12.0 
 str   for strings, e.g., ‘abc’, ’12.0’ 
 
 
 Python has other built -in types. And we will learn to make up our own types.  A Type is a Set of Values and 
Operations on Them  
  int   123, -123, 0 
 float    1.0, -.00123, -12.3e-5 
 str   ‘abcde’, ‘123.0’  
 
 
 Values…  
The “e” nota"
"tion (a power -of-10 notation)  is handy for very large or very small 
floats.  The literals -.00123 and -12.3e -5 are the same number.  These are called “literals”  A Type is a Set of Values and 
Operations on Them  
  int   +  -  *  /  unary -   **  % 
 float    +  -  *  /  unary -   ** 
 str   +     
 
 
 concatenation  Operations…  Type Conversion  
A string that encodes a decimal value can be  
represented as a float .  >>> s = ‘123.45’  
>>> x = 2*float(s)  
>>> print x  
246.90 
 Type Conversion  
A "
"string that encodes an integer value can  
be represented as an int.  >>> s = ‘ -123’ 
>>> x = 2* int(s) 
>>> print x  
-246 
 Type Conversion  
Shows how to get a string encoding of a  
float value.  >>> x = -123.45 
>>> s = str(x) 
>>> print s  
‘-123.45’ 
 Automatic Type Conversion  
>>> x = 1/2.0  
>>> y = 2*x  
 
An operation between a float  and an int 
results in a float . So x is a float .  
 
Thus,  y is also a float  even though its value 
happens to be an integer.  
 Python is a Dynamically Typed"
" 
Language  
>>> x = ‘ abcde’ 
>>> x = 1.0  
>>> x = 32  
 A variable can hold different types of  
values at different times.  
 
 
In other languages the type of a variable is fixed.  Summary  
1. Variables house values that can be 
accessed.  
 
2. Assignment statements assign values to  
variables.  
 
3. Numerical data can be represented  
using the int and float  types.  
 
4.Text data can be represented using the  
str type.  
 "
"WELCOME!
(download slides and . pyfiles and follow along!)
6.0001 LECTURE 1
1 6.0001 LECTURE 1TODAY
course info
what is computation
python basics
mathematical operations
python variables and types
NOTE: slides and code files up before each lecture
ohighly encourage you to download them before lecture
otake notes and run code files when I do
obring computers to answer in-class practice exercises!
2 6.0001 LECTURE 1COURSE INFO
Grading
◦approx . 20%  Quiz
◦approx. 40 %  Final 
◦approx . 30%  Problem Set"
"s 
◦approx . 10%  MITx Finger Exercises
3 6.0001 LECTURE 1COURSE POLICIES
Collaboration
◦may collaborate with anyone
◦required to write code independently and write names of 
all collaborators on submission
◦we will be running a code similarity program on all psets
Extensions
◦no extensions
◦late days , see course website for details
◦drop and roll weight of max two psets in final exam grade
◦should be EMERGENCY use only
4 6.0001 LECTURE 1RECITATIONS
not mandatory
two flavors
1) Lecture review: review l"
"ecture material 
oif you missed lecture 
oif you need a different take on the same concepts
2) Problem solving: teach you how to solve programming 
problems
ouseful if you don’t know how to set up pseudocode from pset words 
owe show a couple of harder questions
owalk you through how to approach solving the problem
obrainstorm code solution along with the recitation instructor
owill post solutions after
6.0001 LECTURE 1 5FAST PACED COURSE
Position yourself to succeed!
◦read psets when they come out and com"
"e back to them later
◦use late days in emergency situations
New to programming? PRACTICE. PRACTICE? PRACTICE! 
◦can’t passively absorb programming as a skill
◦download code before lecture and follow along
◦do MITx finger exercises 
◦don’t be afraid to try out Python commands! 
6 6.0001 LECTURE 1PRACTICE
76.0001 LECTURE 1PROBLEM 
SOLVING
PROGRAMMING 
SKILLKNOWLEDGE 
OF CONCEPTSTOPICS
represent knowledge with data structures
iteration and recursion as computational metaphors
abstraction of procedures and "
"data types
organize and modularize systems using object classes 
and methods
different classes of algorithms , searching and sorting
complexity of algorithms
6.0001 LECTURE 1 8WHAT DOES A COMPUTER DO
Fundamentally:
◦performs calculations
a billion calculations per second!
◦remembers results
100s of gigabytes of storage!
What kinds of calculations?
◦built -into the language
◦ones that you define as the programmer
computers only know what you tell them
6.0001 LECTURE 1 9TYPES OF KNOWLEDGE
declarative k"
"nowledge is statements of fact . 
◦someone will win a Google 
Cardboard before class ends
imperative knowledge is a recipe or “how -to”.  
1)Students sign up for raffle
2)Ana opens her IDE
3)Ana chooses a random number between 1stand nthresponder
4)Ana finds the number in the responders sheet. Winner!
6.0001 LECTURE 1 10A NUMERICAL EXAMPLE
square root of a number x is y such that y*y = x
recipe for deducing square root of a number x ( 16)
1)Start with a guess , g
2)If g*g is close enough to x, stop and s"
"ay g is the 
answer 
3)Otherwise make a new guess by averaging g and x/g
4)Using the new guess, repeat process until close enough
6.0001 LECTURE 1 11g g*g x/g (g+x/g)/2
3 9 16/3 4.17
4.17 17.36 3.837 4.0035
4.0035 16.0277 3.997 4.000002WHAT IS A RECIPE
1) sequence of simple steps
2) flow of control process that specifies when each 
step is executed
3) a means of determining when to stop
1+2+3 = an algorithm !
6.0001 LECTURE 1 12COMPUTERS ARE MACHINES
how to capture a recipe in a mechanical process
fixed p"
"rogram computer
◦calculator
stored program computer
◦machine stores and executes instructions
6.0001 LECTURE 1 13BASIC MACHINE ARCHITECTURE
6.0001 LECTURE 1 14MEMORY
CONTROL 
UNITARITHMETIC 
LOGIC UNIT
INPUT OUTPUTprogram counter do primitive opsSTORED PROGRAM COMPUTER
sequence of instructions stored inside computer
◦built from predefined set of primitive instructions
1) arithmetic and logic
2) simple tests
3) moving data
special program (interpreter) executes each 
instruction in order
◦use tests to cha"
"nge flow of control through sequence
◦stop when done
6.0001 LECTURE 1 15BASIC PRIMITIVES
Turing showed that you can compute anything using 6 
primitives
modern programming languages have more 
convenient set of primitives
can abstract methods to create new primitives
anything computable in one language is computable in 
any other programming language
6.0001 LECTURE 1 16CREATING RECIPES
a programming language provides a set of primitive 
operations
expressions are complex but legal combinations of 
pri"
"mitives in a programming language
expressions and computations have values and 
meanings in a programming language
6.0001 LECTURE 1 17ASPECTS OF LANGUAGES
primitive constructs
◦English: words
◦programming language: numbers, strings, simple 
operators
6.0001 LECTURE 1 18
Word Cloud copyright Michael Twardos , All Right Reserved. This content is excluded from our
Creative  Commons license. For more information, see  https://ocw.mit.edu/help/faq-fair-use/ .Word Cloud copyright unknown, All Right  Reserved.
T"
"his content is excluded from  our Creative
Commons  license. For more  information, see
https://ocw.mit.edu/help/faq-fair-use/ .ASPECTS OF LANGUAGES
syntax
◦English: ""cat dog boy ""    not syntactically valid
""cat hugs boy"" syntactically valid
◦programming language: ""hi""5not syntactically valid
3.2*5syntactically valid
6.0001 LECTURE 1 19ASPECTS OF LANGUAGES
static semantics is which syntactically valid strings 
have meaning
◦English: ""I are hungry"" syntactically valid
but static semantic error
◦progr"
"amming language: 3.2*5 syntactically valid
3+""hi"" static semantic error
6.0001 LECTURE 1 20ASPECTS OF LANGUAGES
semantics is the meaning associated with a 
syntactically correct string of symbols with no static 
semantic errors
◦English: can have many meanings ""Flying planes 
can be dangerous""
◦programming languages: have only one meaning but may 
not be what programmer intended
6.0001 LECTURE 1 21WHERE THINGS GO WRONG
syntactic errors
◦common and easily caught
static semantic errors
◦some languages ch"
"eck for these before running program
◦can cause unpredictable behavior
no semantic errors but different meaning than what 
programmer intended
◦program crashes, stops running
◦program runs forever
◦program gives an answer but different than expected
6.0001 LECTURE 1 22PYTHON PROGRAMS
a program is a sequence of definitions and commands
◦definitions evaluated 
◦commands executed by Python interpreter in a shell
commands (statements) instruct interpreter to do 
something
can be typed directly in a shell or"
" stored in a filethat 
is read into the shell and evaluated
◦Problem Set 0 will introduce you to these in Anaconda
6.0001 LECTURE 1 23OBJECTS
programs manipulate data objects
objects have a type that defines the kinds of things 
programs can do to them
◦Ana is a human so she can walk, speak English, etc.
◦Chewbacca is a wookie so he can walk, “ mwaaarhrhh ”, etc.
objects are
◦scalar (cannot be subdivided)
◦non-scalar (have internal structure that can be accessed)
6.0001 LECTURE 1 24SCALAR OBJECTS
int –r"
"epresent integers , ex. 5
float –represent real numbers , ex. 3.27
bool –represent Boolean values True and False
NoneType –special and has one value, None
can use type() to see the type of an object
>>> type(5)
int
>>> type(3.0)
float
6.0001 LECTURE 1 25TYPE CONVERSIONS (CAST)
can convert object of one type to another
float(3) converts integer 3 to float 3.0
int(3.9) truncates float 3.9 to integer 3
6.0001 LECTURE 1 26PRINTING TO CONSOLE
to show output from code to a user, use print
command
In [11]:"
" 3+2
Out[11]: 5
In [12]: print(3+2 )
5
6.0001 LECTURE 1 27EXPRESSIONS
combine objects and operators to form expressions
an expression has a value , which has a type
syntax for a simple expression
<object> <operator> <object>
6.0001 LECTURE 1 28OPERATORS ON intsand floats
i+jthe sum
i-jthe difference
i*jthe product
i/jdivision
i%jthe remainder when iis divided by j
i**jito the power of j
6.0001 LECTURE 1 29if both are ints, result is int
if either or both are floats, result is float
result is "
"floatSIMPLE OPERATIONS
parentheses used to tell Python to do these 
operations first
operator precedence without parentheses
◦**
◦*
◦/
◦+ and –executed left to right, as appear in expression
6.0001 LECTURE 1 30BINDING VARIABLES AND 
VALUES
equal sign is an assignment of a value to a variable 
name
pi = 3.14159
pi_approx = 22/7
value stored in computer memory
an assignment binds name to value
retrieve value associated with name or variable by 
invoking the name, by typing pi
6.0001 LECTURE 1 31ABSTRACT"
"ING EXPRESSIONS
why give names to values of expressions?
to reuse names instead of values
easier to change code later
pi = 3.14159
radius = 2.2
area = pi*(radius**2)
6.0001 LECTURE 1 32PROGRAMMING vs MATH
in programming, you do not “solve for x”
pi = 3.14159
radius = 2.2
# area of circle
area = pi*(radius**2)
radius = radius+1
6.0001 LECTURE 1 33CHANGING BINDINGS
can re-bind variable names using new assignment 
statements
previous value may still stored in memory but lost the 
handle for it
value for"
" area does not change until you tell the 
computer to do the calculation again
6.0001 LECTURE 1 34pi
radius
area3.14
2.2
15.19763.2pi = 3.14
radius = 2.2
area = pi*(radius**2 )
radius = radius+1MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"10. Iteration: The while -Loop 
 Topics:  
 Open -Ended repetition  
 the while  statement  
 Random Walk Simulation  Open -Ended Iteration  
So far, we have only addressed iterative  
problems in which we know (in advance) the  
required number of repetitions.  
 
Not all iteration problems are like that.  
 
Some iteration problems are open -ended.  
Stir for 5 minutes   vs   Stir until fluffy.  Examples  
Keep tossing a coin until the number of heads  
and the number of tails differs by 10.  
Compute the"
" square root of 2….  
L = 2; W = 1  
Repeat this until |L -W| <= .000001:  
          L = (L + W)/2  
          W = x/L  
       In both cases, we do not know the number of  iterations that will  be required  The Random Walk Idea  
                                                       
We have a “runway” made up of 1x1 tiles.  
 
There are 2L+1 tiles. (L = 5 in the above.)  
 
We call L the “length of the runway.  
 
The center tile is located at x = 0.  
 -5   -4   -3   -2   -1     0    1     2    3    4 "
"   5  The Random Walk Idea  
                                                       
Starting at the center tile, a robot hops  
from tile to tile according to a coin flip.  
 
Heads: Hop right one tile.  
 
Tails:  Hop left one tile.  
 
The simulation over when robot reaches 
either end (a.k.a. the boundary) of the runway.  -5   -4   -3   -2   -1     0    1     2    3    4    5  
           We do not know in advance how many iterations we’ll need , The While Loop  
We introduce an alternative to the for -"
"loop 
called the while -loop. 
 
The while loop is more flexible and is essential  
for ``open ended’’ iteration.  
 
 
 How Does a While -Loop Work?  
A simple warm -up example:  
 
Sum the first 5 whole numbers and display the  
summation process.  
 
  Two  Solutions  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   
s = 0 
for k in range(1,6):          
 s = s + k  
    print k,s 
 The While -Loop Solution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   p"
"rint k,s  
 1   1 
2   3 
3   6  
4  10 
5  15 
Observation: k is used for counting,  s is used for the running sum, and the while 
is used to control the repetition of the indented code.   The Solution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
 1   1 
2   3 
3   6  
4  10 
5  15 
We call this the “loop body”     
 
 
 
 Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   0   k -> 
  0   s -> 
At the start, k and s are init"
"ialized  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   0   k -> 
  0   s -> 
Is the boolean condition true?  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   0   k -> 
  0   s -> 
 
Yes, so execute the loop body   
 
 
 
 Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   1   k -> 
  1   s -> 
 
 
 
 
 11  Trace the Execution  
k = 0  
s = 0 
while k < "
"5:   
   k = k + 1  
   s = s + k  
   print k,s  
   1   k -> 
  1   s -> 
Is the boolean condition true?  11  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   1   k -> 
  1   s -> 
 
Yes, so execute the loop body   
 
 
 
 11  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   2   k -> 
  3   s -> 
 
 
 
 
 11 
23  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print"
" k,s  
   2   k -> 
  3   s -> 
Is the boolean condition true?  11 
23  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   2   k -> 
  3   s -> 
 
Yes, so execute the loop body   
 
 
 
 11 
23  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   3   k -> 
  6   s -> 
 
 
 
 
 11 
23 
36  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   3   k -> 
  6   s -> 
"
"Is the boolean condition true?  11 
23 
36  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   3   k -> 
  6   s -> 
 
Yes, so execute the loop body   
 
 
 
 11 
23 
36  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   4   k -> 
  10   s -> 
 
 
 
 
 11 
23 
36 
410  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   4   k -> 
  10   s -> 
Is the boolean co"
"ndition true?  11 
23 
36 
410  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   4   k -> 
  10   s -> 
 
Yes, so execute the loop body   
 
 
 
 11 
23 
36 
410  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   5   k -> 
  15   s -> 
 
 
 
 
 11 
23 
36 
410 
515  Trace the Execution  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
   5   k -> 
  15   s -> 
11 
23 
36 
410 
5"
"15  
Is the boolean condition true?  
NO! The loop is over.  The While -Loop Mechanism  
while  A Boolean Expression  
 
  The Loop Body   
  :  
 
 
 
 
 
 
 
 
 
The Boolean expression is checked. If it is true,  
then the loop body is executed. The process is  
repeated until the Boolean expression is false.  
At that point the iteration terminates.  The Broader Context  
while  A Boolean Expression  
 
  The Loop Body   
  :  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  Code that comes before the loop  
 Code that "
"comes after the loop  
Every variable involved in the Boolean expression must be initialized.   The Broader Context  
while  A Boolean Expression  
 
  The Loop Body   
  :  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  Code that comes before the loop  
 Code that comes after the loop  
After the loop terminates the next statement after the loop is executed.   The Broader Context  
while  A Boolean Expression  
 
  The Loop Body   
  :  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  Code that comes before the loop  
 Code that comes "
"after the loop  
Indentation defines the loop body   Back to Our Example  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
   print k,s  
 11 
23 
36 
410 
515   
 
 
 
 
Let’s move the print statement outside the loop body   Back to Our Example  
k = 0  
s = 0 
while k < 5:   
   k = k + 1  
   s = s + k  
print k,s  
 5  15  
Only the final value of k and s are reported.    
 
 Random Walks  
A very important type of random simulation.  
 
A good example to showcase the while loop.  The Rando"
"m Walk Idea  
                                                       
We have a “runway” made up of 1x1 tiles.  
 
There are 2L+1 tiles. (L = 5 in the above.)  
 
We call L the “length of the runway.  
 
The center tile is located at x = 0.  
 -5   -4   -3   -2   -1     0    1     2    3    4    5  The Random Walk Idea  
                                                       
Starting at the center tile, a robot hops  
from tile to tile according to a coin flip.  
 
Heads: Hop right one tile.  
 
Tails:  Ho"
"p left one tile.  
 
The simulation over when robot reaches 
either end (a.k.a. the boundary) of the runway.  -5   -4   -3   -2   -1     0    1     2    3    4    5  The Random Walk Idea  
                                                       
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Question:  
 
Given the runway length L, what is the average  
number of hops required for the robot to  
reach the boundary?  
 Implement ShowRandomWalk.py  
from random import randint as randi 
 
def RandomWa"
"lk (L): 
   # Returns the number of hops for  
   # a single random walk.  
 
def AveRandomWalk (L,n): 
   # Simulate n length -L random walks and  
   # returns average number of required hops  
 
if __name__ == '__main__':  
   # Display the value of AveRandomWalk  
   # for various values of L  
     
 def RandomWalk (L): 
   hops = 0; x = 0  
   while abs(x) < L:  
      r = randi(0,1) 
      if r == 0:  
         x = x + 1  
      else: 
         x = x - 1  
      hops += 1  
   return hops  The Functi"
"on  
RandomWalk (L) 
Initializations.  
The robot starts  
at x = 0.  def RandomWalk (L): 
   hops = 0; x = 0  
   while abs(x) < L:  
      r = randi(0,1) 
      if r == 0:  
         x = x + 1  
      else: 
         x = x - 1  
      hops += 1  
   return hops  The Function  
RandomWalk (L) 
If the condition  
is True, the  
robot has not yet  
reached the  
boundary and we  
keep iterating..  def RandomWalk (L): 
   hops = 0; x = 0  
   while abs(x) < L:  
      r = randi(0,1) 
      if r == 0:  
      "
"   x = x + 1  
      else: 
         x = x - 1  
      hops += 1  
   return hops  The Function  
RandomWalk (L) 
We simulate  
the coin toss  
by picking 0 or  
1 at random.  def RandomWalk (L): 
   hops = 0; x = 0  
   while abs(x) < L:  
      r = randi(0,1) 
      if r == 0:  
         x = x + 1  
      else: 
         x = x - 1  
      hops += 1  
   return hops  The Function  
RandomWalk (L) 
Hop right  
Hop left  The While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       "
"x = x+1 
    else: 
       x = x-1 
 To more fully understand how this works,  
let’s look at the execution of this while loop:  Understanding the While -Loop 
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x ="
" x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 0 to 1.  Understanding the While Loop  
x = 0 
while abs(x"
") < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues.  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3 "
"   4    5  
Assume r = 1  
 
Coin = Tails  
 
Hop Left  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is decreased  
from 1 to 0.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                    "
"                                    
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < "
"5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 0 to 1.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is t"
"rue.  
 
Robot not at 
boundary.  
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                        "
"                                
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 1 to 2.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5: "
" 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is"
" increased  
from 2 to 3.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                           "
"                             
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 1  
 
Coin = Tails  
 
Hop Left  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is decreased  
from 3 to 2.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    i"
"f r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues  Understandingthe  While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 1  
 
Coin ="
" Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 2 to 3.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                      "
"  
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r "
"== 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 3 to 4.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is true.  
 
Robot not at 
boundary.  "
"
 
Loop continues  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
Assume r = 0  
 
Coin = Heads  
 
Hop Right  Understanding the While Loop  
x = 0 
while abs(x) < 5:  
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-"
"5   -4   -3   -2   -1     0    1     2    3    4    5  
The value of X  
is increased  
from 4 to 5.  Understanding the While Loop  
x = 0 
while abs(x) < 5 : 
    r = randi(0,1) 
    if r == 0:  
       x = x+1 
    else: 
       x = x-1 
                                                        
-5   -4   -3   -2   -1     0    1     2    3    4    5  
abs(x) < 5 is False.  
 
Robot is on  the 
boundary.  
 
Loop 
TERMINATES  The Application Script  
     
if __name__ == '__main__':  
    n = 1000  # Number "
"of trials  
    for L in range(5,45,5):  
        print L, AveRandomWalk (L,n) 
     
 Check out the cases L = 5,10,15,,20,25,30,35,40 :  
 The Function  
AveRandomWalk (L,n) 
def AveRandomWalk (L,n): 
  s = 0   
    for k in range(0,n):  
   RequiredHops  = RandomWalk (L) 
      s += RequiredHops  
    ave = float(s)/float(n)  
    return ave 
     
                                                                   
L      Ave                                                     
------------               "
"                                         
5        24                                                      
10       93                                                       
15      219                                                       
20      399                                                       
25      649                                                      
30      917  
35     1259  
40     1594                                                   
                                              "
"        
Averages based on 1000 trials.  Sample Output  
Looks like  
doubling L 
increases the  
average by  
a factor of 4.  
Insight  
through  
Computing!  "
"UNDERSTANDING 
PROGRAM EFFICIENCY: 1 
(download slides and .py ﬁles and follow along!)
6.0001 LECTURE 10

6.0001	LECTURE	10	 1	Today
§ 	Measuring	orders	of	growth	of	algorithms	
§ 	Big	“Oh”	notaAon	
§ 	Complexity	classes	
6.0001	LECTURE	10	 2	WANT TO UNDERSTAND 
EFFICIENCY OF PROGRAMS
§ 	computers	are	fast	and	geGng	faster	–	so	maybe	eﬃcient 	
programs	don’t	maLer?	
◦ but	data	sets	can	be	very	large	(e.g.,	in	2014,	Google	served	
30,000,000,000,000	pages,	covering	100,000,000	GB	–	how	long	to	
search	b"
"rute	force?)	
◦ thus,	simple	soluAons	may	simply	not	scale	with	size	in	acceptable	
manner	
§ 
§ 	separate	!me	and	space	eﬃciency	 of	a	program	
§ 	tradeoﬀ	between	them:	
◦ can	someAmes	pre-compute	results	are	stored;	then	use	“lookup”	to	
retrieve	(e.g.,	memoizaAon	for	Fibonacci)	
◦ will	focus	on	Ame	eﬃciency	
6.0001	LECTURE	10	 3		how	can	we	decide	which	opAon	for	program	is	most	eﬃcient?	WANT TO UNDERSTAND 
EFFICIENCY OF PROGRAMS
Challenges	in	understanding	eﬃciency	of	soluAon	to	a	
computaAonal	problem"
":	
§ 	a	program	can	be	implemented	in	many	diﬀerent	
ways	
§ 	you	can	solve	a	problem	using	only	a	handful	of	
diﬀerent	algorithms	
§ 	would	like	to	separate	choices	of	implementaAon	
from	choices	of	more	abstract	algorithm	
6.0001	LECTURE	10	 4	HOW TO EVALUATE 
EFFICIENCY OF PROGRAMS
§ 	measure	with	a	!mer	
§ 	count	the	operaAons	
§ 	abstract	noAon	of	order 	of	growth	
6.0001	LECTURE	10	 5	
TIMING A PROGRAM
§ 	use	Ame	module	
§ 	recall	that	!imporAng	means	to	
bring	in	that	class	def c_to_f(c):!
into	you"
"r	own	ﬁle 	    return c*9/5 + 32 !
!
§	 start 	clock	 t0 = time.clock()!
§ 	call	funcAon	c_to_f(100000)!t1 = time.clock() - t0!
§ 	stop 	clock	Print(""t ="", t, "":"", t1, ""s,”) 
	
6.0001	LECTURE	10	 6	import time!
!TIMING PROGRAMS IS 
INCONSISTENT
§ 	GOAL:	to	evaluate	diﬀerent	algorithms	
§ 	running	Ame	 varies	between	algorithms	
§ 	running	Ame	 varies	between	implementa!ons
§ 	running	Ame	 varies	between	computers	
§ 	running	Ame	is	 not	predictable	based	on	small	
inputs		
§ 	Ame	varies	for	diﬀerent	inputs"
"	but		
	cannot	really	express	a	relaAonship		
	between	inputs	and	Ame	
6.0001	LECTURE	10	 7	COUNTING OPE
§ 	assume	these	steps	take	
constant	!me :	
• 	mathemaAcal	operaAons	
• 	comparisons	
• 	assignments	
• 	accessing	objects	in	memor
• 	then	count	the	number	of	
operaAons	executed	as	
funcAon	of	size	of	input	RATIONS
def c_to_f(c):!
    return c*9.0/5 + 32 !
!
def mysum(x):!    total = 0!
ange(x+1):!+= i!    for i in r        total 
y	    return tot  
mysum	à	1+3al!
6.0001	LECTURE	10	 8	x	ops	COUNTING O"
"PERATIONS IS 
BETTER, BUT STILL…
§ 	GOAL:	to	evaluate	diﬀerent	algorithms	
§ 	count	depends	on	algorithm	
§ 	count	depends	on	implementa!ons	
§ 	count	independent	of	computers	
§ 	no	clear	deﬁniAon	of	which	opera!ons	 to	count 	
§ 	count	varies	for	diﬀerent	inputs	and			
	can	come	up	with	a	relaAonship		
	between	inputs	and	the	count	
6.0001	LECTURE	10	 9	STILL NEED A BETTER WAY
• 	Aming	and	counAng	evaluate	implementa!ons	
• 	Aming	evaluates	machines	
• 	want	to	evaluate	algorithm	
• 	want	to	evaluate	sc"
"alability	
• 	want	to	evaluate	in	terms	of	input	size	
6.0001	LECTURE	10	 10	STILL NEED A BETTER WAY
§ 	Going	to	focus	on	idea	of	counAng	operaAons	in	an	
algorithm,	but	not	worry	about	small	variaAons	in	
implementaAon	(e.g.,	whether	we	take	3	or	4	primiAve	operaAons	to	execute	the	steps	of	a	loop)	
§ 	Going	to	focus	on	how	algorithm	performs	when	size	
of	problem	gets	arbitrarily	large	
§ 	Want	to	relate	Ame	needed	to	complete	a	
computaAon,	measured	this	way,	against	the	size	of	the	input	to	the	problem"
"	
§ 	Need	to	decide	what	to	measure,	given	that	actual	
number	of	steps	may	depend	on	speciﬁcs	of	trial		
6.0001	LECTURE	10	 11	NEED TO CHOOSE WHICH INPUT TO 
USE TO EVALUATE A FUNCTION
§ 	want	to	express	eﬃciency	in	terms	of	size	of	input ,	so	
need	to	decide	what	your	input	is	
§ 	could	be	an	integer		
		--	mysum(x) 
§ 	could	be	 length	of	list	 	
		--	list_sum(L) 
§ 	you	decide	 when	mulAple	parameters	to	a	funcAon	
		--	search_for_elmt(L, e) 
6.0001	LECTURE	10	 12	DIFFERENT INPUTS CHANGE 
HOW THE PROGR"
"AM RUNS
§ 	a	funcAon	that	searches	for	an	element	in	a	list	
def search_for_elmt(L, e):!
    for i in L:!        if i == e:!            return True!    return False!
§ 	when	e	is	ﬁrst	element	 in	the	list	à	BEST	CASE	
§ 	when	e	is	not	in	list	à	WORST	CASE	
§ 	when	look	through	about	half	of	the	elements	in	
list	à	AVERAGE	CASE	
§ 	want	to	measure	this	behavior	in	a	general	way	
6.0001	LECTURE	10	 13	BEST, AVERAGE, WORST CASES
§ 	suppose	you	are	given	a	list	L	of	some	length	len(L) 
§ 	best	case :	minimum	"
"running	Ame	over	all	possible	inputs	
of	a	given	size,	len(L) 
• 	constant	for	search_for_elmt 
• 	ﬁrst	element	in	any	list	
§ 	average	case :	average	running	Ame	over	all	possible	inputs	
of	a	given	size,	len(L) 
• 	pracAcal	measure	
§ 	worst	case:	maximum	running	Ame	over	all	possible	inputs	
of	a	given	size,	 le
• 	linear	in	length	ofn(L) 
	list	for	search_for_elmt 
• 	must	search	enAre	list	and	not	ﬁnd	it	
6.0001	LECTURE	10	 14	
ORDERS OF GROWTH
Goals:		
§ 	want	to	evaluate	program’s	eﬃciency	when	inpu"
"t	is	very	big	
§ 	want	to	express	the	growth	of	program’s	run	!me	 as	input	
size	grows	
§ 	want	to	put	an	upper	bound	on	growth	–	as	Aght	as	possible	
§ 	do	not	need	to	be	precise:	“order	of”	not	“exact”	 growth	
§ 	we	will	look	at	largest	factors	in	run	Ame	(which	secAon	of	
the	program	will	take	the	longest	to	run?)	
§ 	thus,	generally	we	want	!ght	upper	bound	on	growth,	as	
func!on	of	size	of	input,	in	worst	case 	
6.0001	LECTURE	10	 15	MEASURING ORDER OF 
GROWTH: BIG OH NOTATION
§ 	Big	Oh	notaAon	meas"
"ures	an	upper	bound	on	the	
asympto!c	growth,	oien	called	order	of	growth	
§ 	Big	Oh	or	O()	is	used	to	describe	worst	case	
• 	worst	case	occurs	oien	and	is	the	boLleneck	when	a	
program	runs	
• 	express	rate	of	growth	of	program	relaAve	to	the	input	
size	
• 	evaluate	algorithm	NOT	machine	or	implementaAon	
	6.0001	LECTURE	10	 16	
	EXACT STEPS vs O()
def fact_iter(n):!
    """"""assumes n an int >= 0""""""!    answer = 1!
    while n > 1:!
        answer *= n!
        n -= 1!
    return answer!
§ 	computes	fact"
"orial	
§ 	number	of	steps:	 		
§ 	worst	case	asymptoAc	complexity:		
• 	ignore	addiAve	constants	
• 	ignore	mulAplicaAve	constants	
6.0001	LECTURE	10	 17	WHAT DOES O(N)  MEASURE?
§ 	Interested	in	describing	how	amount	of	Ame	needed	
grows	as	size	of	(input	to)	problem	grows	
§ 	Thus,	given	an	expression	for	the	number	of	
operaAons	needed	to	compute	an	algorithm,	want	to	
know	asymptoAc	behavior	as	size	of	problem	gets	large	
§ 	Hence,	will	focus	on	term	that	grows	most	rapidly	in	a	
sum	of	terms	
§ 	And	w"
"ill	ignore	mulAplicaAve	constants,	since	want	to	
know	how	rapidly	Ame	required	increases	as	increase	size	of	input	
6.0001	LECTURE	10	 18	SIMPLIFICATION EXAMPLES
§ 	drop	constants	and	mulAplicaAve	factors	
§ 	focus	on	 dominant	terms	
 : n2	O(n2)	 + 2n + 2 
	O(n2)	 : n2 + 100000n + 31000  
	O(n)	 : log(n) + n + 4 
O(n	log	n)	 : 0.0001*n*log(n) + 300n 
	O(3n)	 : 2n30 + 3n  
6.0001	LECTURE	10	 19	TYPES OF ORDERS OF 
GROWTH
6.0001	LECTURE	10	 20	ANALYZING PROGRAMS AND 
THEIR COMPLEXITY
§ 	combine	complexit"
"y	classes	
• 	analyze	statements	inside	funcAons	
• 	apply	some	rules,	focus	on	dominant	term	
Law	of	Addi!on	for	O():		
• 	used	with	sequen!al 	statements	
• 	O(f(n))	+	O(g(n))	is	O(	f(n)	+	g(n)	)	
• 	for	example,	 		
  for i in range(n):!
      print('a')!
  for j in range(n*n):!
      print('b')!
is	O(n)	+	O(n*n)	=	O(n+n2)	=	O(n2)	because	of	dominant	term	
6.0001	LECTURE	10	 21	ANALYZING PROGRAMS AND 
THEIR COMPLEXITY
§ 	combine	complexity	classes	
• 	analyze	statements	inside	funcAons	
• 	apply	some	ru"
"les,	focus	on	dominant	term	
Law	of	Mul!plica!on	for	O():		
• 	used	with	nested	statements/loops	
• 	O(f(n))	*	O(g(n))	is	O(	f(n)	*	g(n)	)	
• 	for	example,	 		
  for i in range(n):!
      for j in range(n):!
          print('a')!
is	O(n)*O(n)	=	O(n*n)	=	O(n2)	because	the	outer	loop	goes	n	
Ames	and	the	inner	loop	goes	n	Ames	for	every	outer	loop	iter.	
6.0001	LECTURE	10	 22	COMPLEXITY CLASSES
§ 	O(1)	denotes	constant	running	Ame	
§ 	O(log	n) 	denotes	logarithmic	running	Ame	
§ 	O(n)	denotes	linear	running	"
"Ame	
§ 	O(n	log	n) 	denotes	log-linear	running	Ame	
§ 	O(nc)		denotes	polynomial	running	Ame	(c	is	a	
constant)	
§ 	O(cn)	denotes	exponenAal	running	Ame	(c	is	a	
constant	being	raised	to	a	power	based	on	size	of	
input)	
6.0001	LECTURE	10	 23	COMPLEXITY CLASSES 
ORDERED LOW TO HIGH
	
	O(1)  :	
		 							
	O(log n)  :	
		 							
	O(n)  :	
		 							
	O(n log n):	
		 							
	O
	 	
	O(nc)  :	
								
(cn)  :		 			constant	
	logarithmic	 		 	
					linear	
		loglinear	 	 	
	 	polynomial		exponenAal	
	
6.0001"
"	LECTURE	10	 24	
COMPLEXITY GROWTH
CLASS	 n=10	 =	100	 =	1000	 =	1000000	
O(1)	 1	 1	 1	 1	
O(log	n)	 1	 2	 3	 6	
O(n)	 10	 100	 1000	 1000000	
O(n	log	n)	 10	 200	 3000	 6000000	
O(n^2)	 100	 10000	 1000000	 1000000000000	
O(2^n)	 1024	 12676506
00228229
40149670
3205376	1071508607186267320948425049060
0018105614048117055336074437503
8837035105112493612249319837881569585812759467291755314682518714528569231404359845775746985748039345677748242309854210746050
6237114187795418215304647498358
19412673987675591"
"655439460770629145711964776865421676604298316
52624386837205668069376 	Good	luck!!	
6.0001	LECTURE	10	 25	
LINEAR COMPLEXITY
§ 	Simple	iteraAve	loop	algorithms	are	typically	linear	in
complexity		
6.0001	LECTURE	10	 26	LINEAR SEARCH  
ON UNSORTED  LIST
def linear_search(L, e):!
    found = False!    for i in range(len(L)):!        if e == L[i]:!            found = True!    return found!
	
§ 	must	look	through	all	elements	to	decide	it’s	not	there	
§ 	O(len(L))	for	the	loop	*	O(1)	to	test	if	e	==	L[i]	
◦ O"
"(1	+	4n	+	1)	=	O(4n	+	2)	=	O(n)	
§ 	overall	complexity	is	O(n)	–	where	n	is	len(L)		
6.0001	LECTURE	12	 27	CONSTANT TIME LIST ACCESS
§ 	if	list	is	all	ints	
◦ 	ith	element	at		
◦ base	+	4*i	
§ if	list	is	heterogeneous	
◦ 	indirecAon		
◦ 	references	to	other	objects	…	
…	
6.0001	LECTURE	12	 28	LINEAR SEARCH  
ON SORTED LIST
def search(L, e):!
    for i in range(len(L)):!
        if L[i] == e:!
            return True!
        if L[i] > e:!
            return False!
    return False 	
§ 	must	only	look	unAl"
"	reach	a	number	greater	than	e	
§ 	O(len(L))	for	the	loop	*	O(1)	to	test	if	e	==	L[i]	
§ 	overall	complexity	is	O(n)	–	where	n	is	len(L)		
§ 	NOTE:	 order	of	growth	is	same,	though	run	Ame	may	
diﬀer	for	two	search	methods	
6.0001	LECTURE	12	 29	LINEAR COMPLEXITY
§ 	searching	a	list	in	sequence	to	see	if	an	element	is	present	
§ 	add	characters	of	a	string,	assumed	to	be	composed	of	
decimal	digits	
def addDigits(s):!
    val = 0!    for c in s:!        val += int(c)!    return val!
§ 	O(len(s))	
6.0001	LE"
"CTURE	10	 30	LINEAR COMPLEXITY
§ 	complexity	oien	depends	on	number	of	iteraAons	
def fact_iter(n):!
    prod = 1!    for i in range(1, n+1):!
        prod *= i!
    return prod!
§ 	number	of	Ames	around	loop	is	n	
§ 	number	of	operaAons	inside	loop	is	a	constant	(in	this	case,	3	–	
set	i,	mulAply,	set	prod)	
◦ O(1	+	3n	+	1)	=	O(3n	+	2)	=	O(n)	
§ 	overall	just	O(n)	
6.0001	LECTURE	10	 31	NESTED LOOPS
§ 	simple	loops	are	linear	in	complexity	
§ 	what	about	loops	that	have	loops	within	them?	
6.0001	LECTURE"
"	10	 32	QUADRATIC COMPLEXITY
determine	if	one	list	is	subset	of	second,	i.e.,	every	element	
of	ﬁrst,	appears	in	second	(assume	no	duplicates)	
!
def isSubset(L1, L2):!    for e1 in L1:!        matched = False!        for e2 in L2:!            if e1 == e2:!                matched = True!                break!
        if not matched:!
            return False!    return True!
6.0001	LECTURE	10	 33	QUADRATIC COMPLEXITY
def isSubset(L1, L2):!
    for e1 in L1:!        matched = False!        for e2 in L2:!  "
"          if e1 == e2:!                matched =                 break!        if not matched:!            return False!    return True!
		 outer	loop	executed	len(L1)	
Ames	
	 each	iteraAon	will	execute	
inner	loop	up	to	len(L2)	
Ames,	with	constant	number	True!of	operaAons	
	 O(len(L1)*len(L2))	
	 worst	case	when	L1	and	L2	
same	length,	none	of	elements	of	L1	in	L2	
	 O(len(L1)
2)	
6.0001	LECTURE	10	 34	QUADRATIC COMPLEXITY
ﬁnd	intersecAon	of	two	lists,	return	a	list	with	each	element	
appearing	only	onc"
"e !
def intersect(L1, L2):!
    tmp = []!
    for e1 in L1:!
        for e2 in L2:!            if e1 == e2:!
                tmp.append(e1)!
    res = []!
    for e in tmp:!
        if not(e in res):!            res.append(e)!
    return res!
6.0001	LECTURE	10	 35	QUADRATIC COMPLEXITY
def intersect(L1, L2):!
    tmp = []!
    for e1 in L1:!
        for e2 in L2:!
            if e1 == e2:!               tmp.append(e
    res = []!
    for e in tmp:!
        if not(e in res):!
            res.append(e)!    re"
"turn res!
		 ﬁrst	nested	loop	takes	
len(L1)*len(L2)	steps	
	 second	loop	takes	at	
most	len(L1) 	steps	
1)!	 determining	if	element	
in	list	might	take	len(L1)	
steps	
	 if	we	assume	lists	are	of	
roughly	same	length,	then	
	 O(len(L1)^2)	
6.0001	LECTURE	10	 36	O() FOR NESTED LOOPS
def g(n):!
   """""" assume n >= 0 """"""!
   x = 0!   for i in range(n):!      for j in range(n):!
         x += 1!
   return x!
	
§ 	computes	n2	very	ineﬃciently	
§ 	when	dealing	with	nested	loops,	look	at	the	ranges	
§ 	nested	loo"
"ps,	each	itera!ng	n	!mes	
§ 	O(n2)	
6.0001	LECTURE	10	 37	THIS TIME AND NEXT TIME
§ 	have	seen	examples	of	loops,	and	nested	loops	
§ 	give	rise	to	linear	and	quadraAc	complexity	algorithms	
§ 	next	Ame,	will	more	carefully	examine	examples	from	
each	of	the	diﬀerent	complexity	classes	
6.0001	LECTURE	10	 38	MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall 2016
For information about citing these materials or our Terms of Use, visit: https://ocw.m"
it.edu/terms .
"UNDERSTANDING 
PROGRAM EFFICIENCY: 2 
(download slides and .py ﬁles and follow along!)
6.0001 LECTURE 11

6.0001	LECTURE	11	 1	TODAY
§ 	Classes	of	complexity	
§ 	Examples	characteris;c	of	each	class	
6.0001	LECTURE	11	 2	WHY WE WANT TO UNDERSTAND 
EFFICIENCY OF PROGRAMS
§ 	how	can	we	reason	about	an	algorithm	in	order	to	
predict	the	amount	of	;me	it	will	need	to	solve	a	
problem	of	a	par;cular	size?	
§ 	how	can	we	relate	choices	in	algorithm	design	to	the	
;me	eﬃciency	of	the	resul;ng	algorithm?	
◦ ar"
"e	there	fundamental	limits	on	the	amount	of	;me	we	
will	need	to	solve	a	par;cular	problem?	
6.0001	LECTURE	11	 3	ORDERS OF GROWTH: RECAP
Goals:		
§ 	want	to	evaluate	program’s	eﬃciency	when	input	is	very	big	
§ 	want	to	express	the	growth	of	program’s	run	5me	 as	input	
size	grows	
§ 	want	to	put	an	upper	bound	on	growth	–	as	;ght	as	possible	
§ 	do	not	need	to	be	precise:	“order	of”	not	“exact”	 growth	
§ 	we	will	look	at	largest	factors	in	run	;me	(which	sec;on	of	
the	program	will	take	the	longest	to	r"
"un?)	
§ 	thus,	generally	we	want	5ght	upper	bound	on	growth,	as	
func5on	of	size	of	input,	in	worst	case 	
6.0001	LECTURE	11	 4	COMPLEXITY CLASSES: RECAP
§ 	
§ 	
§ 	
§ 	
§ 	
co
§ 	
co
inO(1)	denotes	constant	running	;me	
O(log	n) 	denotes	logarithmic	running	;me	
O(n)	denotes	linear	running	;me	
O(n	log	n) 	denotes	log-linear	running	;me	
O(nc)		denotes	polynomial	running	;me	(c	is	a	
nstant)	
O(cn)	denotes	exponen;al	running	;me	(c	is	a	
nstant	being	raised	to	a	power	based	on	size	of	
put)	
6.0001	LECTUR"
"E	11	 5	
COMPLEXITY CLASSES 
ORDERED LOW TO HIGH
	
	
	O(1)  :	 	 			constant	
		 							
	O(log n)  :	 	 	logarithmic	
		 							
	O(n)  :	 	 						linear	
		 							
	O(n log n):	 	 			loglinear	
		 							
	O(nc)  :	 	 	polynomial	
	 								
	O(cn)  :	 	 	exponen;al	
6.0001	LECTURE	11	 6	
COMPLEXITY GROWTH
CLASS	 n=10	 =	100	 =	1000	 =	1000000	
O(1)	 1	 1	 1	 1	
O(log	n)	 1	 2	 3	 6	
O(n)	 10	 100	 1000	 1000000	
O(n	log	n)	 10	 200	 3000	 6000000	
O(n^2)	 100	 10000	 1000000	 1000000000000	
O(2^n)	 10"
"24	 12676506 1071508607186267320948425049060 Good	luck!!	
00228229 0018105614048117055336074437503
40149670 8837035105112493612249319837881
3205376	 569585812759467291755314682518714528569231404359845775746985748039345677748242309854210746050
6237114187795418215304647498358
19412673987675591655439460770629145711964776865421676604298316
52624386837205668069376 	
6.0001	LECTURE	11	 7	
CONSTANT COMPLEXITY
§ 	complexity	independent	of	inputs	
§ 	very	few	interes;ng	algorithms	in	this	class,	but	can	
oYen	have	"
"pieces	that	ﬁt	this	class	
§ 	can	have	loops	or	recursive	calls,	but	ONLY	IF	number	
of	itera;ons	or	calls	independent	of	size	of	input	
6.0001	LECTURE	11	 8	LOGARITHMIC COMPLEXITY
§ 	complexity	grows	as	log	of	size	of	one	of	its	inputs	
§ 	example:	
◦ bisec;on	search	
◦ binary	search	of	a	list	
6.0001	LECTURE	11	 9	BISECTION SEARCH
§ 	suppose	we	want	to	know	if	a	par;cular	element	is	
present	in	a	list	
§ 	saw	last	;me	that	we	could	just	“walk	down”	the	list,	
checking	each	element	
§ 	complexity	was	lin"
"ear	in	length	of	the	list	
§ 	suppose	we	know	that	the	list	is	ordered	from	
smallest	to	largest	
◦ saw	that	sequen;al	search	was	s;ll	linear	in	complexity	
◦ can	we	do	becer?	
6.0001	LECTURE	11	 10	BISECTION SEARCH
1. pick	an	index,	i,	that	divides	list	in	half	
2. ask	if	L[i] == e 
3. if	not,	ask	if	L[i] is	larger	or	smaller	than	e 
4.   L e 
A	new	version	of	a	divide-and-conquer	algorithm	
§ break	into	smaller	version	of	problem	(smaller	list),	plus	
some	simple	opera;ons	
§ answer	to	smaller	version	is"
"	answer	to	original	problem	depending	on	answer,	search	leY	or	right	half	of for	
6.0001	LECTURE	11	 11	BISECTION SEARCH 
COMPLEXITY ANALYSIS
§ 	ﬁnish	looking
through	list	
when		
				1	=	n/2i		
				so	i	=	log	n	
	
	 §	 complexity	of	
recursion	is	
O(log	n)	–	where	n	is	 len(L)	
6.0001	LECTURE	11	 12		
…	
…BISECTION SEARCH IMPLEMENTATION 1def bisect_search1(L, e):!    if L == []:!        return False!    elif len(L) == 1:!        return L[0] == e!    else:!        half = len(L)//2!        if L[half] > e:!"
"            return bisect_search1( L[:half], e)!        else:!            return bisect_search1( L[half:], e)!	6.0001	LECTURE	11	13	COMPLEXITY OF FIRS T 
ETHOD BISECTION SEARCH M
§ 	implementa5on	1	–	bisect_search1	
• 	O(log	n)	bisec;on	search	calls	
ll,	size	of	range	to	be	searched	is	cut	in	half	
	size	n,	in	worst	case	down	to	range	of	size	1	
	when	k	=	log	n	
;on	search	call	to	copy	list	
	up	each	call,	so	do	this	for	each	level	of	
(n	log	n)	
eful,	note	that	length	of	list	to	be	
d	on	each	recursive	ca"
"ll	
ost	to	copy	is	O(n)	and	this	dominates	the	log	
ursive	calls	
6.0001	LECTURE	11	 14	• On	each	recursive	ca
• If	original	range	is	of
when	n/(2^k)	=	1;	or
• O(n)	for	each	bisec
• This	is	the	cost	to	set
recursion		
• O(log	n)	*	O(n)	à	O
• 	if	we	are	really	car
copied	is	also	halve
• turns	out	that	total	c
n	cost	due	to	the	recBISECTION SEARCH 
ALTERNATIVE
§ 	s;ll	reduce	size	of	
problem	by	factor	
of	two	on	each	step	
§ 	but	just	keep	track	
of	low	and	high	
por;on	of	list	to	be	
searched	
§ 	avoid	copy"
"ing	the	
list	
	
§ 	complexity	of	
recursion	is	again	
O(log	n)	–	where	n	
is	len(L)	
6.0001	LECTURE	11	 15	
def bisect_search2(L, e):!
    def bisect_search_helper(L, e, low, high):!        if high == low:!            return L[low] == e!        mid = (low + high)//2!
        if L[mid] == e:!
            return True!        elif L[mid] > e:!            if low == mid: #nothing left to search!                return False!            else:!
                return bisect_search_helper(L, e, low, mid - 1)!
     "
"   else:!            return bisect_search_helper(L, e, mid + 1, high)!    if len(L) == 0:!
        return False!
    else:!        return bisect_search_helper(L, e, 0, len(L) - 1)!
6.0001	LECTURE	11	 16	BISECTION SEARCH 
IMPLEMENTATION 2COMPLEXITY OF SECOND 
BISECTION SEARCH METHOD
§ 	implementa5on	2	–	bisect_search2	and	its	helper	
• O(log	n)	bisec;on	search	calls	
• On	each	recursive	call,	size	of	range	to	be	searched	is	cut	in	half	
• If	original	range	is	of	size	n,	in	worst	case	down	to	range	of	size	"
"1	
when	n/(2^k)	=	1;	or	when	k	=	log	n	
• pass	list	and	indices	as	parameters	
• list	never	copied,	just	re-passed	as	a	pointer	
• thus	O(1)	work	on	each	recursive	call	
• O(log	n)	*	O(1)	à	O(log	n)	
6.0001	LECTURE	11	 17	LOGARITHMIC COMPLEXITY
def intToStr(i):!
    digits = '0123456789'!
    if i == 0:!        return '0'!    result = ''!    while i > 0:!
        result = digits[i%10] + result!
        i = i//10!    return result!
!
6.0001	LECTURE	11	 18	LOGARITHMIC COMPLEXITY
def intToStr(i):! 	 only	hav"
"e	to	look	at	loop	as	
no	func;on	calls	
	 within	while	loop,	constant	
number	of	steps	
	 how	many	;mes	through	
!loop?	
◦ how	many	;mes	can	one	
divide	i	by	10?	
◦ O(log(i))	    digits = '0123456789'!
    if i == 0:!        return '0'!    res = ''!    while i > 0:!        res = digits[i%10] + res        i = i//10!    return result!
	
6.0001	LECTURE	11	 19	LINEAR COMPLEXITY
§ 	saw	this	last	;me	
◦ 	searching	a	list	in	sequence	to	see	if	an	element	is	
present	
◦ 	itera;ve	loops	
6.0001	LECTURE	11	 20	O() F"
"OR ITERATIVE FACTORIAL
er	of	itera;ve	calls	
):!
p,	constant	cost	each	§ 	complexity	can	depend	on	numb
def fact_iter(n):!
    prod = 1!
    for i in range(1, n+1
        prod *= i!    return prod!
§ 	overall	O(n) 	–	n	;mes	round	loo
;me	
6.0001	LECTURE	11	 21	O() FOR RECURSIVE 
FACTORIAL
def fact_recur(n):!
    """""" assume n >= 0 """"""!
    if n <= 1: !
        return 1!
    else: !
        return n*fact_recur(n – 1)!
	
t	runs	a	bit	slower	than	
	calls	
f	func;on	calls	is	linear	
p	call	
l	implementa;ons	ar"
"e	
22	§ 	computes	factorial	recursively	
§ 	if	you	;me	it,	may	no;ce	that	i
itera;ve	version	due	to	func;on
§ 	s;ll	O(n) 	because	the	number	o
in	n,	and	constant	eﬀort	to	set	u
§ 	itera5ve	and	recursive	factoria
the	same	order	of	growth	
6.0001	LECTURE	11	LOG-LINEAR COMPLEITY 
is	merge	sort	§ 	many	prac;cal	algorithms	are	log-linear	
§ 	very	commonly	used	log-linear	algorithm	
§ 	will	return	to	this	next	lecture	
6.0001	LECTURE	11	 23	POLYNOMIAL COMPLEXITY
§ 	most	common	polynomial	algorithms	are	quadra;c"
",	
i.e.,	complexity	grows	with	square	of	size	of	input	
§ 	commonly	occurs	when	we	have	nested	loops	or	
recursive	func;on	calls	
§ 	saw	this	last	;me	
6.0001	LECTURE	11	 24	EXPONENTIAL COMPLEXITY
§ 	recursive	func;ons	where	more	than	one	recursive	
call	for	each	size	of	problem	
◦ Towers	of	Hanoi	
§ 	many	important	problems	are	inherently	exponen;al	
◦ unfortunate,	as	cost	can	be	high	
◦ will	lead	us	to	consider	approximate	solu;ons	as	may	
provide	reasonable	answer	more	quickly	
6.0001	LECTURE	11	 25	COM"
"PLEXITY  OF TOWERS OF 
HANOI
§ 	Let	tn		denote	;me	to	solve	tower	of	size	n	
§ 	tn	=	2tn-1	+	1	
§ 					=	2(2tn-2	+	1)	+	1	
§	 				=	4tn-2	+	2	+	1	
§ 					=	4(2t 	+	1)	+	2	+	1	 Geometric	growth	n-3	§ 					=	8tn-3	+	4	+	2	+	1	a	=											2n-1	+	…			+	2		+	1	
§ 					=	2k	tk-
n-k	+	21	+	…	+	4	+	2	+	1	 2a	=	2n	+	2n-1		+	...	+	2	
a			=	2n																												-	1	§ 					=	2n-1	+	2n-2	+	...	+	4	+	2	+	1	
§ 					=	2n	–	1	
§	 so	order	of	growth	is	O(2n)	
6.0001	LECTURE	11	 26	EXPONENTIAL COMPLEXITY
§ 	given"
"	a	set	of	integers	(with	no	repeats),	want	to	
generate	the	collec;on	of	all	possible	subsets	–	called	
the	power	set	
§ 	{1,	2,	3,	4}	would	generate	
◦ {},	{1},	{2},	{3},	{4},	{1,	2},	{1,	3},	{1,	4},	{2,	3},	{2,	4},	{3,	4},	
{1,	2,	3},	{1,	2,	4},	{1,	3,	4},	{2,	3,	4},	{1,	2,	3,	4}	
§ 	order	doesn’t	macer	
◦ {},	{1},	{2},	{1,	2},	{3},	{1,	3},	{2,	3},	{1,	2,	3},	{4},	{1,	4},	{2,	
4},	{1,	2,	4},	{3,	4},	{1,	3,	4},	{2,	3,	4},	{1,	2,	3,	4} 	
6.0001	LECTURE	11	 27	POWER SET – CONCEPT 
§ we	want	to	generate	the	"
"power	set	of	integers	from	1	to	n
§ 	assume	we	can	generate	power	set	of	integers	from	1	to	
n-1	
§ 	then	all	of	those	subsets	belong	to	bigger	power	set	
all	of	those	subsets	with	n	
long	to	the	bigger	power	set	(choosing	not	include	n);	and	
added	to	each	of	them	also	be(choosing	to	include	n)	
§ 	{},	{1},	{2},	{1,	2},	{3},	{1,	3},	{2,	3},	{1,
4},	{3,	4},	{1,	3,	4},	{2,	3,	4},	{1,	2,	3,	4} 		
	2,	3},	{4},	{1,	4},	{2,	4},	{1,	2,	
	
§ 	nice	recursive	descrip;on!	
6.0001	LECTURE	11	 28	
EXPONENTIAL COMPLEXIT"
"Y
def genSubsets(L):!
    res = []!    if len(L) == 0:!
        return [[]] #list of empty list!
    smaller = genSubsets(L[:-1]) # all subsets without 
 last elementlast element!
    extra = L[-1:] # create a list of just    new = []!
    for small in smaller:!
        new.append(small+extra)  # for all smaller 
solutions, add one with last element!
    return smaller+new  # combine those with last 
element and those without!
6.0001	LECTURE	11	 29	!EXPONENTIAL COMPLEXITY
	 assuming	append	is	
constant	;m"
"e	
	 ;me	includes	;me	to	solve	
smaller	problem,	plus	;me	    smaller = genSubsets(L[:-1])!needed	to	make	a	copy	of	    extra = L[-1:]!all	elements	in	smaller	    new = []!problem	    for small in smaller:!
        new.append(small+extra)!    return smaller+new!
	def genSubsets(L):!
    res = []!    if len(L) == 0:!        return [[]] !
6.0001	LECTURE	11	 30	EXPONENTIAL COMPLEXITY
def genSubsets(L):! 	 but	important	to	thin
    res = []! about	size	of	smaller	
    if len(L) == 0:!k	
        return [[]] ! 	"
" know	that	for	a	set	of	size	
    smaller = genSubsets(L[:-1])! k	there	are	2k	cases	
    extra = L[-1:]!
    new = []!	 how	can	we	deduce	
    for small in smaller:! overall	complexity?	
        new.append(small+extra)!
    return smaller+new!
	
6.0001	LECTURE	11	 31	EXPONENTIAL COMPLEXITY
§ 	let	tn	denote	;me	to	solve	problem	of	size	n	
§ 	let	sn	denote	size	of	solu;on	for	problem	of	size	n	
§ 	tn	=	tn-1	+	sn-1	+	c	(where	c	is	some	constant	number	of	
opera;ons)	
§ 	tn	=	tn-1	+	2n-1	+	c	
§ 					=	tn-2	+	"
"2n-2	+	c	+	2n-1	+	c	
Thus	§	 				=	tn-k	+	2n-k	+	…	+	2n-1	+	kc	compu;ng	
§ 					=	t0	+	20	+	...	+	2n-1	+	nc	 power	set	is		
§ 					=	1	+	2n		+	nc	 O(2n)	
6.0001	LECTURE	11	 32	COMPLEXITY CLASSES
§ 	O(1)	–	code	does	not	depend	on	size	of	problem	
§ 	O(log	n) 	–	reduce	problem	in	half	each	;me	through	
process	
§ 	O(n)	–	simple	itera;ve	or	recursive	programs	
§ 	O(n	log	n) 	–	will	see	next	;me	
§ 	O(nc)	–	nested	loops	or	recursive	calls	
§ 	O(cn)	–	mul;ple	recursive	calls	at	each	level	 	
6.0001	LECTURE	11	 "
"33	SOME MORE EXAMPLES OF 
ANALYZING COMPLEXITY
6.0001	LECTURE	11	 34	COMPLEXITY OF  
ITERATIVE FIBONACCI
def fib_iter(n):!§     if n == 0:! 	Best	case:	
        return 0! O(1)	
    elif n == 1:!
        return 1! § 	Worst	case:	
    else:!O(1)	+	O(n)	+	O(1)	è	O(n)	        fib_i = 0!        fib_ii = 1!
	
        for i in range(n-1):!            tmp = fib_i!            fib_i = fib_ii!
  fib_ii = tmp + fib_ii!turn fib_ii !                  re
6.0001	LECTURE	11	 36	COMPLEXITY OF  
RECURSIVE FIBONACCI
def fib"
"_recur(n):!
    """""" assumes n an int >= 0 """"""!
    if n == 0:!
        return 0!
    elif n == 1:!
        return 1!
    else:!        return fib_recur(n-1) + fib_recur(n-2)!
 
§ 	Worst	case :	
O(2n)	
6.0001	LECTURE	11	 37	COMPLEXITY OF RECURSIVE 
FIBONACCI  
 fib(5) 
 
 fib(4) fib(3) 
 
 fib(3) fib(2) fib(2) fib(1) 
 
 fib(2) fib(1) 
§ 	actually	can	do	a	bit	becer	than	2n	since	tree	of	
cases	thins	out	to	right		
§ 	but	complexity	is	s;ll	exponen;al	
6.0001	LECTURE	11	 38	BIG OH SUMMARY
§ 	compare	eﬃcienc"
"y	of	algorithms	
• 	nota;on	that	describes	growth	
• 	lower	order	of	growth	 is	becer	
• 	independent	of	machine	or	speciﬁc	implementa;on	
§ 	use	Big	Oh	
• 	describe	order	of	growth	
• 	asympto5c	nota5on	
• 	upper	bound	
• 	worst	case	analysis	
6.0001	LECTURE	11	 40	COMPLEXITY OF COMMON 
PYTHON FUNCTIONS
 § 	Lists:	n is	len(L) § 	Dic;onaries:	n is	len(d)
• 	index	 	O(1)	§	 worst	case	
• 	store	 	O(1)	 • 	index	 	O(n)	
• 	length	 	O(1)	 • 	store	 	O(n)	
• 	append	 	O(1)	 • 	length	 	O(n)	
• 	==		 	O(n)	 • 	"
"delete	 	O(n)	
• 	remove	 	O(n)	 • 	itera;on	 	O(n)	
• 	copy	 	O(n)	 §	 	average	case	
• 	reverse	 	O(n)	 • 	index	 	O(1)	
• 	itera;on	 	O(n)	 • 	store	 	O(1)	
• 	in	list 	O(n)	 • 	delete	 	O(1)	
• 	itera;on	 	O(n)	
6.0001	LECTURE	11	 41	MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall 2016
For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms ."
"12. Logical Maneuvers  
Topics:  
 Loop-Body Returns  
 Exceptions  
 Assertions  
 Type Checking  
 Try-Except  
 
 Loop-Body Returns  Loop-Body Returns  
Another way to terminate a loop.  
 
Uses the fact that in a function, control  
is passed back to the calling program  
as soon as a return statement is encountered.  
 A Problem  
Write a function  
 
                        MyFind(char,s)  
 
that returns True  if character char   is in  
string  s  and  returns False otherwise.  
 
 
. Typical While "
"-Loop Solution  
When the loop ends, if  k== len(s) is True,  
 then we never found an instance of char .  def MyFind(char,s): 
   k = 0 
   while k< len(s) and char!=s[k]:  
      k = k+1 
   if k==len(s): 
      return False  
   else: 
      return True  
 While -Loop Solution  
with a Loop -Body Return  
def MyFind(char,s): 
   k = 0 
   while k< len(s): 
      if s[k]==char  
         return True  
      k = k+1 
   return False  
 
The function “jumps out of the loop” and returns  True should  
 it en"
"counter an instance of char . If the loop runs to completion,  
that means there is no instance of char .  For Loop Solution with a  
Loop Body return   
def MyFind(char,s): 
   for k in range( len(s)): 
       if s[k]==char:  
          return True  
   return False  
 
The function “jumps out of the loop” and returns  True should  
 it encounter an instance of char . If the loop runs to completion,  
that means there is no instance of char .  Another For Loop Solution with a  
Loop Body return   
def MyFi"
"nd(char,s): 
   for c in s:  
       if c==char:  
          return True  
   return False  
 
The function “jumps out of the loop” and returns  True should  
 it encounter an instance of char . If the loop runs to completion,  
that means there is no instance of char .  Boolean Variables  Review: Variables and floats  
It is possible to assign a float value to a  variable:  
 
 a = 1.3 
 b = 10.1  
 c = 3.7 
 r = -b + math.sqrt (b*b-4*a*c))/(2*a)  
  Review: Variables and ints 
It is possible to assign a s"
"tring value to a  
variable:  
 
 m = ‘7’ 
 d = ’4’ 
 y = ‘1776’  
 date = m + ‘/’ + d + ‘/’ + y  
  
  
  Review: Variables and Booleans  
It is possible to assign a boolean  value to a  
variable:  
 
 L = 1 
 R = 2 
 x = 1.3  
 inside = (L<=x) and (x<=R)  
  
  
  Boolean Variables  
 
As the course progresses you will be dealing  
with logical situations that are increasingly 
complicated.  
 
Boolean variables are a handy way of keeping  
track of what is going on.  
  
  
  Example: Leap Year  
 
Greg"
"orian Calendar Rule:  
 
 Y is a leap year if it is a century year that 
 is divisible by 400 or a non -century year 
 that is divisible by 4.  
 
Leap years: 1904, 2000, 2016  
 
Not leap years: 1900, 2015  
 
 
 
  Example: Leap Year  
Gregorian Calendar Rule:  
 
 Y is a leap year if it is a century year that  
  is divisible by 400 or a non -century year   
 that is divisible by 4.  
 
centuryYear  = (Y%100==0)  
if centuryYear : 
 LY = (Y%400==0)  
else: 
 LY = (Y%4==0)  
 Y is a positive int.  
 
LY i"
"s assigned the  
value  True if Y  
is a leap year and  
False otherwise.  Boolean Functions  Boolean Functions  
 
A function can return a boolean  value.  
 
This can be a handy way of encapsulating  
a complicated computation that culminates  
in the production of a True value or a False 
value.  
  
  
  Example:  Intersecting Squares  
 
 
 
 
 
 
 
 
                                                
 
 
 
 
 
 
 
                                               
Given two unit squares and a point, when i"
"s the  
point inside both squares?  A unit square  
has side length  
one.  Point in a Unit Square  
 
 
 
 
 
 
 
 
                                               Must have:  
 
      a <= x <= a+1  
 
      b <= y <= b+1  
(a,b) (a+1,b)  (a,b+1)  (a+1,b+1)  
(x,y) 
xOK = (a<=x<=a+1)  
yOK = (b<=y<=b+1)  Point in a Unit Square  
def inS(a,b,x,y): 
   “”” Returns True if ( x,y) is inside  
   the square with vertices ( a,b), 
   (a+1,b),(a,b+1), and (a+1,b+1).  
   Otherwise, returns False.”””  
   xOK = (a"
"<=x<=a+1)  
   yOK = (b<=y<=b+1)  
   z = (xOK and yOK) 
   return z  Using inS 
z2 = inS(a1,b1,x,y) and inS(a2,b2,x,y)  
z2 is True if and only if  ( x,y)  is inside  
 
   (i)  the unit square with lower left vertex (a1,b1).  
 
and also  
 
   (ii) the unit square with lower left vertex (a2,b2).  Exceptions  
Exceptions are errors that occur while your  
program is running. The program stops running  
when an exception is “raised.”  
 
There are many types of exceptions.  
 
Here are some examples…  Valu"
"eError  
>>> t = int(‘12F’) 
 
ValueError : invalid literal for 
int() with base 10: '123F‘  
 
In English:  
 
 The int function does not accept  a 
string unless it encodes a number.  ImportError  
>>> from superMath  import sqrt 
 
ImportError : No module named 
superMath  
 
In English:  
 
 You cannot import stuff from a  
nonexistent module or a module that is 
not in the same working directory  ImportError  
>>> >>> from math import SquareRoot  
 
ImportError : cannot import name 
SquareRoot  
 
In E"
"nglish:  
 
 the math module does not contain a  
function named SquareRoot  NameError  
>>> x = 3  
>>> x = y+2  
 
NameError : name 'y' is not defined  
 
In English:  
 
 The variable y does not exist.  TypeError  
>>> x = 3  
>>> s = ' abc' 
>>> t = s/x  
 
TypeError : unsupported operand 
type(s) for /: ' str' and 'int' 
 
In English:  
 
 You cannot divide a string by a 
number.  TypeError  
>>> from math import sqrt 
>>> x = sqrt('a') 
 
TypeError : a float is required  
 
In English:  
 
 The square"
" root function requires  
a  number.  ZeroDivisionError  
>>> x = 3.0/0.0  
ZeroDivisionError : float division by 
zero 
 
In English:  
 
 Cannot divide by zero.  Assertions   
They enable you to generate exceptions if  
something is wrong.  
 
A good way to check that your code is  
doing what it should be doing.  
 
A good way to focus on pre - and post - conditions  
during the program development phase.  
 
 
 Assertions: How They Work   
Syntax:     
          assert  B,S    
B is a boolean  expressio"
"n .  
 
S is a string.  
 
If B is not true,  then string S is printed  
and an exception is “raised”.  
 
Otherwise, nothing is done.  Checking Pre -, Post - Conditions  
 
Typical:  
 
     
    1. At the start of a function body, are  
     the preconditions satisfied?  
    2. At the end of the function body, does  
        the value returned have the required  
        properties?  
 
 Checking Pre -, Post Conditions  
def sqrt(x): 
   """""" Returns an approximate  
  square root of x in that  
   |L*L-x"
"| <= .001  
    
   PreC: x is a positive number.  
   """""" Checking Pre -,  Post conditions  
def sqrt(x): 
      
   assert x>0, 'The sqrt function 
  requires a positive argument.'  
    L = float(x)  
    L = (L+x/L)/2 
    L = (L+x/L)/2 
    L = (L+x/L)/2 
    L = (L+x/L)/2 
    assert abs(L*L -x)<=.001,   
        'Inaccurate Square Root'  
    return L  Type Checking  
Use assert  and the function isinstance  How isinstance  Works 
It is a boolean -valued function with two arguments.  
 
isinstance (x"
",int)   
  True if variable x houses an int value  
  Otherwise, False  
isinstance (x,float)   
  True if variable x houses a float value  
  Otherwise, False  
isinstance (x,str)   
  True if variable x houses a string value  
  Otherwise, False  
 Using isinstance   
def sqrt(x): 
  assert isinstance (x,float) or 
         isinstance (x,int), 
         print ‘x must be type int or 
                float’ 
    : Guard against the user passing a string to sqrt : The Try-except 
Construction   
A graceful w"
"ay to handle exceptions  Example:Try -Except  
try: 
 
    from AintNoMath  import sqrt 
    print 'AintNoMath.sqrt  unavailable'  
 
except ImportError : 
 
   from math import sqrt 
     print ‘AintNoMath.sqrt  is  not  
             available‘  
 
# Code that uses sqrt... 
a = 9; x = sqrt(a); print a,x 
If the green code triggers an ImportError  exception, then  
the mauve code is executed and “ sqrt” comes from the math 
module. Otherwise sqrt comes from AintNoMath  Try-Except Construction   
try: 
 
 
"
" 
 
 
except                :                                                         
         Code that may generate  
  a particular exception  
 
 
                                                       
          Code to execute if  
   the particular     
 exception is found  
 
 Name  of Exception  break break 
Another way to terminate a loop  
 
But it must be used with care for style reasons.  How break Works  
As soon as a break statement is executed  
inside a loop body, the loop ends and the  
n"
"ext statement after the body is executed.  Example  
Compute the smallest N so that N!>10  
fact = 1  
for N in range(1,10000):  
      fact = fact*N  
      if fact>10:  
          print N 
          break 
print fact  Loop range  
big enough 
to ensure  
we will get  
a large  
enough 
factorial  
                                            Recall that   5! = 1 x 2 x 3 x 4 x5  Example  
Print the smallest N so that N!>10  
fact = 1  
for N in range(1,10000):  
      fact = fact*N  
      if fact>10:  
   "
"       print N 
          break 
print fact  
Bad Style! Have to guess a suitable for -loop  range.  While Loop Solution  
Compute the smallest N so that N!>10  
fact = 1  
N = 1 
# fact = N!  
while fact <=10:  
      N = N+1 
      fact = fact*N     
print fact  A Good Example of break  Usage  
Consider the following problem.  
 
A user enters an integer N from the keyboard  
and Python is to display the value of N!  
 
Recall:  5! = 1x2x3x4x5 = 120  
 
Use math.factorial (N) A Good Example of break  Usag"
"e  
Possible issue.  
 
When we use  math.factorial (N), the value 
of N must be nonnegative.  
 
What if the user inputs -5? 
 
Would like to say, “try again”  A Good Example of break Usage  
 
while True:  
   N = raw_input (‘Enter pos int: ’) 
   N = int(N) 
   if N>=0 
      break 
   else: 
      print ‘N must be nonnegative’  
print math.factorial (N) 
                                Keep iterating until a nonnegative int is obtained  Another Issue  
If the user doesn’t enter a string of  
digits then"
" the int statement will crash  
the program:  
 
     N = raw_input (‘Enter pos int: ’) 
  N = int(N) 
 
This brings up the challenge of “exceptions” and  
“exception handling.”  
 A ValueError  Exception  
>>> int('12F') 
ValueError : invalid literal for int()  
    with base 10: '12F'  
Exception a.k.a. run time error  Challenge  
Is there a way we can keep soliciting  
keyboard input until the user enters a  
string of numbers?  
 
Don’t want the program to terminate because  
of a ValueError . The Try-e"
"xcept 
Construction   
A graceful way to handle exceptions  Example Showing Try -Except  
from math import factorial  
 
while True:  
   n = raw_input ('Enter an integer: ')  
   try: 
       n = int(n) 
       break 
   except ValueError : 
       print 'Invalid input. Try again.'  
 
m = factorial(n)  
print m                    
 
 
                                                                                                                                   
 
 
 How It Works  
from math import fact"
"orial  
 
while True:  
   n = raw_input ('Enter an integer: ')  
   try: 
       n = int(n) 
       break 
   except ValueError : 
       print 'Invalid input. Try again.'  
 
print factorial(n  
If int(n) in the green block triggers a ValueError  
 exception, then control passes to the cyan block.  
A message is printed and the loop continues                     
 
                   How It Works  
from math import factorial  
 
while True:  
   n = raw_input ('Enter an integer: ')  
   try: 
       n = i"
"nt(n) 
       break 
   except ValueError : 
       print 'Invalid input. Try again.'  
 
print factorial(n)  
If int(n) does not trigger a ValueError  exception,  
then the break is executed and the loop is over  
and control passes to the print factorial(n) line                     
 
                   "
"SEARCHING AND 
SORTING ALGORITHMS 
(download slides and .py ﬁles and follow along!)
6.0001 LECTURE 12

6.0001	LECTURE	12	 1	SEARCH ALGORITHMS
§	search	algorithm	–	method	for	ﬁnding	an	item	or	
group	of	items	with	speciﬁc	properAes	within	a	
collecAon	of	items	
§	collecAon	could	be	implicit	
◦example	–	ﬁnd	square	root	as	a	search	problem	
◦exhausAve	enumeraAon	
◦bisecAon	search	
◦Newton-Raphson	
§	collecAon	could	be	explicit	
◦example	–	is	a	student	record	in	a	stored	collecAon	of	
data?	
6.0001	LECTURE	"
"12	 2	SEARCHING ALGORITHMS
§	linear	search	
•	brute	force	 search	(aka	BriAsh	Museum	algorithm)	
•	list	does	not	have	to	be	sorted	
§	bisecAon	search	
•	list	MUST	be	sorted	to	give	correct	answer	
•	saw	two	diﬀerent	implementaAons	of	the	algorithm	
6.0001	LECTURE	12	 3	LINEAR SEARCH  
ON UNSORTED  LIST: RECAP
def linear_search (L, e):
    found = False
    for i in  range(len(L)):
if e == L[i]:
found = True
    return found
	
§	must	look	through	all	elements	to	decide	it’s	not	there	
§	O(len (L))	for	the	"
"loop	*	O(1)	to	test	if	e	==	L[ i]	
§	overall	complexity	is	 O(n)	–	where	n	is	len(L)		
6.0001	LECTURE	12 	 4	LINEAR SEARCH  
ON SORTED  LIST: RECAP
def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True        if L[i] > e:            return False    return False
	
§ 	must	only	look	unAl	reach	a	number	greater	than	e	
§ 	O(len(L))	for	the	loop	*	O(1)	to	test	if	e	==	L[i]	
§ 	overall	complexity	is	O(n)	–	where	n	is	len(L)		
6.0001	LECTURE	12	 5	USE BISECTION SEARCH: 
RECA"
"P
1.Pick	an	index,	i, 	that	divides	list	in	half	
2.Ask	if	L[i] == e
3.If	not,	ask	if	L[i] is	larger	or	smaller	than	e
4.Depending	on	answer,	search	le_	or	right	half	of L for 	e
A	new	version	of	a	divide-and-conquer	algorithm	
§Break	into	smaller	version	of	problem	(smaller	list),	plus	
some	simple	operaAons	
§Answer	to	smaller	version	is	answer	to	original	problem	
6.0001	LECTURE	12	 6	def bisect_search2(L, e):
    def bisect_search_helper(L, e, low, high):
if high == low:
return L[low] == e
mid = (low +"
" high)//2
if L[mid] == e:
return True
elif L[mid] > e:
if low == mid: #nothing left to search
return False
else:
return bisect_search_helper(L, e, low, mid - 1)
else:
return bisect_search_helper(L, e, mid + 1, high)
    if len(L) == 0:
return False
    else:
return bisect_search_helper(L, e, 0, len(L) - 1)BISECTION SEARCH 
IMPLEMENTATION: RECAP
6.0001	LECTURE	12	 7	COMPLEXITY OF BISECTION 
SEARCH: RECAP
§	bisect_search2	and	its	helper	
•	O(log	n)	bisecAon	search	calls	
•reduce	size	of	problem	by	factor	of"
"	2	on	each	step	
•	pass	list	and	indices	as	parameters	
•	list	never	copied,	just	re-passed	as	pointer	
•	constant	work	inside	funcAon	
•	à	O(log	n)	
6.0001	LECTURE	12	 8	SEARCHING A SORTED LIST 
-- n is len(L)
§	using	linear	search ,	search	for	an	element	is	O(n)	
§	using	binary	search ,	can	search	for	an	element	in	O(log	n)	
•	assumes	the	list	is	sorted!	
§	when	does	it	make	sense	to	sort	ﬁrst	then	search ?	
•	SORT	+	O(log n)	<	O(n) 	 	à	SORT	<	O(n)	–	O(log n)	
•	when	sorAng	is	less	than	O(n)	
•	NEVER	TR"
"UE!	
•to	sort	a	collecEon	of	n	elements	must	look	at	each	one	at	
least	once! 	
6.0001	LECTURE	12	 9	AMORTIZED COST 
-- n is len(L)
§ 	why	bother	sorAng	ﬁrst?	
§ 	in	some	cases,	may	sort	a	list	once	 then	do	many	
searches	
§ 	AMORTIZE	cost	of	the	sort	over	many	searches	
§ 	SORT	+	K*O(log n)	<	K*O(n)	 		
		à	for	large	K,	 SORT	Eme	becomes	irrelevant,	if	
cost	of	sorAng	is	small	enough	
6.0001	LECTURE	12	 10	SORT ALGORITHMS
§	Want	to	eﬃciently	sort	a	list	of	entries	(typically	
number s)	
§	Will	see	a	ran"
"ge	of	methods,	including	one	that	is	
quite	eﬃcient	
6.0001	LECTURE	12	 11	MONKEY SORT
§	aka	bogosort,	stupid	
sort,	slowsort ,	
permutaAon	sort,	
shotgun	sort	
§	to	sort	a	deck	of	cards	
•	throw	them	in	the	air	
•	pick	them	up	
•	are	they	sorted?		
•	repeat	if	not	sorted	
6.0001	LECTURE	12	 12	COMPLEXITY OF BOGO SORT
def bogo_sort(L):
    while not is_sorted(L):
        random.shuffle(L)
§ 	best	case:	O(n)	where	n	is	len(L)	to	check	if	sorted	
§ 	worst	case:	O(?)	it	is	unbounded	if	really	unlucky	
6.0001"
"	LECTURE	12	 13	BUBBLE SORT
§compare	consecuEve	pairs
of	elements	
§swap	elements	 in	pair	such
that	smaller	is	ﬁrst	
§when	reach	end	of	list,
start	over	 again	
§stop	when	no	more	swaps
have	been	made	
§largest	unsorted	element
always	at	end	a_er	pass,	so	
6.0001	LECTURE	12	 14	at	most	n	passes	
CC-BY	Hydrargyrum		
https://commons.wikimedia.org/wi ki/File:Bubble_sort_anima tion.gif COMPLEXITY OF BUBBLE SORT
def bubble_sort(L):
    swap = False
    while not swap:
swap = Truefor j in range(1, len(L)):
if "
"L[j-1] > L[j]:
swap = False
temp = L[j]
L[j] = L[j-1]
L[j-1] = temp
§	inner	for	loop	is	for	doing	the	comparisons
§	outer	while	loop	is	for	doing	mulEple	passes	 unAl	no	m ore	
swaps	
§	O(n2)	where	n	is	len(L) 	
	to	do	len(L)-1	comparisons	and	len(L)-1	passes	
6.0001	LECTURE	12	 15	SELECTION SORT
§ 	ﬁrst	step	
• 	extract	minimum	element		
• 	swap	it	with	element	at	index	0	
§ 	subsequent	step	
• 	in	remaining	sublist ,	extract	minimum	element	
• 	swap	it	with	the	element	at	index	1		
§ 	keep	the	le_	porAon"
"	of	the	list	sorted		
• 	at	i’th	step,	ﬁrst	i	elements	in	list	are	sorted	
• 	all	other	elements	are	bigger	than	ﬁrst	i	elements	
6.0001	LECTURE	12	 16	ANALYZING SELECTION SORT
§	loop	invariant	
◦given	preﬁx	of	list	L[0:i]	and	suﬃx	L[i+1:len(L)],	then	
preﬁx	is	sorted	and	no	element	in	preﬁx	is	larger	than	
smallest	element	in	suﬃx	
1.base	case:	preﬁx	empty,	suﬃx	whole	list	–	invariant	
true	
2.inducAon	step:	move	minimum	element	from	suﬃx	
to	end	of	preﬁx.		Since	invariant	true	before	move,	
preﬁx	sorted	"
"a_er	append	
3.when	exit,	preﬁx	is	enAre	list,	suﬃx	empty,	so	sorted	
6.0001	LECTURE	12	 17	COMPLEXITY OF SELECTION 
SORT
def selection_sort(L):
    suffixSt = 0    while suffixSt != len(L):
for i in range(suffixSt, len(L)):
if L[i] < L[suffixSt]:
L[suffixSt], L[i] = L[i], L[suffixSt]
suffixSt += 1	
§	outer	loop	executes	len(L)	Ames	
§	inner	loop	executes	len(L)	–	i	Ames	§	complexity	of	selecAon	sort	is	O(n
2)	where	n	is	len(L)	
6.0001	LECTURE	12	 18	MERGE SORT
§	use	a	divide-and-conquer	approach:	
1.if	l"
"ist	is	of	length	0	or	1,	already	sorted	
2.if	list	has	more	than	one	element,	split	into	two	lists,	
and	sort	each	
3.merge	sorted	sublists	
1. look	at	ﬁrst	element	of	each,	move	smaller	to	end	of	the	
result	
2. when	one	list	empty,	just	copy	rest	of	other	list	
6.0001	LECTURE	12	 19MERGE SORT§ 	divide	and	conquer	
§ 	split	list	in	half	unAl	have	sublists	of	only	1	element	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted"
"	merge	merge	merge	merge	merge	merge	merge	merge	
6.0001	LECTURE	12	22	MERGE SORT§ 	divide	and	conquer			§ 	merge	such	that	sublists	will	be	sorted	aQer	merge	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	unsorted	sort	sort	sort	sort	sort	sort	sort	sort	merge	merge	merge	merge	
6.0001	LECTURE	12	23	MERGE SORT
§	divide	and	conquer	
§	merge	sorted	sublists	
§	sublists	will	be	sorted	a_er	merge	unsorted	
unsorted	 unsorted	
sorted	 sorted	 sorted	 sorted	
merge	 merge	
6.0001	LECTURE	12	 22	MERGE SOR"
"T
§divide	and	conquer
§merge	sorted	sublists
§	sublists	will	be	sorted	a_er	merge	unsorted	
sorted	 sorted	
merge	
6.0001	LECTURE	12	 23	MERGE SORT
§	divide	and	conquer	–	done!	
sorted	
6.0001	LECTURE	12	 24	EXAMPLE OF MERGING
Le_	in	list	1															Le_	in	list	2						Compare									Result	
[1,5,12,18,19,20]					[2,3,4,17]									1,	2																			[]	
[5,12,18,19,20]									[2,3,4,17]									5,	2																		[1]	[5,12,18,19,20]									[3,4,17]												5,	3																		[1,2]	[5"
",12,18,19,20]									[4,17]															5,	4																		[1,2,3]	[5,12,18,19,20]									[17]																		5,	17																[1,2,3,4]	
[12,18,19,20]												[17]																		12,	17														[1,2,3,4,5]	
[18,19,20]																		[17]																		18,	17													[1,2,3,4,5,12]	[18,19,20]																		[]																						18,	 --															[1,2,3,4,5,12,17]	
[]																																		[]																																														[1,2,3,4,5,12,17,18,"
"19,20]	
6.0001	LECTURE	12	 25	
MERGING SUBLISTS STEP
def merge(left, right):
    result = []    i,j = 0,0
    while i < len(left) and j < len(right):
if left[i] < right[j]:
result.append(left[i])
i += 1
else:
result.append(right[j])j += 1
    while (i < len(left)):
result.append(left[i])i += 1
    while (j < len(right)):
result.append(right[j])j += 1
    return result
6.0001	LECTURE	12	 26	COMPLEXITY OF  
MERGING SUBLISTS STEP
§	go	through	two	lists,	only	one	pass	
§	compare	only	 smallest	elements	in	eac"
"h	 sublist 	
§	O(len(le_)	+	len (right))	copied	elements	
§	O(len (longer	list))	comparisons	
§	linear	in	length	of	the	lists	
6.0001	LECTURE	12	 27	MERGE SORT ALGORITHM 
-- RECURSIVE
def merge_sort(L):
    if len(L) < 2:
return L[:]
    else:
middle = len(L)//2left = merge_sort(L[:middle])
right = merge_sort(L[middle:])
return merge(left, right)
§	divide	list	successively	into	halves	
§	depth-ﬁrst	such	that	conquer	smallest	pieces	down	
one	branch 	ﬁrst	before	moving	to	larger	pieces	
6.0001	LECTURE	12	 2"
"8	8	4	1	6	5	9	2	0	
	
	
	
8	4	1	6	
	
	
	
8	4		
	
	
	
8		
	
base	
case	4	
	
base	
case	1	6	
	
	
	
1		
	
base	
case	6	
	
base	
case	Merge	
4	8	Merge	
4	8		&	1	6	
1	4	6	8	
Merge	
1	6	5	9	2	0	
	
	
	
5	9	
	
	
	
5		
	
base	
case	9	
	
base	
case	2	0	
	
	
	
2		
	
base	
case	0	
	
base	
case	Merge	
5	9	Merge	
5	9		&	0	2	
0	2	5	9	
Merge	
0	2	Merge	
	1	4	6	8		&	0	2	5	9	
0	1	2	4	5	6	8	9	
6.0001	LECTURE	12	 29	COMPLEXITY OF MERGE SORT
§	at	ﬁrst	recursion	level	
•	n/2	elements	in	each	list	
•	O(n)	+	O(n)	=	O(n)	where	n	is"
"	len(L)	
§	at	second	recursion	level	
•	n/4	elements	in	each	list	
•	two	merges	à	O(n)	whe re	n	is	len(L)	
§	each	recursion	level	is	O(n)	where	n	is	len(L)		
§	dividing	list	in	half	 with	each	recursive	call	
•O(log(n))	whe re	n	is	len(L)	
§	overall	complexity	is	O(n	log(n))	where	n	is	 len(L)	
6.0001	LECTURE	12	 30	SORTING SUMMARY 
-- n is len(L)
§	bogo	sort	
•	randomness,	unbounded	O()	
§	bubble	sort	
•	O(n2)	
§	selecAon	sort	
•	O(n2)	
•	guaranteed	the	ﬁrst	i	elements	were	sorted	
§	merge	sort	
•	O(n	log"
"(n))	
§	O(n	log(n))	is	the	fastest	a	sort	can	be	
6.0001	LECTURE	12	 31	WHAT HAVE WE SEEN 
IN 6.0001?
6.0001	LECTURE	12	 32	KEY TOPICS
§	represent	knowledge	with	data	structures	
§	iteraEon	and	recursion 	as	computaAonal	metaphors	
§	abstracEon 	of	procedures	and	data	types	
§	organize	and	modularize 	systems	using	object	classes	
and	methods	
§	diﬀerent	classes	of	algorithms, 	searching	and	sorAng	
§	complexity 	of	algorithms	
6.0001	LECTURE	12	 33	OVERVIEW OF COURSE
§	learn	computaAonal	modes	of	
think"
"ing	
§	begin	to	master	the	art	of	
computaAonal	problem	solving	
§	make	computers	do	what	you	want	
them	to	do	
6.0001	LECTURE	12	 34	Hope	we	have	started	you	down	the	
path	to	being	able	to	think	and	act	like	a	computer	scienAst	WHAT DO COMPUTER 
SCIENTISTS DO?
§	they	think	computaAonally	
◦	abstracAons,	algorithms,	
automated	execuAon	
§	just	like	the	three	r’s:		reading,	
‘riting, 	and	‘rithmeAc	–	
computaAonal	thinking	is	
becoming	a	fundamental	skill	that  
every	well -educated	person	will	
need	
35 
"
"I											6.0001	
Ada	Lovelace	
 Alan	Turing	
6.0001	LECTURE	12	Image in the Public
Domain, courtesy ofWikipedia Commons.Image in the PublicDomain, courtesy ofWikipedia Commons.THE THREE A’ S OF 
COMPUTATIONAL THINKING
§	abstracAon	
◦choosing	the	right	abstracAons	
◦operaAng	in	mulAple	layers	of	abstracAon	
simultaneously	
◦deﬁning	the	relaAonships	between	the	abstracAon	
layers	
§	automaAon	
◦think	in	terms	of	mechanizing	our	abstracAons	
◦mechanizaAon	is	possible	–	because	we	have	precise	
and	exacAng	"
"notaAons	and	models;	and	because	there	is	
some 	“machine”	that	can	interpret	our	notaAons	
§	algorithms	
◦language	for	describing	automated	processes	
◦also	allows	abstracAon	of	details	
◦language	for	communicaAng	ideas	&	processes	
36 6.0001	LECTURE	12	
Person 	
MITPerson	
Student	
UG	
 Grad	
ASPECTS OF COMPUTATIONAL 
THINKING
§	how	diﬃcult	is	this	problem	
and	how	best	can	I	solve	it?	
◦theoreAcal	computer	science	
gives	precise	meaning	to	these	
and	related	quesAons	and	their	answers	
§	thinking	recurs"
"ively	
◦reformulaAng	a	seemingly	
diﬃcult	problem	into	one	which	we	know	how	to	solve	
◦
reduc tion,	embedding,	
transformation,  	simulaAon 	
37 
O(log	n)	;	O(n)	;		
O(n	log	n) 	;		
O(n2);	O(cn)		
6.0001	LECTURE	12	Image Licensed CC-BY, Courtesy of Robson# on Flickr.	MIT OpenCourseWare  
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python 
Fall 2016
For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms ."
"13A. Lists of Numbers  
Topics:  
 Lists of numbers  
         List Methods:  
 Void vs Fruitful Methods  
         Setting up Lists  
         A Function that returns a list  
  
 
 We Have Seen Lists Before  
MyColor = [.3,.4,.5]  
 
DrawDisk (0,0,1,FillColor = MyColor) Recall that the rgb encoding of a color  
involves a triplet of numbers:  
MyColor   is a list.  
 
A list of numbers is a way of assembling a  
sequence of numbers.  Terminology  
x = [3.0, 5.0, -1.0, 0.0, 3.14]  
How we talk about what i"
"s in a list:  
 
 5.0 is an item in the list x. 
 
 5.0 is an entry  in the list x. 
 
 5.0 is an element  in the list x.  
 
 5.0 is a value  in the list x.  
Get used to the synonyms.  A List Has a Length  
The following would assign the value of 5  
to the variable n:  
x = [3.0, 5.0, -1.0, 0.0, 3.14]  
n = len(x) The Entries in a List are  
 Accessed Using Subscripts  
The following would assign the value of -1.0 
to the variable a: 
x = [3.0, 5.0, -1.0, 0.0, 3.14]  
a = x[2]  A List Can Be Sliced  
Thi"
"s:  x = [10,40,50,30,20]  
y = x[1:3]  
z = x[:3]  
w = x[3:]  
Is same as:  x = [10,40,50,30,20]  
y = [40,50]  
z = [10,40,50]  
w = [30,20]  Lists are Similar to Strings  
‘x’ ‘1’ ‘?’ ‘L’ ‘C’ ‘a’ s: 
 3   2   7   5   4   0  x: 
A string is a sequence of characters.  
  
A list of numbers is a sequence of numbers.  Lists in Python  
Animals = [‘ cat’,’dog’,’mouse ’] Now we consider lists of numbers:  
 
 
 
 
Soon we will consider lists of strings:  
 
 
 
Later  we will consider lists of objects.  
 
The"
" operations on lists that we are about to describe will be illustrated using lists 
of numbers. But they can be applied to any kind of list.  A = [10,20,30]  
B = [10.0,20.0,30.0]  
C = [10,20.0,30]  The items  
in a list  
usually have  
the same type,  
but that is not  
required.  Visualizing Lists  
 0 --->  3 
 1 --->  5 
 2 --->  1 
 3 --->  7 x ----> 
  3   1   7   5  x:      0              1              2             3        
Informal:  
Formal:  
A state diagram that shows  
the “map” from indice"
"s to  
elements.  Lists vs. Strings  
There are some similarities, e.g., subscripts  
 
But there is a huge difference:  
 
   1. Strings are immutable . They cannot be changed.  
 
   2. Lists are mutable . They can be change.  
 
 
Exactly what does this mean?  Strings are Immutable  
Before:  
s[2]= ‘x’  
After:  ‘a’ ‘c’ ‘d’ ‘b’ s:      0              1              2             3      
You cannot change the value of a string  TypeError : 'str' object does  
not support item assignment  Lists ARE Mutabl"
"e  
Before:  
x[2] = 100  
After:  
You can change the values in a list   3   1   7   5  x:      0              1              2             3      
 3  100  7   5  x:      0              1              2             3      Lists ARE Mutable  
Before  
x[1:3] = [100,200]  
After  
You can change the values in a list   3   1   7   5  x:      0              1              2             3      
 3  200  7  100 x:      0              1              2             3      List Methods  
When these methods are appl"
"ied to a list,  
they affect the list.  
 
    append 
    extend 
    insert 
    sort 
 
Let’s see what they do through examples…  
 
 
 List Methods: append 
Before:  
x.append (100) 
After:   3   1   7   5  x:      0              1              2             3              4       
100 
Use append when you want to “glue” an item on the end of a given list .  3   1   7   5  x:      0              1              2             3      List Methods: extend 
Before:  
t = [100,200]  
x.extend (t) 
After:   3 "
"  1   7   5  x:      0              1              2             3              4              5       
100  3   1   7   5  x:      0              1              2             3      
200 
Use extend when you want to “glue”  one list onto the end of another list.  List Methods: insert 
Before:  
i = 2 
a = 100 
x.insert (i,a) 
After:   3  100  1   5  x:      0              1              2             3              4                  
 7   3   1   7   5  x:      0              1              2             "
"3      
Use insert when you want to insert an item into the list. Items get “bumped” to  the 
right if they are at or to the right of the specified insertion point.   List Methods: sort 
Before:  
x.sort() 
After:   1   5   3  x:      0              1              2             3                      
 7   3   1   7   5  x:      0              1              2             3      
Use sort when you want to order the elements in a list from little to big.   List Methods: sort 
Before:  
x.sort(reverse=True)  "
"
After:   7   3   5  x:      0              1              2             3                      
 1   3   1   7   5  x:      0              1              2             3      
Use sort when you want to order the elements in a list from big to little.   An optional  
argument is  
being used to  
take care of  
this situation.  Void Methods  
When the methods  
 
 append    extend   insert    sort  
 
 
are applied to a list, they affect the list b ut 
they do not return anything like a number or  
string. "
"They are called “void” methods.  
 
Void methods return the value of None . This is  
Python’s way of saying they do not return  
anything.  
 
 Void Methods  
 
A clarifying example : 
 
 
 
 
 
 >>> x = [10,20,30]  
>>> y = x.append (40) 
>>> print x 
[10, 20, 30, 40]  
>>> print y 
None x.append (40) does 
something to x.  
 
In particular, it appends  
an element to x  
 
It returns None and that is  
assigned to y.  Void Methods/Functions  
The graphics procedures DrawDisk , DrawRect ,  
etc., are exam"
"ples of void functions.  
 
They also return the value None. But we were  
never tempted to do something like this:  
 
  C = DrawDisk (0,0,1) 
 
With lists, however, it is tempting to do  
something like this:  
 
  newValue  = 10 
  y = x.append (newValue ) 
 
So we have to be careful!  
 (Fruitful) List Methods  
When these methods are applied to a list,  
they actually return something:  
 
    pop 
    count 
 
Let’s see what they do through examples…  
 
 
 The List Method  pop 
Before:  
i = 2 
m = x"
".pop( i) 
After:   3   5  x:      0              1              2                               
 7   3   1   7   5  x:      0              1              2             3      
Use pop when you want to remove an element and assign it to a variable.    1  m: The List Method  count 
Before:  
m = x.count(7) 
After:   3   1   7  x:      0              1              2             3                      
 7   3   1   7   7  x:      0              1              2             3      
Use count when  you want to "
"compute the number of items in a list  
that have a value.  m:  2  Two Built -In Functions that  
Can be Applied to Lists  
len  returns the length of a list  
 
sum returns the sum of the elements in  
 a list provided all the elements are  
 numerical.  len and sum 
Before  
m = len(x) 
s = sum(x)  
After   3   1   7  x:      0              1              2             3                      
 5   3   1   5   7  x:      0              1              2             3      
m:  4  
s:  16  len and sum: Commo"
"n errors  
>>> x = [10,20,30]  
 
>>> s = x.sum()  
AttributeError : 'list' object  
   has no attribute 'sum‘  
 
>>> n = x.len()  
AttributeError : 'list' object  
   has no attribute ' len' Legal But Not What You 
Probably Expect  
>>> x = [10,20,30]  
>>> y = [11,21,31]  
>>> z = x+y 
>>> print z  
[10,20,30,11,21,31]  Legal But Not What You  
Probably Expect  
>>> x = [10,20,30]  
>>> y = 3*x  
>>>print y 
[10,20,30,10,20,30,10,20,30]  Setting Up “Little” Lists  
The examples so far have all been small"
".  
 
When that is the case, the “square bracket”  
notation is just fine for setting up a list:  
x = [10,40,50,30,20]  
Don’t forget the commas!   Working with Big Lists  
Setting up a big list requires a loop.  
 
Looking for things in a big list requires  
a loop.  
 
Let’s consider some examples.  A Big List of Random Numbers  
Roll a dice one million times. Record the outcomes in a list.  from random import randint as randi 
x = [] 
N = 1000000  
for k in range(N):  
    r = randi(1,6) 
    x.append ("
"r) 
 
x starts out as an empty list and is built 
up through repeated appending.  This Does Not Work  
from random import randint as randi 
x = [] 
N = 1000000  
for k in range(N):  
    r = randi(1,6) 
    x[k] = r  
 
x[k] = r  
IndexError : list assignment index out of range  
x[0] = r   does not work because x is the empty list —it has no components  A List of Square Roots  
from math import sqrt 
x = [] 
N = 1000000  
for k in range(N):  
    s = sqrt(k) 
    x.append (s) 
 
Same idea. Create a list th"
"rough repeated appending.  A Random Walk Example  
from random import randint as randi 
x = [0] 
k = 0 
# x[k] is robot’s location after k hops  
while abs(x[k])<=10:  
    # Flip a coin and hop right or left  
    r = randi(1,2) 
    if r==1:  
        new_x = x[k]+1  
    else: 
        new_x = x[k]-1 
    k = k+1 
    x.append (new_x) A Random Walk Example  
from random import randint as randi 
x = [0] 
k = 0 
# x[k] is robot’s location after k hops  
while abs(x[k])<=10:  
    # Flip a coin and hop righ"
"t or left  
    r = randi(1,2) 
    if r==1:  
        new_x = x[k]+1  
    else: 
        new_x = x[k]-1 
    k = k+1 
    x.append (new_x) Notice  
that x is  
initialized  
as a  
length -1 
list. The  
robot  
starts  
at the  
origin .  
 Be Careful About Types  
This is OK and synonymous with x = [0,10]:  
 
         x = [0] 
 x.append (10) 
 
This is not OK : 
 
         x = 0 
 x.append (10) 
 
AttributeError : 'int' object has  
     no attribute 'append'  You need the square  
brackets. It is your"
" way  
of telling Python that  
X   is a list, not an int.  Be Careful About Types  
>>> x = 0  
>>> type(x)  
<type 'int'>  
>>> x = [0]  
>>> type(x)  
<type 'list'>  Functions and Lists  
Let’s start with a function that returns a list.  
 
In particular, a function that returns a  
list of random integers from a given  
interval.  
 
Then we will use that function to estimate  
various probabilities when a pair of dice are  
rolled.  A List of Random Integers  
from random import randint as randi 
 
def"
" randiList (L,R,n): 
    “““ Returns a length -n list of  
    random integers from interval [L,R]  
    PreC: L,R,n ints with L<=R and n>=1  
    ””” 
    x = [] 
    for k in range(n):  
        r = randi(L,R) 
        x.append (r)  
    return x  
 Outcomes from Two Dice Rolls  
Roll a pair of dice N times  
 
Store the outcomes of each dice roll  
in a pair of length -N lists.  
 
Then using those two lists, create a third  
list that is the sum of the outcomes  
in another list.  
  Outcomes from Two D"
"ice Rolls  
Example:   
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
 5   9   6   4   D:      0              1              2             3      How to Do It  
N = 1000000  
D1 = randiList (1,6,N) 
D2 = randiList (1,6,N) 
 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) 
 
  How It Works  
 2   5   4   1  D1:      0              1              2             3   "
"   
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  0  
 4  
At the start of the loop   D: []       How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  "
"0  
 4  
TwoThrows  = D1[0]+D2[0]    D: []       TwoThrows  -->  5  How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  0  
 4  
D.append (5)  TwoThrows  -->  5  
 5   D:            How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3"
"  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  1  
 4  
TwoThrows = D1[1]+D2[1]   TwoThrows  -->  4  
 5   D:            How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> "
"
N -->  1  
 4  
D.append (4)  TwoThrows  -->  4  
 5   D:            
 4  How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  2  
 4  
TwoThrows = D1[2]+D2[2]   TwoThrows  -->  9  
 5   D:            
 4  How It Works  
 2   5   4   1  D1:      0              1              2           "
"  3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  2  
 4  
D.append (9)  TwoThrows  -->  9  
 5   D:            
 4   9  How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.appen"
"d (TwoThrows ) k --> 
N -->  3  
 4  
TwoThrows  = D1[3]+D2[3]   TwoThrows  -->  9  
 5   D:            
 4   9  How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  3  
 4  
TwoThrows  = D1[3]+D2[3]   TwoThrows  -->  6  
 5   D:            
 4   9  How It Works  
 2   5   4   1  D1:     "
" 0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) k --> 
N -->  3  
 4  
D.append (6)  TwoThrows  -->  6  
 5   D:            
 4   9   6  How It Works  
 2   5   4   1  D1:      0              1              2             3      
 3   4   2   3  D2:      0              1              2             3      
N = 4 
D = [] 
for k in range(N"
"):  
   TwoThrows  = D1[k] + D2[k]  
   D.append (TwoThrows ) N --> k -->  4  
 4  
All Done!   TwoThrows  -->  6  
 5   D:            
 4   9   6  Tabulating Outcomes  
We have simulated the rolling of a pair of  
dice N times.  
 
The outcomes are recorded in the list D.  
 
New problem:  
 How many 2’s were there?  
 How many 3’s were there?  
                 : 
 How many 12’s were there?  Tabulating Outcomes  
count = [0,0,0,0,0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]"
"+1 
 
 0   0   0   0   0   0   0   0   0   0   0   0   0  0        1        2       3        4        5         6       7         8       9       10     11      12  
count:  
count[2]    keeps track of the number of 2’s thrown  
count[10]   keeps track of the numberof  10’s thrown  Tabulating Outcomes  
count = [0,0,0,0,0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]+1 
 
The variable  i  is assigned the outcome  
of the k -th 2-die roll.  Tabulating Outcomes  
count = [0,0,0,0,"
"0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]+1 
 
Suppose:  
  i -->  7  
 0   0   3   1   5   8   7   2   1   6   9   2   1  0        1        2       3        4        5         6       7         8       9       10     11      12  
count:  Tabulating Outcomes  
count = [0,0,0,0,0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]+1 
 
Suppose  i -->  7  
then the assignment     count[i] = count[ i]+1 
 
effectively says       count[7] = count[7]+1   "
"Tabulating Outcomes  
count = [0,0,0,0,0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]+1 
 
Before:  
  i -->  7  
 0   0   3   1   5   8   7   2   1   6   9   2   1  0        1        2       3        4        5         6       7         8       9       10     11      12  
count:  
 0   0   3   1   5   8   7   3   1   6   9   2   1  0        1        2       3        4        5         6       7         8       9       10     11      12  
count:  After:  
  Overall...  
count ="
" [0,0,0,0,0,0,0,0,0,0,0,0,0]  
for k in range(N):  
  i = D[k] 
  count[i] = count[ i]+1 
 
 
A list of counters.  Sample Results, N = 10000  
 k   count[k]  
---------------  
  2    293  
  3    629  
  4    820  
  5   1100  
  6   1399  
  7   1650  
  8   1321  
  9   1149  
 10    820  
 11    527  
 12    292  
 for k in range(2,13):  
  print k,count[k] 
 "
"13B. Loops and Lists  
Topics:  
 Functions that return more than 1 thing  
 Nested Loops  
 Map 
 
 
 Computing the Diameter of a 
Cloud of Points  
500 Points. Which two are furthest apart  
and what is their separation?  Same Problem:  
What’s the Biggest Number in 
This Table?  
Which two cities are furthest apart  
and what is their separation?  It Will Have Three Functions  
MakeCloud (n,sigma) 
 This generates two lists x and y that define 
the coordinates of the points in the cloud.  
 
Diameter( x,"
"y) 
 This will compute the diameter of the cloud 
using the ( x,y) coordinates of its points.  
 
ShowCloud (x,y) 
 This will use SimpleGraphics  to display the  
 cloud and highlight the “diameter points”.  
 
 The Function MakeCloud  
from random import normalvariate  as randn 
 
def MakeCloud (n,sigma): 
  x=[] 
     y=[] 
     for k in range(n):  
        r = randn(0,sigma)  
        x.append (r) 
        r = randn(0,sigma)  
        y.append (r) 
     return ( x,y) The normal  
distribution  MakeCloud "
" Returns Two Lists  
from random import normalvariate  as randn 
 
def MakeCloud (n,sigma): 
  x=[] 
     y=[] 
     for k in range(n):  
        r = randn(0,sigma)  
        x.append (r) 
        r = randn(0,sigma)  
        y.append (r) 
     return ( x,y) New Feature  
 
A function  
that returns  
more than  
one thing.  
 
Note the  
parentheses  MakeCloud  Returns Two Lists  
>>> (x,y) = MakeCloud (3,1) 
>>> print x  
>>> print y  
 
 
 [-2.328, -0.044, -0.241]  
 
 [ 2.737,  2.078, -1.272] 
 
       "
"                                           Note the parentheses                                              MakeCloud  
from random import normalvariate  as randn 
 
def MakeCloud (n,sigma): 
  x=[] 
     y=[] 
     for k in range(n):  
        r = randn(0,sigma)  
        x.append (r) 
        r = randn(0,sigma)  
        y.append (r) 
     return x,y Old Stuff  
 
x and y start 
out as empty 
lists. 
 
Repeatedly  
generate a  
random number  
and append to x  
 
Ditto for y   
 
 
 
 
 
 
 
 
          "
"                                                                              
  The Diameter Function: What 
It Computes  
The “diameter  
points” and the  
distance  
between them  
Input: lists x and y that define the yellow dots  Diameter: Formal Specs  
def Diameter( x,y): 
  """""" Returns ( d,imax,jmax ) where d is a 
float that is the diameter of a cloud of 
points defined by lists x and y. imax and 
 jmax are ints that are the indices of the 
diameter points.  
     
 The diameter of a cloud of points"
" is the 
maximum distance between any   two points in 
the cloud. The two points for which this 
occurs are called diameter points.  
     
  PreC: x and y are lists of floats with the 
same length.  Diameter: The Implementation  
def Diameter( x,y): 
   d = 0 
   n = len(x) 
   for i in range(n):  
    for j in range(n):  
          dx = x[i]-x[j] 
          dy = y[i]-y[j] 
          dij = sqrt(dx**2+dy**2)  
          if dij>d: 
             d = dij 
             imax = i 
             jmax = j 
   return"
" ( d,imax,jmax ) New Feature  
 
Nested Loops  Nested Loops  
In this situation we have a loop whose  
body contains a loop  
 
for blahblahblah  
and                 contains a loop.  
 Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inner’  
print ‘Outer’  
 Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inner’  
 
print ‘Outer’  
  
 
 
 
                                                 "
"                                                             
Execute the loop body with i=0 Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inner’  
 
print ‘Outer’  
  
 
 
 
                                                                                                              
Execute the loop body with i=0  0  0  
 0  1 
 0  2 
 Inner Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print"
" ‘Inner’  
 
print ‘Outer’  
  
 
 
 
                                                                                                              
Execute the loop body with i=1  0  0  
 0  1 
 0  2 
 Inner Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inner’  
 
print ‘Outer’  
  
 
 
 
                                                                                                              
Execute the loop body with i=1  0  0  
 0  1 
 0 "
" 2 
 Inner 
 1  0 
 1  1 
 1  2 
 Inner Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inner’  
 
print ‘Outer’  
  
 
 
 
                                                                                                              
Go to the next statement after  
the loop body.   0  0  
 0  1 
 0  2 
 Inner 
 1  0 
 1  1 
 1  2 
 Inner Nested Loops: A Simple Example  
for i in range(2):  
 for j in range(3):  
        print i,j 
     print ‘Inne"
"r’  
 
print ‘Outer’  
  
 
 
 
                                                                                                              
Go to the next statement after  
the loop body.   0  0  
 0  1 
 0  2 
 Inner 
 1  0 
 1  1 
 1  2 
 Inner 
 Outer Back to Diameter  
Aspects of our problem  
 
 - Must check all possible pairs of points.  
 - Look at their separation distance  
 - What’s the largest among these distances?  When developing nested -loop solutions,  
it is essentia l to apply the metho"
"dology of  
step-wise refinement, perhaps preceded  
by a small example  Suppose There Are 3 points  
    From           To        Dist  
----------------------------------    
(x[0],[y[0])   (x[0],y[0])     0  
(x[0],[y[0])   (x[1],y[1])     7  
(x[0],[y[0])   (x[2],y[2])     9  
(x[1],[y[1])   (x[0],y[0])     7  
(x[1],[y[1])   (x[1],y[1])     0  
(x[1],[y[1])   (x[2],y[2])     10  
(x[2],[y[2])   (x[0],y[0])     9  
(x[2],[y[2])   (x[1],y[1])     10  
(x[2],[y[2])   (x[2],y[2])     0  
Number of possibil"
"ities.: 9 = 3x3  Suppose There Are 3 points  
    From           To        Dist  
----------------------------------    
(x[0],[y[0])   (x[0],y[0])     0  
(x[0],[y[0])   (x[1],y[1])     7  
(x[0],[y[0])   (x[2],y[2])     9  
(x[1],[y[1])   (x[0],y[0])     7  
(x[1],[y[1])   (x[1],y[1])     0  
(x[1],[y[1])   (x[2],y[2])     10  
(x[2],[y[2])   (x[0],y[0])     9  
(x[2],[y[2])   (x[1],y[1])     10  
(x[2],[y[2])   (x[2],y[2])     0  
Number of possibilities.: 9 = 3x3  And now, stepwise refinement  
in actio"
"n….  First Solution  
d = 0 
n = len(x) 
for i in range(n):  
 # Examine the distance from  
     # (x[i],y[i]) to every other point  
 Second Solution  
d = 0 
n = len(x) 
for i in range(n):  
 for j in range(n):  
          # Examine the distance from  
         # (x[i],y[i]) to (x[j],y[j])  
 Third Solution  
d = 0 
n = len(x) 
for i in range(n):  
 for j in range(n):  
          dx = x[i]-x[j] 
         dy = y[i]-y[j] 
         dij = sqrt(dx**2+dy**2)  
         # Compare dij to d revising  
         # "
"the latter if necessary  
 Fourth Solution  
d = 0 
n = len(x) 
for i in range(n):  
 for j in range(n):  
          dx = x[i]-x[j] 
         dy = y[i]-y[j] 
         dij = sqrt(dx**2+dy**2)  
         if dij>d: 
   d = dij 
             imax = i 
             jmax = j 
return ( d,imax,jmax ) 
 Fourth Solution  
d = 0 
n = len(x) 
for i in range(n):  
 for j in range(n):  
          dx = x[i]-x[j] 
         dy = y[i]-y[j] 
         dij = sqrt(dx**2+dy**2)  
         if dij>d: 
   d = dij 
             imax "
"= i 
             jmax = j 
return ( d,imax,jmax ) 
 We have to  
“remember”  
where the max  
separation  
occurs.  Next Up: ShowCloud  
ShowCloud : Specs  
def ShowCloud (x,y): 
    """""" Displays a point cloud  
    defined by x and y and highlights  
    the two points  that define  
    its diameter.  
     
    PreC: x and y are lists of  
    floats with the same length.  
    """""" First: How Big a Window?  
xMax = max(map( abs,x)) 
yMax = max(map( abs,y)) 
M = max( xMax,yMax ) 
MakeWindow (1.1*M,bgcolo"
"r =BLACK) New Feature:  
         map 
Idea:  look at the x and y coordinates of  
the points  and see how big they can be.  Map: Apply a Function to Each  
Element in a List  
>>> x = [10, -20,-40] 
>>> x = map( abs,x) 
>>> print x  
[10,20,40]  Example. Apply the absolute value function  
to every list element  Map: Apply a Function to Each  
Element in a List  
>>> x = [11.3, 12.4, 15.0]  
>>> x = map( math.floor,x ) 
>>> print x  
[11.0,12.0,15.0]  Example. Apply the floor function  
to every list eleme"
"nt:  Map: Apply a Function to Each  
Element in a List  
y = [] 
for k in range( len(x)): 
   y.append (math.sqrt (x([k]))  This:  
y = map( math.sqrt,x ) Is equivalent to this:  
               Assuming that x is an initialized list of nonnegative numbers                      Map: Formal Syntax  
 
map(          ,             )  
The name of a function that  
returns a value. Every element in  
the list must satisfy its precondition.  
The name of a list.  Now, Back to ShowCloud  First: How Big a Window?  "
"
xMax = max(map( abs,x)) 
yMax = max(map( abs,y)) 
M = max( xMax,yMax ) 
MakeWindow (1.1*M,bgcolor =BLACK) 
x = [-19,12,-4] 
max(map( abs,x)) 
>>> 19 Next, Use DrawDisk  For 
Each Point  
r = M/50;  
(d,i,j) = Diameter( x,y) 
for k in range( len(x)): 
   if k==i or k==j:  
       DrawDisk (x[k],y[k],2* r,FillColor =CYAN) 
      DrawDisk (x[k],y[k], r,FillColor =YELLOW)  
i and j are the indices of the diameter points.  
 
Before they are displayed, we paint a larger  
cyan dot.  "
"14. Lists of Strings  
Topics:  
 List methods -again  
 Setting up a list of strings  
 Reading from a textfile  
 .csv files 
 delimiters and the method split  
 What You Know About Lists of 
Numbers Carries Over  
Set-Up: 
    s = [‘cat’,’dog’,’mice ’] 
 
Length:  
 L = len(s) 
 
Slicing:  
    t = s[1:3]  
 
Methods:  
    append, extend, insert, pop, 
 count, sort  A Note About sort 
Before:  
s.sort() 
After:   ‘dog’  s: ‘mouse’  ‘cat’  
 ‘cat’  s:  ‘dog’  ‘mouse’ 
When you sort a list of strings and "
"the strings are  
made up of letters, digits, and blanks, then it alphabetizes  
the items according to the order in this string:  
 
‘ 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ’ 
 
  Strings vs Lists of Characters  
LC = ‘abcdefghijklmnopqrstuvwxyz ’ 
UC = ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’  
Digits = ‘0123456789’  
All = LC + UC + Digits + ’ ‘  
s = [] 
for c in All:  
    s.append (c) 
s.sort() 
lex = '' 
for x in s:  
    lex = lex + x 
print lex empty list  
empty string  repeated appen"
"ding  
repeated concatenation  
‘ 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ’ Note on sum 
If 
    s = [‘cat’,’dog’,’mice ’] 
 
then 
 t = sum(s)  
 
produces an error:  
     
 
 
 
 
not 
    ‘catdogmice ’ TypeError : unsupported operand type(s) for +:  
            'int' and 'str' Visualizing Lists of Strings  
 0 ---> ‘cat’ 
 1 ---> ‘dog’ 
 2 ---> ‘mouse’  s ----> 
 Informal:  
Formal:   ‘cat’  ‘mouse’  ‘dog’  s: 
      0                              1                              2"
"               Subscript “Reasoning”  
 ‘cat’  ‘mouse’  ‘dog’  s: 
      0                              1                              2               
The statement  
 
 c = s[2][1:3]  
 
assigns ‘ou’ to c The statements  
 
 t = s[2]  
 c = t[1:3]  
 
assign ‘ou’ to c Subscript “Reasoning”  
 ‘cat’  ‘mouse’  ‘dog’  s: 
      0                              1                              2               
How to decipher  s[2][1:3]:  
 
 s names a list  
 
 s[2] names item 2 in  s 
 
 s[2][1:3] names slice  "
"1:3 in item 2 in  s Three Examples  
1. A function that returns a list of random  
 3-letter words.  
 
2. A function that reads a text file and returns 
a list where each item in the list is a line in 
the file.  
 
3. A script that uses a US Census dataset to 
examine county population growth rates from 
2010 to 2014.  
 
 1. A Function that Returns  
a List of Strings  
def ListOfRandomStrings (n,m): 
    """""" Returns an alphabetized length -n  
    list of random strings each of which  
    is made up of"
" m lower case letters.  
    The items in the list are distinct.  
     
    PreC: n and m are positive integers  
    and n<=26**m. """"""  Let’s implement this : 
 
There are  26**m  different possible strings . So n cannot be bigger than that.  ListOfRandomStrings (100,4) 
afei atou atzo auvf bdus bmut bnhk btqp bztw cabs 
cdnr chda dayy dhtb dinj drfq ecme eixm ethh evsv 
frar gfam gssn gtnx gvmp hfhb hlwe ilsr inxs iolb 
itzv izwd jfmc jtph jzai kefo keiy keyo kfft kwnu 
kyoi lbgt ldgs ldrc luwn lvtg lynx"
" medj mplc muzs 
mvov nawk ngvb nkhp nogc npgc ntjk nwbt oefw oepg 
pddo pewe phpp qapi qhal qmod qryd qwhj rmhk rorl 
rvhu sauo sebg segl sknu slgk svsf tmry uake vinu 
vlvx vygo wtoi wxmj xpcn xuni ypta yqxc yqzq ysny 
ywsd yyut zayj zhym zqdn zsqf zvce zwgj zxog zyyp Sample outcome:  Helper Function  RandString  
def RandString (m): 
    """""" Returns a random length -m string  
    consisting of lower case letters.  
     
    PreC: m is a positive integer.  
    """"""  Assume the availability of…  If we al"
"lowed Repeats…  
def ListOfRandomStrings (n,m): 
    s = [] 
 for k in range(n):  
  w = RandString (m) 
  s.append (t) 
 s.sort() 
 return s  
  
Repeat n times:  Generate a random string and append  Check Before Appending…  
def ListOfRandomStrings (n,m): 
    s = [] 
 k = 0   # k is the length of s.  
    while k<n:  
  w = RandString (m) 
         if w not in s:  
             s.append (w) 
             k+=1 
     s.sort() 
     return s  
  
Repeat:  Generate a random string and append IF it is not yet"
" in s  Notice how we can  
use “in” to look  
for values in a  
list. And “not in”  
to confirm the  
absence of  
a value in a list  2. Reading a Text File Into  
a List of Strings  
MyFile.txt  
abcd 
123 abc d fdd  
xyz 
3.14159   2.12345  Text files can be visualized like this:  
This text file  
has four lines.  Our Plan  
MyFile.txt  
abcd 
123 abc d fdd  
xyz 
3.14159   2.12345  We will “read”  
the file line -by-line  
and make each  
line an item in a  
list of strings.  
 0 ---> ‘abcd’ 
 1 ---> ‘1"
"23 abc d fdd’ 
 2 ---> ‘xyz’ 
 3 ---> ‘3.14159  2.12345’  L --> 
 Opening a File  
L = [] 
with open(‘ MyFile.txt’,’r ’) as F:  
  for s in F:             
   L.append (s) 
The name of the file is passed as a string.  
 
The file must be in the same working  
directory as the file -reading code.  
 
‘r’ means “read”  The Reading  
L = [] 
with open(‘ MyFile.txt’,’r ’) as F:  
  for s in F:             
   L.append (s) 
F is a “file object”.  
 
It can be read line -by-line with a for -loop. 
 
As the loop e"
"xecutes, s takes on the  
value of each file line in succession.  Problem: Special Characters  
MyFile.txt  
abcd 
123 abc d fdd  
xyz 
3.14159   2.12345  Newline characters and carriage return  
characters mess up this process:  
Typically these  
characters are  
irrelevant once  
the data is  
read into the  
list. So delete  
them…  Removing Newline and Carriage 
Return Characters  
L = [] 
with open(‘ MyText.txt’,’r ’) as F:  
   for s in F:             
   s1 = s.rstrip (‘\n’)    
        s2 = s1.rstr"
"ip(‘ \r’) 
   L.append (s2) 
     
>>> s = ‘ abc   ‘ 
>>> s.rstrip (‘ ‘) 
‘abc’ Putting It All Together  
def fileToStringList (FileName ): 
  L = [] 
     with open( FileName,’r ’) as F:  
       for s in F:             
    s1=s.rstrip (‘\n’)    
             s2 = s1.rstrip(‘ \r’) 
    L.append (s2) 
    return L  Using  fileToStringList  
L=fileToStringvList ('EnglishWords.txt ') 
for s in L:  
    if len(s)>=5 and Palindrome (s): 
        print s 
EnglishWords.txt  is a file with about 100000 lines,  
e"
"ach containing a single English word.  
 
Palindrome  is a boolean  valued function that is  
True if and Only if the input string is a palindrome  Using  fileToStringList  
L=fileToStringList ('EnglishWords.txt ') 
for s in L:  
    if len(s)>=5 and Palindrome (s): 
        print s 
civic      deified   deled   denned   dewed    
hallah     kaiak     kayak   level    madam  
malayalam   minim     radar   redder   refer  
reifier    reviver   rotator rotor    sagas  
seres      sexes     shahs   solos    st"
"ats  
stets      tenet  Output:  3. A More Complicated Example  
EnglishWords.txt  
aarvaark  
baby 
cat 
  : Extracting words from EnglishWords.txt   
was easy because there was one data item of  
interest per line:  Multiple Data Items Per Line  
BigStates.txt  
California  38.8  
Florida  19.9  
NewYork   19.8 
Texas  27.0  In more complicated set -ups, there can be  
multiple data items per row.  
Here, blanks   
are being used  
to separate  
items of interest.  The split  Method is Handy  
for Extract"
"ing Data  
>>> s = 'California  38.8'  
>>> v = s.split() 
>>> v 
['California', '38.8']  
A list is made up of substrings that are  
separated by blanks.  
 
The blank acts as a delimiter . The Comma -Separated Value  
Format  
BigStates.csv  
California,  38.8  
Florida,  19.9  
NewYork,   19.8  
Texas,  27.0  A more common strategy is to use commas  
as delimeters .  
The . csv suffix  
is used to signal  
this format in  
a text file.  Reading a . csv File 
BigStates.csv  
California,  38.8  
Florida,  "
"19.9  
NewYork,   19.8  
Texas,  27.0  
L = FileToList (‘BigState.csv’)  
for c in L:  
   v = c.split(‘,’) 
   print v[1],v[0]  
38.8 California  
19.9 Florida  
19.8 NewYork 
27.0 Texas  File 
 Code 
Output  ReadMe Files  
Whoever puts together a . csv file is obliged to 
tell you how the data is laid out.  
BigStates.csv  
California,  38.8  
Florida,  19.9  
NewYork,   19.8  
Texas,  27.0  
Field 1:  State Name  
Field 2:  Population (millions)  This information  
is typically placed  
in a text file th"
"at  
is  named ReadMe  An Example  
Suppose we have a file  CensusData.csv  
in which each line houses US Census data on  
a county. Assume that…  
      Field 6   State Name  
   Field 7   County Name  
   Field 8   2010 county population  
   Field 11  2011 county population  
   Field 12  2012 county population  
   Field 13  2013 county population  
   Field 14  2014 county population  
Question: Which county that has a 2010 
population greater than 100000 grew the 
most between 2010 and 2014?  An Examp"
"le  
      Field 6   State Name  
   Field 7   County Name  
   Field 8   2010 county population  
   Field 11  2011 county population  
   Field 12  2012 county population  
   Field 13  2013 county population  
   Field 14  2014 county population  
If c is a line in the file then  
 
 v = c.split(‘,’) 
    growth = float(v[13])/float(v[8])  
 
is what we want.  Solution Code  
TheCounties  =     
 fileToStringList ('CensusData.csv')  
gMax = 0 
for c in TheCounties : 
    v = c.split(',') 
    g = float(v"
"[13])/float(v[7])  
    if int(v[7])>=100000 and g> gMax: 
        gMax = g 
        vMax = v 
print vMax[6],vMax[5],int(gMax*100),’percent’  
Hays County Texas 117 percent  "
"15. Lists are Objects  
Topics:  
 References  
         Alias  
         More on Slicing  
          
 
 
 Comparing Lists  
>>> x = [10,20,30,40]  
>>> y = [10,20,30,40]  
>>> x==y  
True  
You can use  ==  to compare two lists  
 Comparing Lists  
 
You can use  ==  to compare two lists  
 
 0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   y --> 
  0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
The Boolean expression   x==y   is True   because x and y  
have the same length and identical"
" values in each element  Comparing Lists  
>>> x = [1,2,3]  
>>> y = [1.0,2.0,3.0]  
>>> x==y  
True  
You can use  ==  to compare two lists  
 
If there are ints and floats, convert everything to float then compare  Comparing Lists  
>>> x = [10,20,30,40]  
>>> y = [11,21,31,41]  
>>> x<y 
True 
>>> y<x 
True  
Do  not use  <, <= , > , >=   to compare two lists  
 
 Unpredictable  Aliasing  
x = [10,20,30,40]  
y = x This:  
 0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> 
 Results in"
" this:  Aliasing  
 0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> 
 
Things to say:  
 
 x and y are variables that refer to the same list 
 object.  
 
 The object is aliased because it has more than one 
 name.  Tracking Changes  
x = [10,20,30,40]  
y = x 
y = [1,2,3]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 Tracking Changes  
x = [10,20,30,40]  
y = x 
y = [1,2,3]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> 
 Tracking Changes  
x = ["
"10,20,30,40]  
y = x 
y = [1,2,3]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
 0 --->  1 
 1 --->  2 
 2 --->  3   y --> 
 The  is  Operator  
>>> x = [10,20,30,40]  
>>> y = [10,20,30,40]  
>>> x is y  
False  
Even though the two lists have the same component  
values. x and y do not refer to the same object.   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
  0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   y --> 
 The  is  Operator  
>>> x = [10,20,30,40]  
>>> y = x  
>"
">> x is y  
True  
x and y  refer to the same object   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> 
 Making a Copy of a List  
x = [10,20,30,40]  
y = list(x)   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 Making a Copy of a List  
x = [10,20,30,40]  
y = list(x)   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
 0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   y --> 
 Slices Create new Objects  
x = [10,20,30,40]  
y = x[1:]   0 --->  10 
 1 --->  20 "
"
 2 --->  30 
 3 --->  40   x --> 
 Slices Create New Objects  
x = [10,20,30,40]  
y = x[1:]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
 0 --->  20 
 1 --->  30 
 2 --->  40   y --> 
 Careful!  
x = [10,20,30,40]  
y = x 
y = x[1:]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 Careful!  
x = [10,20,30,40]  
y = x 
y = x[1:]   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> 
 Careful!  
x = [10,20,30,40]  
y = x 
y = x[1:]   0 --->  10 
 1 --->  20 
 "
"2 --->  30 
 3 --->  40   x --> 
 
 0 --->  20 
 1 --->  30 
 2 --->  40   y --> 
 Void Functions  
x = [40,20,10,30]  
y = x.sort()   0 --->  40 
 1 --->  20 
 2 --->  10 
 3 --->  30   x --> 
 
  y --> 
 Void Functions  
x = [40,20,10,30]  
y = x.sort()   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   x --> 
 
  y --> None 
 
 Void Functions return None, a special type  Void Functions  
x = [40,20,10,30]  
y = list(x)  
y.sort()   0 --->  40 
 1 --->  20 
 2 --->  10 
 3 --->  30   x --> 
 
 Void Fun"
"ctions return None, a special type   0 --->  40 
 1 --->  20 
 2 --->  10 
 3 --->  30   y --> 
 Void Functions  
x = [40,20,10,30]  
y = list(x)  
y.sort()   0 --->  40 
 1 --->  20 
 2 --->  10 
 3 --->  30   x --> 
 
 Void Functions return None, a special type   0 --->  10 
 1 --->  20 
 2 --->  30 
 3 --->  40   y --> 
 Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ == '__main__':  
    u = [1,2,3,4]  
    f(u) 
    print u 
Looks like f deletes the 0 -th chara"
"cter in x  Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ blabla   
    u = [1,2,3,4]  
    f(u) 
    print u 
Follow the red dot and  
watch for impact…   0 --->  1 
 1 --->  2 
 2 --->  3 
 3 --->  4   u --> 
  
 
 
 
 
 
  
                                                      Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ blabla   
    u = [1,2,3,4]  
    f(u) 
    print u 
Parameter x initially refers 
to the same obj"
"ect as u   0 --->  1 
 1 --->  2 
 2 --->  3 
 3 --->  4   u --> 
  
 
 
 
 
 
  
                                                      
 
 
 
 
 
 
  
                                                      x 
  
 
 
 
 
 
  
                                                      
 
 
 
 
 
 
  
                                                      Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ blabla   
    u = [1,2,3,4]  
    f(u) 
    print u 
x[1:] creates a new "
"object  
and x will refer to it   0 --->  1 
 1 --->  2 
 2 --->  3 
 3 --->  4   u --> 
 
 
  0 --->  2 
 1 --->  3 
 2 --->  4   x --> 
  
 
 
 
 
 
  
                                                      
 
 
 
 
 
 
  
                                                      Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ blabla   
    u = [1,2,3,4]  
    f(u) 
    print u 
2 3 4  is printed   0 --->  1 
 1 --->  2 
 2 --->  3 
 3 --->  4   u --> 
 
 
  0 --->  2 "
"
 1 --->  3 
 2 --->  4   x --> 
  
 
 
 
 
 
  
                                                      
 
 
 
 
 
 
  
                                                      Understanding Function Calls  
def f(x):  
    x = x[1:]  
    print x 
     
if __name__ blabla   
    u = [1,2,3,4]  
    f(u) 
    print u 
 1 2 3 4  is printed   0 --->  1 
 1 --->  2 
 2 --->  3 
 3 --->  4   u --> 
 
 
  0 --->  2 
 1 --->  3 
 2 --->  4   x --> 
 Example: The Perfect Shuffle  
Permuting the items in a list comes u"
"p a lot.  
 
Here is a famous example called the  
perfect shuffle : 
40 10 20 30 50 60 70 80 
60 10 50 20 30 70 40 80 Before:  
After:  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 Alternately  
choose  
from the  
"
"“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 7"
"0 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 60 Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 60 30 Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 60 30 70 Alternately  
choose  
from "
"the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 60 30 70 40 Alternately  
choose  
from the  
“half” lists.  Executing the Perfect Shuffle  
The given list:  
40 10 20 30 50 60 70 80 
40 10 20 30 50 60 70 80 Cut it in half:  
The Re -assemble Process:  
10 50 20 60 30 70 40 80 Alternately  
choose  
from the  
“half” lists.  Implementation 1  
def PF1(x):  
  n = len(x)  
  m = n/2 "
"
  top = list(x[:m])  
  bot = list(x[m:])  
  for k in range(m):  
      x[2*k]   = top[k]  
      x[2*k+1] = bot[k]  
     
This is a Void function. It returns None.  
However, it permutes the values in the list referenced  
by x according to the perfect shuffle.  Make a copy  
of the top and  
bottom halves  
They become the  
even -indexed and  
odd-indexed entries  Implementation 2  
 def PF2(x):  
  n = len(x)  
     m = n/2 
     y = [] 
     for k in range(m):  
      y.append(x[k])  
         y.app"
"end(x[k+m])  
     return y  
This is a fruitful function. It returns a reference  
to a list that is the perfect shuffle of the list  
referenced by x  Build y up through  
repeated appending  
x[k] comes from the  
top half of the list,  
x[k+m] comes from  
the bottom half.  Perfect Shuffle Cycles  
Question:  
 
Given a length -n list x where n is even, how many  
perfect shuffle updates are required before we  
cycle back to the original x?  Perfect Shuffle Cycles  
 # Assume x0 is a given list  
  x ="
" list(x0)  
  PF1(x) 
  numPFs = 1  
  while x!=x0:  
    PF1(x) 
     numPFs+=1  
 print numPFs  
 Solution Using the Void function PF1:  
 Perfect Shuffle Cycles  
 # Assume x0 is a given list  
  x = PF2(x0)  
  numPFs = 1  
  while x!=x0:  
   x = PF2(x)  
     numPFs+=1  
 print numPFs  
 Solution Using the Fruitful function PF2:  
 Sample Outputs  
     n      numPFs 
--------------------   
      8      3  
     52      8  
    444    442  
   1000     36  
  10000    300  
 100000    540  
 "
"17. Dictionaries  
Topics:  
 Basic dictionary manipulations  
 How they are different from lists  
 Dictionaries are Objects  
 Application: Word frequency  
 A First Example  
 
 D = {‘I’:1,’V’:5,’X’:10,’L’:50,’C’:100}  
 
This dictionary has 5 items : 
 
   ’I’:1 
   ’V’:5 
   ’X’:10 
   ’L’:50 
   ’C’:100  
 Keys and Values  
 
 D = {‘I’:1,’V’:5,’X’:10,’L’:50,’C’:100}  
 
An item has a key and a value . 
 
For the item  ’V’:5 
 
           ‘V’ is the key  
            5  is the value  
    Set-Up 
 
 D "
"= {‘I’:1,’V’:5,’X’:10,’L’:50,’C’:100}  
 
To set up a small dictionary in this style you do 
this: 
 
1. Use a colon to separate a key from its value.  
 
2. Separate items with a comma.  
 
3. Enclose the whole thing with curly brackets.  
    The Methods .keys and .values 
 
 >>> D = 
{'I':1,'V':5,'X':10,'L':50,'C':100}  
 
>>> D.keys() 
['I', 'X', 'C', 'L', 'V']  
 
>>> D.values () 
[1, 10, 100, 50, 5]  
 Creates a list  
of all the keys  
Creates a list  
of  all the values  Deleting a Dictionary Item  "
"
with del 
>>> D = {'I':1,'V':5,'X':10,'L':50,'C':100}  
 
>>> del D[‘X’]  
 
>>> D 
{'I':1,'V':5,'L':50,'C':100}  Some Questions  
How do you check if a dictionary has a key?  
 
How do you access items in a dictionary?  
 
How can you add an item to a dictionary?  
 
How is a dictionary different from a list?  
 
Are there type -related rules about keys?  
 
Are there type -related rules about values?  Checking to see if a Dictionary 
Has a Particular Key  
>>> D = {'I':1,'V':5,'X':10}  
>>> 'I' in D  
Tr"
"ue 
>>> 'II' in D  
False 
>>> 
Use  in to check if a dictionary has a particular 
key. Checking if D has a particular  
Value Using the values  Method  
>>> D = {'I':1,'V':5,'X':10}  
>>> L = D.values () 
>>> L 
[1, 10, 5]  
>>> 5 in L  
True Use “in” on  
that list  Produce a list  
of all the values  
in D Extracting a Value  
>>> D = {'I':1,'V': 5,'X':10}  
>>> a = D[‘V’]  
>>> a 
5 
Use square bracket notation.  
 
Use the key as you would an integer subscript.  Adding an Item to a Dictionary  
>>> D ="
" {'I':1,'V':5,'X':10}  
>>> D['C'] = 100  
>>> D 
{'I': 1, 'X': 10, 'C': 100, 'V': 5}  
Use assignment, e.g.,  D['C'] = 100  
 
This “connects” the assigned value to the key 
named within square brackets making the pair  
an item, e.g., 'C': 100  
 Changing the Value of an Item  
>>> D = {'I':1,'V':5,'X':10}  
>>> D[‘V'] = 55  
>>> D 
{'I':1, 'X':10, 'V':55}  
 D[‘V'] = 55  does not produce  
 
   {'I':1, ‘V’:5, 'X':10, 'V':55}  
 
Cannot have two items with the same key.  
 Dictionaries are Different 
from"
" Lists  
>>> D = {'I':1,'V':5,'X':10,'L':50}  
 
>>> D  
{'I': 1, 'X': 10, 'L': 50, 'V': 5}  
The items in a dictionary are not ordered as in a  
list. 
 
We see here that Python “shows” a different  
ordering than how D was set up.  Dictionaries are Different 
From Lists  
>>> D = {'I': 1, 'X': 10, 'V': 5}  
>>> D['X']  
10  
 
>>> L = [1,5,10]  
>>> L[1]  
5 Dictionary values are accessed by key not  
subscript.  
Dictionary  
List Dictionaries are Different 
From Lists  
>>> D = {'I': 1, ‘V': 5, ‘X': 10}"
"  
>>> D[2]  
Traceback  (most recent call last):  
  File ""<stdin>"", line 1, in <module>  
KeyError : 2 Dictionary values are accessed by key not  
subscript.  
Python is complaining because  2  is not a key in the D  Lists and Dictionaries  
 0 --->  3 
 1 --->  5 
 2 --->  1 x ---> 
 >>> x = []  
>>> x.append(3)  
>>> x.append(5)  
>>> x.append(1)  
‘I’ --->  1 
‘V’ --->  5 
‘X’ --->  10 D ---> 
 >>> D = {}  
>>> D[‘I’] = 1  
>>> D[‘V’] = 5  
>>> D[‘X’] = 10  
Lists involve mappings from ints to values  "
"
Dictionaries involve mappings from keys to values  Lists and Dictionaries  
 0 --->  3 
 1 --->  5 
 2 --->  1 x ---> 
 >>> x = []  
>>> x.append(3)  
>>> x.append(5)  
>>> x.append(1)  
‘I’ --->  1 
‘V’ --->  5 
‘X’ --->  10 D ---> 
 >>> D = {}  
>>> D[‘I’] = 1  
>>> D[‘V’] = 5  
>>> D[‘X’] = 10  
You “add” to a list using the append method.  
You add an item to a dictionary using a “new” key.  Lists and Dictionaries  
 0 --->  3 
 1 --->  5 
 2 --->  1 x ---> 
 >>> L = []  
>>> L.append(3)  
>>> L.append"
"(5)  
>>> L.append(1)  
‘I’ --->  1 
‘V’ --->  5 
‘X’ --->  10 D ---> 
 >>> D = {}  
>>> D[‘I’] = 1  
>>> D[‘V’] = 5  
>>> D[‘X’] = 10  Empty List  
Empty Dict  
L = [ ] and   L = list()    are equivalent  
D = { }  and   D = dict()  are equivalent   Dictionaries & Lists  
Access via the Square Bracket Notation:  
 
         D[‘x’]        L[2]  
 
The len function can be applied to both:  
>>> x = [10,20,30]  
>>> len(x) 
3 
>>> D = {'a':10,'b':20,'c':30}  
>>> len(D) 
3 Dictionaries & Lists Are 
Objects  
"
"You can have multiple  
references to the  
same object. This is  
the idea of an alias.  >>> x = [10,20,30]  
>>> y = x  
>>> x[0]=100  
>>> y 
[100, 20, 30]  
>>> D = {'a':10,'b':20,'c':30}  
>>> E = D  
>>> D['a'] = 100  
>>> E 
{'a': 100, 'c': 30, 'b': 20}  Dictionaries & Lists Are 
Objects  
It is possible to  
make copies.  >>> x = [10,20,30]  
>>> y = list(x) 
>>> x[0] = 100  
>>> y 
[10, 20, 30]  
>>> D = {'a':10,'b':20,'c':30}  
>>> E = dict(D) 
>>> D['a']=100  
>>> E 
{'a': 10, 'c': 30, 'b': 20}  "
"For-Loops and Dictionaries  
D = {‘I’:1,’V’:5,’X’:10,’L’:50}  
for d in D:  
   print d, D[d]  
I    1 
X   10 
L   50 
V    5 Again, dictionaries  
are not ordered. So  
extra steps  would  
need to be taken  
here for things to  
be printed in a certain order.  For-Loops and Dictionaries  
D = {‘I’:1,’V’:5,’X’:10,’L’:50}  
KeysOfD = D.keys() 
KeysOfD.sort () 
for d in KeysOfD: 
   print d, D[d]  
I    1 
L   50 
V    5 
X   10 Pretty Printing a Short  
Dictionary  
>>> D = {'I':1,'V':5,'X':10,'L':50}  
 
"
">>> str(D) 
 
""{'I': 1, 'X': 10, 'L': 50, 'V': 5}""  Other Examples and Rules  
D1 = {‘red’:[1,0,0],’cyan’:[0,1,1]}  
 
D2 = {1:’one’, 2:’two’, 3:’three’}  
 
D3 = {‘A’:’B’, 1:’C’, ‘D’:2}  
- Keys must be strings or numbers  
- Values can be anything  
-Typically the items all “look alike”, but that  
  is not necessary.  Some Common Errors  
>>> D = {'I':1,'V':5,'X':10}  
 
>>> D('I')  
 
Traceback  (most recent call last):  
  File ""<stdin>"", line 1, in <module>  
 
TypeError : 'dict' object is not callabl"
"e  
Square brackets, not parens !                   Some Common Errors  
>>> D = {'I': 1, 'X': 10, 'V': 5}  
 
>>> x = D['L']  
 
Traceback  (most recent call last):  
  File ""<stdin>"", line 1, in <module>  
 
KeyError : 'L' 
Trying to access a nonexistent item.  
 
Note: D[‘L’] = 50  is legal and adds an item to D                             A Dictionary Application  
Given a text file F that encodes (for example)  
an English novel,  create a dictionary  D that 
specifies the frequency of each word that  "
"
appears in the file.   
 
 Word Frequency Dictionaries  
The dictionary  
 
       D = {‘sun’:34,‘moon’:5,’darcy’:56}  
 
would “say” that there are  
  
  34  occurrences of ‘sun’,  
  5  occurrences of ‘moon’, and  
  56  occurrences of ‘ darcy ’. 
 
 Strategy  
First, read the file and create a list of strings,  
one string for each line in the file:  
 
       L = FileToList ('PridePrej.txt')  
 
 Strategy  
Second, assume the existence of a function 
that can extract a list of words a string s and  
u"
"se it like this:  
 
       wList = stringToWordList (s) 
 
Thus, we would get  
 
               [‘the’,‘quick’,’brown’,’fox ’] 
from  
             ‘The quick, brown fox!’  
            
 Strategy  
Third, figure out how to update the word 
frequency dictionary D:  
 
    L = fileToStringList (‘PridePrej.txt’)  
  D = {} 
  for s in L:  
     wList = stringToWordList (s) 
     for w in wList: 
         Update(w,D) 
 Updating a Dictionary  
W = [‘cat’, mouse’,’dog’,’cat’,rabbit ’] 
‘cat’    --->  20 
‘dog’"
"    --->  10 D ---> 
 
            Look at each word in W and update D accordingly  Updating a Dictionary  
W = [‘cat’, mouse’,’dog’,’cat’,rabbit ’] 
‘cat’    --->  20 
‘dog’    --->  10 D ---> 
 
            Look at each word in W and update D accordingly  Before  Updating a Dictionary  
W = [‘cat’, mouse’,’dog’,’cat’,rabbit ’] 
‘cat’    --->  21 
‘dog’    --->  10 D ---> 
 
            Look at each word in W and update D accordingly  After  Updating a Dictionary  
W = [‘cat’,‘mouse’,’dog’,’cat’,’rabbit ’]"
" 
‘cat’    --->  21 
‘dog’    --->  10 D ---> 
 
            Look at each word in W and update D accordingly  Before  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  21 
‘dog’    --->  10 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly  After  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  21 
‘dog’    --->  10 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly "
" Before  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  21 
‘dog’    --->  11 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly  After  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  21 
‘dog’    --->  11 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly  Before  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  22 
‘dog’    ---> "
" 11 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly  After  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  22 
‘dog’    --->  11 
‘mouse’  --->   1 D ---> 
 
            Look at each word in W and update D accordingly  Before  Updating a Dictionary  
W = [‘cat’,’mouse’,’dog’,’cat’,’rabbit ’] 
‘cat’    --->  22 
‘dog’    --->  11 
‘mouse’  --->   1 
‘rabbit’ --->   1   D ---> 
 
            Look at each word in W and update D accordi"
"ngly  After  We Design Two Key  
Functions To Do all the Work  
 
 
 
 stringToWordList (s) 
 
Update(wList,D) stringToWordList  
def stringToWordList (s): 
   t = '' 
   for c in s.lower(): 
     alfa = 'abcdefghijklmnopqrstuvwxyz ' 
     if c in alfa: 
        t = t + c  
     else: 
        t = t + ' '       
   return t.split() 
 
 A word is made up  
of lower case letters.  
 
After the loop, words are  
separated  by blanks in  
the string  t.  Update(wList,D) 
 def Update( wList,D): 
   for w in wLis"
"t:  
      z = w.lower()  
      if z in D:  
         D[z]+=1 
      else: 
         D[z]=1 z is in the dictionary. So  
increase its frequency count  
z is not in the dictionary. So  
add it in with frequency   
initialized to 1  A Sample Computation  
communicativeness  
condescendingly  
conscientiously  
disappointments  
discontentedness  
disinterestedness  
merchantibility  
misrepresentation  
recommendations  
representations  
superciliousness  
superintendence  
uncompanionable  
unenforceabilit"
"y  These are all  
the words in  
Pride and Prejudice  
that occur only  
once and which  
have 15 or more  
Letters.  
Method. Compute the complete  
word frequency dictionary. Then  
go through it printing a key if its  
value is 1 and its length is 15  
or greater.  "
"18. Introduction to Classes  
Topics:  
 Class Definitions  
 Constructors  
 Example:  The class Point 
 Functions that work with Point  Objects  
 Defining methods  What a Simple Class Definition  
Looks Like  
class Point(object):  
    """""" 
    Attributes:  
        x: float, the x -coordinate of a point  
        y: float, the y -coordinate of a point  
    """""" 
    def __init__( self,x,y ): 
        self.x = x 
        self.y = y 
A class can be used to  “package’’ related data.  One Reason for classe"
"s:  
They Elevate the Level Thinking  
>>> P = Point(2,1)  
>>> Q = Point(6,4)  
>>> d = P.Dist(Q) 
>>> print d  
5 (2,1) (6,4) 
Here, Dist  is a method and P.Dist(Q) 
says “compute and return the distance from  
point P to point Q.  >>> P = Point(2,1)  
>>> Q = Point(6,4)  
>>> d = P.Dist(Q) 
>>> print d  
5 (2,1) (6,4) 
By having a  Point  class we can think at the  
 “point level” instead of at the “ xy level”  One Reason for classes:  
They Elevate the Level Thinking  Classes and Types  
Recall that a t"
"ype is a set of values and  
operations that can be performed on those values.  
 
The four basic “built -in” types:  
 
                   int, float, str, bool 
 
Classes are a way to define new types.  
 
 Examples  
By suitably defining a rectangle class, we could  
say something like  
 
if R1.intersect(R2):  
  print ‘Rectangles R1 and R2 intersect’  
 
 Examples  
By suitably defining a  polynomial class, we  
could perform operations like  
 
             p = q + r  
 
where q and r are polynomials "
"that are  
added together to produce a polynomial p  
 
 
 How to Define a Class  A Point  Class  
class Point(object):  
    """""" 
    Attributes:  
        x: float, the x -coordinate of a point  
        y: float, the y -coordinate of a point  
    """""" 
    def __init__( self,x,y ): 
        self.x = x 
        self.y = y 
A class provides a “blue print” for packaging data.  
The data is stored in the attributes.  A Point  Class  
class Point(object):  
    """""" 
    Attributes:  
        x: float, the x -"
"coordinate of a point  
        y: float, the y -coordinate of a point  
    """""" 
    def __init__( self,x,y ): 
        self.x = x 
        self.y = y 
This special function, called a constructor,  
does the packaging.                  
 
 
                                                                   A Point  Class  
class Point(object):  
    """""" 
    Attributes:  
        x: float, the x -coordinate of a point  
        y: float, the y -coordinate of a point  
    """""" 
    def __init__( self,x,y ):"
" 
        self.x = x 
        self.y = y 
The name of this class is “ Point ” The ‘’ __init__  ‘’ Function  
def __init__( self,x,y ): 
    """""" Creates a Point object  
     
    PreC: x and y are floats  
    """""" 
    self.x = x 
    self.y = y 
That’s a double underscore: __ init __ The  ‘’ __init__ ‘’ Function  
def __init__( self,x,y ): 
    """""" Creates a Point object  
     
    PreC: x and y are floats  
    """""" 
    self.x = x 
    self.y = y 
“self ”  is always the first argument for any  
method de"
"fined in a class.  The “ __init__ ‘’ Function  
def __init__( self,x,y ): 
    """""" Creates a Point object  
     
    PreC: x and y are floats  
    """""" 
    self.x = x 
    self.y = y 
The attributes are assigned values.  Calling the Constructor  
Creates an Object  Calling the Constructor  
>>> a = 3  
>>> b = 4  
>>> Q = Point( a,b)        3      x 
     4     y  Point  
Q 
    3      
    4      a 
b 
The constructor’s  
name is the name  
of the class  Calling the Constructor  
>>> a = 3  
>>> b = 4  
"
">>> Q = Point( a,b)        3      x 
     4     y  Point  Q 
    3      
    4      a 
b 
This creates  
a  Point  object  Calling the Constructor  
>>> a = 3  
>>> b = 4  
>>> Q = Point( a,b)        3      x 
     4     y  Point  
Q 
    3      
    4      a 
b 
The constructor  
returns a reference,  
in effect, the red arrow.  Objects: The Folder Metaphor  
In the office, manila folders organize 
data.  
 
Objects organize data.  
A point object houses float variables x and y,  
called the attributes, wh"
"ere ( x,y) is the point.  Objects: The Folder Metaphor  
In the office manila folders organize  
data.  
 
Objects organize data.  
A color object might house an rgb list like [1,0,1]  
and a string that names it, i.e.,  ‘magenta’  Visualizing a Point Object  
>>> a = 3  
>>> b = 4  
>>> Q = Point( a,b)        3      x 
     4     y  Point  
Q 
    3      
    4      a 
b 
x and y are  
attributes  
 
Attributes are 
variables that live  
inside objects  Accessing an Attribute  
 
The “Dot Notation” Again  "
"
 
Not a coincidence: modules are objects  Accessing Attributes  
>>> Q = Point(3,4)  
>>> print Q 
( 3.000, 4.000)  
>>> Q.x = Q.x + 5 
>>> print Q 
( 8.000, 4.000)  
Q.x is a variable and can ‘’show up” in all 
the usual places, i.e., in an assignment 
statement.  Accessing Attributes  
>>> Q = Point(3,4)  
>>> print Q 
( 3.000, 4.000)  
>>> Q.x = Q.x + 5 
>>> print Q 
( 8.000, 4.000)  
Seems that we can print an object!  The “ __ str__ “ function  
 def __str__(self):  
  return '(%6.3f,%6.3f)' %( self.x"
",self.y ) 
This “double underscore” function is part of  
the class definition.  
 
Whenever a statement like  
 
                   print P 
 
is encountered, then P is “pretty printed” according  
to the format rules.  Two Examples  
A function that returns  a Point  Object:  
      RandomPoint (Lx,Rx,Ly,Ry )  
A function that has input  parameters that are  
Point  objects:  
      Midpoint(P,Q )  Computing a Random Point  
def RandomPoint (Lx,Rx,Ly,Ry ): 
    """""" Returns a point that is randomly chosen "
" 
    from the square Lx<=x<=Rx, Ly<=y<=Ry.  
     
    PreC: Lx and Rx are floats with Lx<Rx  
    Ly and Ry are floats with Ly< Ry 
    """""" 
    x = randu(Lx,Rx) 
    y = randu(Ly,Ry) 
    P = Point( x,y) 
    return P  
calling the  
constructor  Computing a Midpoint  
def Midpoint(P1,P2):  
    """""" Returns a point that is the midpoint of  
    a line segment that connects P1 and P2.  
     
    PreC: P1 and P2 are point objects.  
    """""" 
    xm = (P1.x + P2.x)/2.0  
    ym = (P1.y + P2.y)/2.0  
    Q "
"= Point( xm,ym) 
    return Q  Computing a Midpoint  
def Midpoint(P1,P2):  
    """""" Returns a point that is the midpoint of  
    the line segment that connects P1 and P2.  
     
    PreC: P1 and P2 are points.  
    """""" 
    xm = (P1.x + P2.x)/2.0  
    ym = (P1.y + P2.y)/2.0  
    Q = Point( xm,ym) 
    return Q  
calling the  
constructor  referencing  
a point’s  
attributes  Methods  
s.upper(),s.find(s1),s.count(s2), 
s.append (s2), s.split(c), etc  Methods are functions that are defined  
inside a "
"class definition.  
 
We have experience using  them with strings  
and lists  
L.append (x),L.extend (x),L.sort(),etc Methods  
Now we show how to implement them.  
 
We will design a method for  the Point  
class that can be used to compute the 
distance between two points.  
 
It will be used like this:  
 
        delta = P.Dist(Q) 
    Note the dot notation  
syntax for method  
Calls.  class Point(object):  
    def __init__( self,x,y ): 
        self.x = x 
        self.y = y 
 
    def Dist( self,ot"
"her ): 
       """""" Returns distance from self to other.  
       PreC: other is a point  
       """""" 
       dx = self.x - other.x 
   dy = self.y - other.y 
       d = sqrt(dx**2+dy**2)  
       return d  A Point Class Method: Dist 
Assume proper importing from math class  Using the  Dist  Method  
>>> P = Point(3,4)  
>>> Q = Point(6,8)  
>>> deltaPQ = P.Dist(Q) 
>>> deltaQP = Q.Dist(P) 
>>> print deltaPQ,deltaQP  
5.0 5.0 Let’s create two point objects  and compute  
the distance between them. This can  "
"
be done two ways…  
The usual  
“dot” notation  
for invoking  
a method  class Point(object)  
          : 
   def Dist( self,other): 
      """""" Returns distance from self to other.  
        PreC: P is a point  
        """""" 
        dx = self.x - other.x 
    dy = self.y - other.y 
    d = sqrt(dx**2+dy**2)  
    return d  Method Implementation:  
Syntax Concerns  
Note the use of “self”.  
It is always the first argument of a method.  
 class Point(object):  
          : 
   def Dist( self,other): 
    "
"  """""" Returns distance from self to other.  
      PreC: P is a point  
      """""" 
      dx = self.x - other.x 
  dy = self.y - other.y 
      d = sqrt(dx**2+dy**2)  
      return d  How to Think “Method”  
Think like this: “We are going to apply the method 
dist  to a pair of Point  objects,  self  and other .” 
 class Point(object):  
          : 
   def Dist( self,other ): 
     """""" Returns distance from self to other  
     PreC: other is a point  
     """""" 
     dx = self.x - other.x 
 dy = self.y - ot"
"her.y 
     d = sqrt(dx**2+dy**2  
 return d  Method Implementation:  
Syntax Concerns  
Two Facts:  
 Indentation is important.  
 A class method is part of the class definition . 
 Visualizing a Method Call  
Using State Diagrams  
P = Point(3,4)  
Q = Point(6,8)  
D = P.Dist(Q) Let’s see what happens when we execute  
the following:  Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
     3      x 
     4     y  Point   P  
 d        3      x 
     4     y  Point  Visualizing"
" a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point  
       6      x 
     8     y  Point   P   Q  Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point  
       6      x 
     8     y  Point   P   Q  
 dx = self.x-other.x 
 dy = self.y-other.y 
 d = sqrt(dx**2+dy**2)  
 return d  
 self    other   Dist class Point(object):  
        : 
    def Dist( self,other): 
      """""" Returns distance "
"from self to other. 
      PreC: other is a point  
      """""" 
      dx = self.x - other.x 
  dy = self.y - other.y 
      d = sqrt(dx**2+dy**2)  
  return d   Method: Dist 
Think of self  and  other  as input parameters.  Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point   P   Q  
 dx = self.x-other.x 
 dy = self.y-other.y 
 d = sqrt(dx**2+dy**2)  
 return d  
 self    other   -3  dx:  Control passes to  
the method Dist Dist 
       6     "
" x 
     8     y  Point  Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point  
       6      x 
     8     y  Point   P   Q  
 dx = self.x-other.x 
 dy = self.y-other.y 
 d = sqrt(dx**2+dy**2)  
 return d  
 self    other   -3  dx:  -4  dy:  Dist Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       6      x 
     8     y  Point   P   Q  
 dx = self.x-other.x 
 dy = self.y-other.y 
 d = sqrt(dx**2+dy**2)  
 ret"
"urn d  
 self    other   -3  dx:  -4  dy:   d:  5        3      x 
     4     y  Point  Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point  
       6      x 
     8     y  Point   P   Q  
 dx = self.x-other.x 
 dy = self.y-other.y 
 d = sqrt(dx**2+dy**2)  
 return d  
 self    other   -3  dx:  -4  dy:   d:  5 5 D:  
Dist Visualizing a Method Call  
 P = Point(3,4)  
 Q = Point(6,8)  
 D = P.Dist(Q) 
       3      x 
     4     y  Point  
    "
"   6      x 
     8     y  Point   P   Q  5 D:  Checking Things Out  
>>> P1 = RandomPoint (-10,10) 
>>> P2 = RandomPoint (-10,10) 
>>> M = Midpoint(P1,P2)  
>>> print M.Dist(P1) 
4.29339610681  
>>> print M.Dist(P2) 
4.29339610681  Summary: Base Types vs Classes  
          Base Types  
 
Built into Python  
Instances are values  
Instantiate w/ Literals  
Immutable  
           Classes  
 
Defined in Modules  
Instances are objects  
Instantiate  w/ constructors  
Mutable  
 A Note on Copying an Object  
"
"There is a difference between creating an  
alias and creating a genuine second copy of 
an object.  This Does Not Create a Copy…  
>>> Q = Point(3,4)  
>>> P = Q  
       3      x 
     4     y  Point  
Q 
P 
It creates an alias, not a copy.  This Does Create a Copy…  
>>> Q = Point(3,4)  
>>> P = Point( Q.x,Q.y) 
       3      x 
     4     y  Point  
Q 
P        3      x 
     4     y  Point  And This Also Creates a Copy…  
>>> Q = Point(3,4)  
>>> P = copy(Q)  
       3      x 
     4     y  Point  
Q 
"
"P        3      x 
     4     y  Point  
The function copy must be imported . The Module copy 
from copy import copy  
Import this function and use it to make copies  
of objects.  
 
deepcopy  is another useful function from  
this module —more later.  Using copy   
>>> Q = Point(3,4)  
>>> P1 = copy(Q)  
>>> P1.x = 5  
>>> print Q 
( 3.000, 4.000)  
>>> print P1 
( 5.000, 4.000)  
We are modifying P1, but Q remains the same  Methods vs Functions  
It is important to understand the differences  
between me"
"thods and functions, i.e., how they  
are defined and how they are invoked.  A >>Function<< that Returns the 
Distance Between Two Points  
def Dist(P1,P2):  
    """""" Returns the distance from P1 to P2.  
    PreC: P1 and P2 are points  
    """""" 
    d = sqrt((P1.x-P2.x)**2+(P1.y -P2.y)**2)  
    return d  def Dist( self,other ): 
  dx = self.x - other.x 
  dy = self.y - other.y 
  D = sqrt(dx**2+dy**2)  
  return D  Methods and (Regular) Functions  
def Dist(P,Q):  
  dx = P.x - Q.x 
  dy = P.y - Q.y 
  D "
"= sqrt(dx**2+dy**2)  
  return D  >>> P = Point(3,4)  
>>> Q = Point(6,8)  
>>> P.Dist(Q) 
5.0 
>>> P = Point(3,4)  
>>> Q = Point(6,8)  
>>> Dist(Q,P)  
5.0 "
"19. Lists of Objects  
Topics:  
 Example:  The class Disk 
 Boolean -Valued Methods  
 A Disk Intersection Problem  
 Example: The class CountyPop   
 Representing census -related data  
 Sorting a list of CountyPop  objects  Visualizing a List of Points  
>>> P = Point(3,4);Q = Point(1,2);R = Point(9,3)  
>>> L = [P,Q,R]  L: 
       3      x 
     4     y  Point  
       1      x 
     2     y  Point  
       9      x 
     3     y  Point                 Visualizing a List of ints 
>>> L = [3,1,9]  L:    "
" 3         1         9     A List of Objects  
We would like to assemble a list whose  
elements are not numbers or strings, but  
references to objects.  
 
For example, we have a hundred points in  
the plane and a length -100 list of points  
called ListOfPoints . 
 
Let’s compute the average distance to (0,0).  Working with a  
 List of Point  Objects  
Origin = Point(0,0)  
d = 0 
for P in ListOfPoints : 
   d += P.Dist(Origin)  
N = len(ListOfPoints ) 
AveDist = d/N  
A lot of familiar stuff: Running "
"sums.  A for -loop 
based on “in”.  The len function, Etc  A List of Random Points  
def RandomCloud (Lx,Rx,Ly,Ry,n ): 
    """""" Returns a length -n list of points,  
    each chosen randomly from the rectangle  
    Lx<=x<=Rx, Ly<=y<=Ry.  
    PreC: Lx and Rx are floats with Lx<Rx,  
    Ly and Ry are floats with Ly< Ry, and 
    n is a positive int.  
    """""" 
    A = [] 
    for k in range(n):  
        P = RandomPoint (Lx,Rx,Ly,Ry ) 
        A.append (P) 
    return A  The append method for lists 
works "
"for lists of objects.  Recall: Random Point  
def RandomPoint (Lx,Rx,Ly,Ry ): 
    """""" Returns a point that is randomly chosen  
    from the square Lx<=x<=Rx, Ly<=y<=Ry.  
     
    PreC: Lx and Rx are floats with Lx<Rx  
    Ly and Ry are floats with Ly< Ry 
    """""" 
    x = randu(Lx,Rx) 
    y = randu(Ly,Ry) 
    P = Point( x,y) 
    return P  
Use import to get access to classes  defined in other modules  Visualizing a List of Points  
>>> P = Point(3,4);Q = Point(1,2);R = Point(9,3)  
>>> L = [P,Q,R]  "
"L: 
       3      x 
     4     y  Point  
       1      x 
     2     y  Point  
       9      x 
     3     y  Point                 Visualizing a List of Points  
>>> P = Point(3,4);Q = Point(1,2);R = Point(9,3)  
>>> L = [P,Q,R]  L: 
       3      x 
     4     y  Point  
       1      x 
     2     y  Point  
       9      x 
     3     y  Point                 
More accurate: A  List of references to Point objects  Operations on a List of Points  
>>> L[1].x = 100  L: 
       3      x 
     4     y  P"
"oint  
       1      x 
     2     y  Point  
       9      x 
     3     y  Point                 
Before  Operations on a List of Points  
>>> L[1].x = 100  L: 
       3      x 
     4     y  Point  
   100      x 
     2     y  Point  
       9      x 
     3     y  Point                 
After  Operations on a List of Points  
>>> L[1] = Point(5,5)  L: 
       3      x 
     4     y  Point  
       1      x 
     2     y  Point  
       9      x 
     3     y  Point                 
Before  Operations o"
"n a List of Points  
>>> L[1] = Point(5,5)  L: 
       3      x 
     4     y  Point  
       5      x 
     5     y  Point  
       9      x 
     3     y  Point                 
After  Printing a List of Points  
def printCloud (A): 
    """""" Prints the points in A  
     
    PreC : A is a list of points.  
    """""" 
    for a in A:  
        print a 
Synonym for the loop:  
 
    for k in range( len(A)): 
      print A[k]  We Now Showcase the Use  
of Lists of Objects  
Example 1. A Disk Intersection Prob"
"lem  
 
Example 2. A Census Data Problem  A Disk Intersection Problem  An Intersection Problem  
We have a 10 -by-10 target  
 
for k in range(100):  
 
    Generate a random disk  D  
 
    Display D if it does not  
    touch any of the  
    previously displayed disks  
Assume all the disks have radius 1  
and all inside the target.  A Class for Representing Disks  
class Disk(object):  
    """""" 
    Attributes:  
        center: Point, the center of the disk  
        radius: float, the radius of the di"
"sk   
    """""" 
    def __init__( self,P,r ): 
        """""" Creates a Disk object with  
        center P and radius r  
        PreC: P is a Point,r is a pos float  
        """""" 
        self.center  = P 
        self.radius  = r 
Note that an attribute can be an object. The center  attribute is a Point The RandomDisk  Function 
def RandomDisk (n): 
    """""" Returns a random radius -1 disk whose 
 center is inside the 2n -by-2n square 
 centered at (0,0).  
    Pre: n is a positive int 
    """""" 
    x = randu"
"(-n,n) 
    y = randu(-n,n) 
    center = Point( x,y) 
    radius = 1  
    return Disk( center,radius ) When Does a Pair of Disks  
Intersect?  
Answer: When the distance between their centers is less than the  
sum of their radii.  The Method  Intersects  
def Intersects( self,other ): 
        """""" Returns True if self and other     
    intersect and False otherwise.  
        PreC: self and other are Disk objects  
        """""" 
        # The center -to-center distance:  
        c1 = self.center  
     "
"   c2 = other.center  
        d = c1.Dist(c2)  
        # The sum of the two radii  
        radiusSum  = self.radius  + other.radius  
        TheyIntersect  = (radiusSum  >= d ) 
        return TheyIntersect  An Intersection Problem  
We have a 10 -by-10 target  
 
for k in range(100):  
 
    Generate a random disk  D  
 
    Display D if it does not  
    touch any of the  
    previously displayed disks  
Assume all the disks have radius 1  
and all inside the target.  A Critical Function  
def outsid"
"eAll (D0,L): 
    """""" Returns True if D0 doesn't  
    intersect any of the disks in L  
     
    PreC: D0 is a Disk and L is a  
    list of Disks  
    """""" 
    for D in L:  
        if D.Intersects (D0): 
            return False  
    return True  Using  outsideAll  
# The list of displayed disks…  
m = 10 
DiskList  = []  
for k in range(100):  
   D = RandomDisk (m-1)  
   if outsideAll (D,DiskList ): 
      # D does not intersect any  
      # of the displayed disks  
      ShowDisk (D,MAGENTA)  
  "
"    DiskList.append (D) 
nDisplayed  = len(DiskList ) Display D and append it to  
the list of displayed disks  Starts out as the empty list  A Census Data Sorting  
Problem What Can We Sort?  
We can sort a list of numbers from small to big  
 (or big to small).  
 
We can sort a list of strings from “A -to-Z”  
 (or “Z -to-A”). 
 
We can sort a list of objects based on an  
 attribute if that attribute is either a  
 number or a string.  
 
 A Sorting Problem  
Suppose we have  
 
    class Student(object"
"):  
  Attributes:  
        Name: string, student’s name  
        GPA : float, student’s gpa 
 
and that L is a list of Student  objects…  A List of Student Objects  
 
 
 
 
 
 Name:  
GPA :   3.31   ‘Gaga’  Student   
 
 
 
 
 Name:  
GPA :   4.00   ‘Cher’  Student   
 
 
 
 
 Name:  
GPA :   2.95  ‘Adele’  Student                 L: 
L[0]            L[1]             L[2]  A List of Student Objects  
 
 
 
 
 
 Name:  
GPA :   3.31   ‘Gaga’  Student   
 
 
 
 
 Name:  
GPA :   4.00   ‘Cher’  Student   
"
" 
 
 
 
 Name:  
GPA :   2.95  ‘Adele’  Student                 L: We can sort this list  
based on Name or  
GPA.  
L[0]            L[1]             L[2]  A List of Student Objects  
 
 
 
 
 
 Name:  
GPA :   2.95  ‘Adele’  Student   
 
 
 
 
 Name:  
GPA :   4.00   ‘Cher’  Student   
 
 
 
 
 Name:  
GPA :   3.31   ‘Gaga’  Student                 L: Sorted by Name  
L[0]            L[1]             L[2]  A List of Student Objects  
 
 
 
 
 
 Name:  
GPA :   4.00   ‘Cher’  Student   
 
 
 
 
 Name:  
GPA"
" :   3.31   ‘Gaga’  Student   
 
 
 
 
 Name:  
GPA :   2.95  ‘Adele’  Student                 L: Sorted by GPA  
L[0]            L[1]             L[2]  How to Do We Do This?  
You have to write a “getter” function that  
extracts the value of the “key” attribute.  
 
 
The name of this getter function is then  
passed as an argument to the sort method.  
We illustrate the technique on a problem that involves census data.  The Class County 
class CountyPop (object):  
    """""" 
    Attributes:  
      Name: "
"the name of the county (string)  
      State: the name of the state (string)  
      Pop2010: the 2010 population ( int) 
      Pop2011: the 2011 population ( int) 
      Pop2012: the 2012 population ( int) 
      Pop2013: the 2013 population ( int) 
      Pop2014: the 2014 population ( int) 
    """""" Setting Up the List of  
CountyPop  Objects  
The file CensusData.csv  has these columns:  
 
     5    State Name  
     6    County Name  
     7    2010 county population  
     10   2011 county population "
" 
     11   2012 county population  
     12   2013 county population  
     13   2014 county population  
 TheCounties  = fileToStringList ('CensusData.csv')  
L = [] 
for c in TheCounties : 
   v = c.split(',') 
   c = CountyPop (v[6],v[5],int(v[7]),int(v[10]), 
              int(v[11]),int(v[12]),int(v[13])) 
   L.append (C) 
 
The constructor sets up the Name, State,  
Pop2010, Pop2011, Pop2012, Pop2013, and  
Pop2014 attributes  Setting Up the List of  
CountyPop  Objects  Let’s Sort!  
def getPop2014("
"C):  
   # C is a County Object  
    return C.Pop2014  
             : 
if __name__ == '__main__':  
             : 
 L.sort(key=getPop2014 ,reverse=True)  
 
 for k in range(10):  
     print L[k],L[k].Pop2014  This getter function  
grabs the 2014  
population.  
Printing the top ten  
counties in the USA in  
terms of population.  And here is how we  
tell sort  to use it  Top Ten in 2014  
 Los Angeles County, California 10116705  
          Cook County, Illinois  5246456  
           Harris County, Te"
"xas  4441370  
       Maricopa County, Arizona  4087191  
   San Diego County, California  3263431  
      Orange County, California  3145515  
     Miami-Dade County, Florida  2662874  
         Kings County, New York  2621793  
           Dallas County, Texas  2518638  
   Riverside County, California  2329271  "
" 2. Modules , Scripts,  and I/O  
 Topics:  
 Script Mode  
 Modules  
 The print  and input  statements  
 Formatting  
 First look at importing stuff from  
  other modules  
  
 The Windchill  Calculation  
Let’s compute the windchill  temperature given  
that the air temperature is T = 32F and the wind  
is W = 20mph.  
 
Here is the formula courtesy of the National  
Weather Service:  
  The formula only applies if T <= 50F and W>=3mph.   
16.) 4275.0 75.35() 6215.0 74.35( WT T Wchill Use Pytho"
"n in Interactive Mode  
>>> Temp = 32  
>>> Wind = 20  
>>> A = 35.74  
>>> B = .6215  
>>> C = -35.75 
>>> D = .4275  
>>> e = .16  
>>> WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
>>> print WC  
19.9855841878  
 
  The print statement is used for displaying values in variables.   Quick Note on  print 
The line  
 
    >>> print WC  
 
results  in the display of the value currently  
housed in the variable WC 
  More on the  print statement later.   Motivating “Script Mode”  
What is the new windchill  if the win"
"d is  
increased from 20mph to 30mph?  
 
Looks like we have to type in the same  
sequence of statements. Tedious.  
 
Wouldn’t it be nice if we could store the  
sequence of statements in a file and then have  
Python “run the file” after we changed  
Wind = 20  to Wind = 30  ?   Script Mode  
Instead of running Python in interactive mode , 
we run Python in  script mode . 
 
The code to be run (called a script ) is entered  
into a file (called a module ). 
 
We then ask Python to “run the script”.  What"
" is a Module?  
 
A module  is a  .py  file that contains Python code.  
 
  In CS 1110, these are created using Komodo Edit.   The Module WindChill.py  
Temp = 32  
Wind = 20  
A = 35.74  
B = .6215  
C = -35.74 
D = .4275  
e = .16 
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  
  Produced using Komodo Edit. This is our first draft.   WindChill.py  Running the Module  
Here are the steps to follow in the  
command shell:  
 
1. Navigate the file system so that you are  
 “in” the same diretory  that hous"
"es  
 WindChill.py  
 
2. Type:   python WindChill.py  
 Details  
Suppose I have a directory on my desktop 
called TODAY  where I keep all my python files 
for today’s lecture.  
 
 
I navigate the file system until I get this 
prompt:  
 
C:\Users\cv\Desktop\TODAY> 
 Asking Python to Run  
the Code in WindChill.py  
C:\Users\cv\Desktop\TODAY> Python WindChill.py  
 
19.6975841877955  
To save space in subsequent slides, we will refer to  
C:\Users\cv\Desktop\TODAY>     as     Blah \Blah>  Multiple Stateme"
"nts on a Line  
Temp = 32  
Wind = 20  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  Can put multiple statements on a line. Separate 
the statements with semicolons.  
WindChill.py  
For lecture slides we will sometimes do this to save space.  
But in general, it makes for ``dense reading’’ and should be avoided.  Module Readability: Comments  
Comments begin with a “#”  
Temp = 32  
Wind = 20  
# Model Parameters  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
# Comp"
"ute and display the windchill  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  WindChill.py  Comments: Guidelines  
Wind = 20 # wind speed in miles -per-hour Comments can also appear on the same line  
as a statement:  
Everything to the right of the “#” is  
part of the comment and not part of  the  
program.  Comments and Readability  
 
Start each program (script) with a concise  
description of what it does.  
 
Define each important variable/constant.  
 
A chunk of code with a specific task  should 
b"
"e generally be prefaced with a concise  
comment . 
 
 Module Readability: docstrings  
A special comment at the top of the module.  
“““Computes windchill  as a function of  
   wind(mph)and temp (Fahrenheit).”””  
Temp = 32  
Wind = 20  
# Model Parameters  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
# Compute and display the windchill  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  WindChill.py  Docstrings : Guidelines  
Docstrings  are multiline comments that are  
delimited by triple quotes:   “““ 
 
T"
"hey are strategically located at the beginning  
of “important” code sections.  
 
Their goal is to succinctly describe what the  
code section is about.   
  One example of an “important” code section is a module.   Trying Different Inputs  
“““Computes windchill  as a function of  
   wind(mph)and temp (Fahrenheit).”””  
Temp = 32  
Wind = 20  
# Model Parameters  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
# Compute and display the windchill  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  Can we be more "
" 
flexible here?  WindChill.py  Handy Input  
If we want to explore windchill  as a 
function of windspeed  and temperature,  
then it is awkward to proceed by editing  
the module WindChill.py every time  
we want to check out a new wind/temp  
combination.  
 
The input  statement addresses this issue.  The input Statement  
The input  statement is used to solicit  
values via the keyboard:  
 
    input ( < string that serves as a prompt >  ) 
 
  Later we will learn how to input data from a file.   Temp"
"  and Wind  via  input   
“““Computes windchill  as a function of  
   wind(mph)and temp (Fahrenheit).”””  
 
Temp = input(‘Enter temp (Fahrenheit):’)  
Wind = input(‘Enter wind speed (mph):’)  
 
# Model Parameters  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
# Compute and display the windchill  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print WC  WindChill.py  A Sample Run  
> Enter temp (Fahrenheit) :   The prompt is displayed…  
And you respond…  
> Enter temp (Fahrenheit) : 15   A Sample Run  
> Enter wind s"
"peed (mph) :   The next prompt is displayed…  
And you respond again…  
> Enter wind speed (mph) : 50   A Sample Overall “Dialog”  
BlahBlah > python WindChill.py  
Enter temp (Fahrenheit) : 15   
Enter wind speed (mph)  : 50  
-9.79781580448  
 For more on Keyboard Input  
Practice with the demo file      
   ShowInput.py  
 
There is an alternative to input called   
    raw_input   
 
It is handier in certain situations. Practice with  
    
   ShowRawInput.py  
 
 More Readable Output  
The print  state"
"ment can be used to format  
output in a way that facilitates the  
communication of results.  
 
We don’t need to show wind chill to the  
12th decimal!  
 More Readable Output  
“““Computes windchill  as a function of  
   wind(mph)and temp (Fahrenheit).”””  
 
Temp = input(‘Enter temp (Fahrenheit):’)  
Wind = input(‘Enter wind speed (mph):’)  
 
# Model Parameters  
A=35.74;B=.6215;C= -35.74;D=.4275;e=.16  
# Compute and display the windchill  
WC = (A+B*Temp)+(C+D*Temp)*Wind**e  
print '        Windchil"
"l  :%4.0f' % WC  WindChill.py  The “Dialog” With Formatting  
BlahBlah > WindChill  
Enter temp (Fahrenheit) :  15   
Enter wind speed (mph)  :  50  
-9.79781580448  
 
BlahBlah > WindChill  
Enter temp (Fahrenheit) :  15   
Enter wind speed (mph)  :  50  
             Windchill   : -10 
 print 
without  
formatting  
print 
with  
formatting  The print Statement  
The print  statement tries to intelligently  
format the results that it is asked to 
display.  
 
print  with formatting puts you in control.  "
"
 
  Later we will learn how to direct output to a file   print w/o Formatting  
0.4 
0.333333333333  
1234.56789012         
  For float values, print (by itself)  displays  up to 12 significant digits   x = 2./5.  
print x 
x = 1./3.  
print x 
x = 1234.5678901234  
print x Script:  
Output:  print w/o Formatting  
1234 12345678         x = 1234  
y = 12345678  
print x,y Script:  
Output:  
  To display more then one value on a line, separate the references with commas.  
A single blank is placed in betw"
"een the displayed values.  print  with the %f Format  
x = 1234.123456789  
print ‘x = %16.3f’ %x  
print ‘x = %16.6f’ %x  
print ‘x = %16.9f’ %x     
 
x =         1234.123  
x =      1234.123457  
x =   1234.123456789          
  Formatted print statements are developed by “trial and error.”  
It not a topic for memorization and it does not show up on exams.     print  with the %e Format  
x = 1234.123456789  
print ‘x = %16.3e’ %x  
print ‘x = %16.6e’ %x  
print ‘x = %16.9e’ %x     
 
x =        1.234e+0"
"3  
x =     1.234123e+03  
x =  1.234123456e+03          
  Formatted print statements are developed by “trial and error.”  
It not a topic for memorization and it does not show up on exams.     print  with the %d Format  
x = 1234  
print ‘x = %4d’  %x  
print ‘x = %7d’  %x  
print ‘x = %10d’ %x     
 
x = 1234  
x =    1234  
x =       1234          
  Formatted print statements are developed by “trial and error.”  
It not a topic for memorization and it does not show up on exams.     print  with the %s F"
"ormat  
The Beatles in 1964         Band = ‘The Beatles’  
print ‘%s in 1964’ % Band  Script:  
Output:  
  Strings can be printed too   Formatted Print With More than 
1 Source Value  
The Beatles in 1964 and 1971         y1 = 1964  
y2 = 1971  
Band = ‘The Beatles’  
print ‘%s in %4d and %4d’ % (Band,y1,y2)  Script:  
Output:    Need parentheses 
here.    print with Formatting  
print  < string with formats >  %( < list-of-variables > )  
A string that  
includes  
things like  
%10.3f. %3d,  
%8.2e, etc "
" Comma -separated,  
e.g., x,y,z. One  
variable for each  
format marker  
in the string. The  
Parentheses are  
Required if more  
than one variable.  
Practice with the demo file  ShowFormat.py  Why Program Readability and 
Style is Important  
How we “do business” in commerical , scientific,  
and engineering settings increasingly relies on  
software.  
 
Lack of attention to style and substandard  
documentation promotes error and makes it  
hard to build on one another’s software.  Another Detail  
"
"All modules that are submitted for grading  
should begin with three comments.  
# WindChill.py  
# Xavier Zanzibar (xz3)  
# January 1, 1903    
 
           etc Name of module    
Your name and netid     
Date  WindChill.py  A Final Example  
Write a script that solicits the area of  
a circle and prints out the radius.  Preliminary Solution  
A = input(‘Enter the circle area: ‘)  
r = sqrt(A/3.14)  
print r 
  The Math: solve A = pi*r*r for r.   Radius.py  We Get an Error  
A = input(‘Enter the circle ar"
"ea: ‘)  
r = sqrt(A/3.14)  
print ‘The radius is %6.3f’ % r  
  sqrt is NOT a built -in function    r = sqrt(A/3.14)  
NameError : name ' sqrt' is not defined  Final Solution  
from math import sqrt 
A = input(‘Enter the circle area: ‘)  
r = sqrt(A/3.14)  
print ‘The radius is %6.3f’ % r  
  The Math: solve A = pi*r*r for r.   We are importing the function sqrt   
from the math  module.  Radius.py  The Idea Behind import 
People write useful code and place it in 
modules that can be accessed by others.  
 "
"
The import statement makes this possible.  
 
One thing in the math module is the square 
root function sqrt .  
 
If you want to use it in your module just say  
 
       from math import sqrt 
  Better Final Solution  
from math import sqrt,pi 
A = input(‘Enter the circle area: ‘)  
r = sqrt(A/pi) 
print ‘The radius is %6.3f’ % r  
  Can import more than one thing from a module. Much more on import later.   We are importing the function sqrt and  
the constant pi from the math  module.  Radius.py  Sample"
" Run  
 
C:\Users\cv\Desktop\TODAY> Python Radius.py  
Enter the circle area: 10  
The radius is  1.785  
 
  For more insights, check out the lecture script  SurfaceArea.py.    "
"BRANCHING, 
ITERATION
(download slides and . pyfiles ĂŶĚ follow along!)
6.0001 LECTURE 2
6.0001 LECTURE 2 1LAST TIME
syntax and semantics
scalar objects
simple operations
expressions, variables and values
6.0001 LECTURE 2 2TODAY
string object type
branching and conditionals
indentation
iteration and loops
6.0001 LECTURE 2 3STRINGS
letters, special characters, spaces, digits
enclose in quotation marks or single quotes
hi = ""hello there""
concatenate strings
name = ""ana""
greet = hi + name
greeting "
"= hi + "" ""+ name
do some operations on a string as defined in Python docs
silly = hi + "" ""+ name * 3
6.0001 LECTURE 2 4INPUT/OUTPUT: print
used to output stuff to console
keyword is print
x = 1
print(x)
x_str= str(x)
print(""my fav numis"", x, ""."", ""x ="", x)
print(""my fav numis "" + x_str+ "". "" + ""x = "" + x_str)
6.0001 LECTURE 2 5INPUT/OUTPUT: input("""")
prints whatever is in the quotes
user types in something and hits enter
binds that value to a variable
text = input(""Type anything... "")
print(5*text)
i"
"nput gives you a string so must cast if working 
with numbers
num= int(input(""Type a number... ""))
print(5* num)
6.0001 LECTURE 2 6COMPARISON OPERATORS ON
int,float, string
iand jare variable names
comparisons below evaluate to a Boolean 
i> j
i>= j
i< j
i<= j
i== jequality test, True if iis the same as j
i!= jinequality test, True if inot the same as j
6.0001 LECTURE 2 7LOGIC OPERATORS ON bools
aand bare variable names (with Boolean values)
not aTrue if ais False
False if ais True
a and b True if bo"
"th are True
a or b True if either or both are True
6.0001 LECTURE 2 8A B A and B A or B
True True True True
True False False True
False True False True
False False False FalseCOMPARISON EXAMPLE
pset_time = 15
sleep_time = 8
print(sleep_time > pset_time )
derive = True
drink = False
both = drink and derive
print(both)
6.0001 LECTURE 2 9If right clear,
go right If right blocked,
go forwardIf right and 
front blocked,
go leftIf right , front, 
left blocked,
go back
6.0001 LECTURE 2 10CONTROL FLOW -BRANCHING
i"
"f <condition>:
<expression>
<expression>
...
if <condition >:
<expression>
<expression >
...
else:
<expression >
<expression >
...if <condition>:
<expression>
<expression>
...
elif<condition>:
<expression > 
<expression>
...
else:
<expression>
<expression >
...
<condition> has a value True or False
evaluate expressions in that block if <condition> is True
6.0001 LECTURE 2 11INDENTATION
matters in Python
how you denote blocks of code
x = float(input(""Enter a number for x: ""))
y = float(input(""Enter a num"
"ber for y: ""))
if x == y:
print(""x and y are equal"")
if y != 0:
print(""therefore, x / y is"", x/y)
elifx < y:
print(""x is smaller"")
else:
print(""y is smaller"")
print(""thanks!"")print(""x and y are equal"")
if y != 0:
print(""therefore , x / y is"", x/y)
print(""x is smaller"")
print(""y is smaller"")
6.0001 LECTURE 2 12=vs ==
x = float(input (""Enter a number for x: ""))
y = float(input (""Enter a number for y: ""))
if x == y:
print(""x and y are equal"")
if y != 0:
print(""therefore , x / y is"", x/y)
elifx < y:
print(""x is"
" smaller"")
else:
print(""y is smaller"")
print(""thanks!"")
6.0001 LECTURE 2 13Legend of Zelda –
Lost Woods
keep going right, 
takes you back to this 
same screen, stuck in 
a loop
if <exit right>:
<set background to woods_background>
if <exit right>:
<set background to woods_background>
if <exit right>:
<set background to woods_background>
and so on and on and on...
else:
<set background to exit_background>
else:
<set background to exit_background>
else:
<set background to exit_background>
<set background to"
" woods_background >
if <exit right>:
else:
<set background to exit_background ><set background to woods_background >
if <exit right>:
else:
<set background to exit_background ><set background to woods_background >
and so on and on and on...
<set background to exit_background >
6.0001 LECTURE 2 14Image Courtesy Nintendo, All Rights Reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.while <exit right>:
<set background to woods_"
"background>
<set background to exit_background>
Legend of Zelda –
Lost Woods
keep going right, 
takes you back to this 
same screen, stuck in 
a loop
6.0001 LECTURE 2 15<set background to woods_background >Word Cloud copyright unknown, All Right Reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.CONTROL FLOW: 
while LOOPS
while <condition>:
<expression>
<expression>
...
<condition> evaluates to a Boolean
if <condition> is"
" True , do all the steps inside the 
while code block
check <condition> again
repeat until <condition> is False
6.0001 LECTURE 2 16while LOOP EXAMPLE
You are in the Lost Forest.
************
************

************
************
Go left or right?
PROGRAM:
n = input(""You're in the Lost Forest. Go left or right? "")
while n == ""right"":
n = input(""You're in the Lost Forest. Go left or right? "")
print(""You got out of the Lost Forest !"")
6.0001 LECTURE 2 17CONTROL FLOW: 
while and for LOOPS
iterate through "
"numbers in a sequence
# more complicated with while loop
n = 0
while n < 5:
print(n)
n = n+1
# shortcut with for loop
for n in range(5):
print(n)
6.0001 LECTURE 2 18CONTROL FLOW: for LOOPS
for <variable> in range(< some_num >):
<expression>
<expression > 
...
each time through the loop, <variable> takes a value
first time, <variable> starts at the smallest value
next time, <variable> gets the prev value + 1
etc.
6.0001 LECTURE 2 19range(start,stop,step )
default values are start = 0 and step = 1 and op"
"tional
loop until value is stop -1 
mysum= 0
for iin range(7, 10 ):
mysum+= i
print(mysum)
mysum= 0
for iin range(5, 11, 2):
mysum+= i
print(mysum)
6.0001 LECTURE 2 20break STATEMENT
immediately exits whatever loop it is in
skips remaining expressions in code block
exits only innermost loop!
while <condition_1>:
while <condition_2>:
<expression_a >
break
<expression_b >
<expression_c >
6.0001 LECTURE 2 21break STATEMENT
mysum = 0
for iin range(5, 11, 2):
mysum += i
if mysum == 5:
break
mysum+= 1
print(m"
"ysum)
what happens in this program? mysum+= i
if mysum== 5:
break
6.0001 LECTURE 2 22for VS while LOOPS
for loops
know number of 
iterations
can end early via 
break
uses a counter
canrewrite a for loop 
using a while loopwhile loops
unbounded number of 
iterations
can end early via break
can use a counter but 
must initialize before loop 
and increment it inside loop
may not be able to 
rewrite a while loop using 
a for loop
6.0001 LECTURE 2 23MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduc"
"tion to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"20. More Complicated Classes  
Topics:  
         Example: The class Fraction   
 Operator Overloading  
 Class Invariants  
 Example:  The class SimpleDate  
 Class Variables  
 deepcopy  A Class For Manipulating  
Fractions  
2/3 + 13/6 = (2*6+13*3)/(3*6)  
           = 51/18 
           = 17/6 You in Grade  
School:  
>>> x = Fraction(2,3)  
>>> y = Fraction(13,6)  
>>> z = x+y  
>>> print z 
17/6 Python in  
College:  A Class For Manipulating  
Fractions  
2/3 * 3/4 = (2*3)/(3*4)  
          = 6/12 
   "
"       = 1/2  You in Grade  
School:  
Python in  
College:  >>> x = Fraction(2,3)  
>>> y = Fraction(3,4)  
>>> z = x+y  
>>> print z 
1/2 Let’s Define a Class to Do This 
Stuff  
class Fraction(object):  
    """""" 
    Attributes:  
        num: the numerator [ int] 
        den: the denominator [ int]  
     
Not good enough. Do not want zero denominators!  """"""  Let’s Define a Class to Do This 
Stuff  
class Fraction(object):  
    """""" 
    Attributes:  
        num: the numerator [ int] 
        den: the"
" denominator [ nonzero int]  
    
  
Still not good enough. Fractions  should be  
reduced to lowest terms, e.g., -3/2  not  -24/16   """"""  A Note About Greatest  
Common Divisors  
  p      q       gcd(p,q)     p/q  
------------------------------------  
 16      24          8        2/3  
 19      47          1       19/47  
 15      25          5        3/5  
Reducing a fraction to lowest terms involves  
finding the gcd of the numerator and  
denominator and dividing.  Computing the Greatest  
Common D"
"ivisor  
def gcd(a,b): 
    a = abs(a)  
    b = abs(b)  
    r = a%b 
    while r>0:  
        a = b 
        b = r 
        r = a%b   
    return b  Euclid’s  
Algorithm  
 
300BC  
 
We will  
assume this  
is given and won’t  
worry why it works  Back to the Class Definition  
class Fraction(object):  
    """""" 
    Attributes:  
        num: the numerator [ int] 
        den: the denominator [nonzero int] 
        num/den is reduced to lowest terms   
     
These “rules” define a class invariant . Prope"
"rties  
that all  Fraction   objects obey.   """"""  The Constructor  
def __init__( self,p,q =1): 
     d = gcd(p,q) 
     self.num = p/d  
     self.den = q/d  
>>> x = Fraction(10,4)  
>>> print x  
5/2 
Whole numbers are fractions  
too. Handy to use the optional  
argument feature.  >>> x = Fraction(10)  
>>> print x 
10/1 Let’s Look at the Methods  
Defined in the Class Fraction  
Informal synopsis:  
 
              in            out  
-------------------------------------  
negate        2/3          -"
"2/3 
Invert        2/3           3/2  
__add__      2/3 + 1/6      5/6  
__mul__      2/3 * 1/6      1/9  
The double underscore methods make a nice notation possible.  
Instead of f1.add(f2)  we can just write f1+f2 . The negate  Method  
 def negate(self):  
    """""" Returns the negative of self  
    """""" 
    F = Fraction( -self.num,self.den ) 
    return P  
>>> x = Fraction(6, -5) 
>>> print x  
-6/5 
>>> y = x.negate () 
>>> print y  
6/5 The invert  Method  
 def invert(self):  
     """""" Returns the r"
"eciprocal of self  
     PreC: self is not zero  
     """""" 
     F = Fraction( self.den,self.num ) 
     return F  
>>> x = Fraction(100,95)  
>>> print x 
20/19 
>>> y = x.invert () 
>>> print y 
19/20 Consider Addition  
s = ‘dogs’ + ‘and’ + ‘cats’  
 
x = 100 + 200 + 300  
 
y = 1.2 + 3.4 + 5.6  
What “+” signals depends on the operands.  
Python figures it out.  
We say that the “+” operation is overloaded . Let’s Define “+” For Fractions  
def __add__( self,f):      
   N = self.num* f.den + self.den* "
"f.num 
   D = self.den* f.den 
   return Fraction(N,D)  
>>> A = Fraction(2,3)  
>>> B = Fraction(1,4)  
>>> C = A + B  
>>> print C  
11/12 By defining __add__ this  
way we can say  
               A+B  
instead of  
       A.__add __(B)  
Underlying math:  
 
      a/b + c/d = ( ad+bc )/bd Likewise for Multiplication  
def __mul__(self,f): 
 N = self.num* f.num 
 D = self.den* f.den 
 return Fraction(N,D)  
>>> A = Fraction(2,3)  
>>> B = Fraction(1,4)  
>>> C = A*B  
>>> print C  
1/6 By defining __ mul"
"__ this  
way we can say  
               A*B  
instead of  
       A.__mul __(B)  Would Like Some Flexibility  
Sometimes we would like to  add an integer  
 to a fraction:  
 
 
                   2/3 + 5  =  17/3  
 
To make this happen Python needs to know the 
type of the operands, i.e., “who is to the right  
of the “+” and who is to the left of the “+”?  Using the Built -In Boolean -
Valued Function isinstance  
>>> x = 3/2  
>>> isinstance (x,Fraction ) 
False 
>>> y = Fraction(3,2)  
>>> isinstance"
" (y,Fraction ) 
True 
Feed isinstance  it the “mystery” object and a class  
and it will tell you if the object is an instance of the class.  A More Flexible __add__ 
def __add__( self,f): 
  if isinstance (f,Fraction ): 
    N = self.num* f.den + self.den* f.num 
    D = self.den* f.den 
  else: 
    N = self.num + self.den*f  
    D = self.den  
  return Fraction(N,D)  
If f is a Fraction, use (a/b + c/d) = ( ad+bc )/(bd) A More Flexible __add__  
def __add__( self,f): 
  if isinstance (f,Fraction ): 
   "
" N = self.num* f.den + self.den* f.num 
    D = self.den* f.den 
  else: 
    N = self.num + self.den*f  
    D = self.den  
  return Fraction(N,D)  
If f is an integer, use (a/b + f) = ( a+bf)/b A More Flexible __mul__ 
 def __mul__(self,f): 
    if isinstance (f,Fraction ): 
        N = self.num* f.num 
        D = self.den* f.den 
    else: 
        N = self.num*f  
        D = self.den  
    return Fraction(N,D)  
If f is a Fraction, use (a/b)(c/d) = (ac)/( bd) A More Flexible __mul__ 
 def __mul__(self"
",f): 
    if isinstance (f,Fraction ): 
        N = self.num* f.num 
        D = self.den* f.den 
    else: 
        N = self.num*f  
        D = self.den  
    return Fraction(N,D)  
If f is an int, use (a/b)(f) = ( af)/b Be Careful!  
>>> F = Fraction(2,3)  
>>> G = F + 1  
>>> print G  
5/3 
>>> H = 1 + F  
Traceback  (most recent call last):  
  File ""<stdin>"", line 1, in <module>  
TypeError : unsupported operand type(s)  
for +: ' int' and 'instance'  When you add an int to 
a Fraction, the int must 
"
"be on the right side of  
the +  An Example  
n = 15 
s = Fraction(0)  
for k in range(1,n+1):  
    s = s + Fraction(1,k)  
print s Let’s compute 1  +  1/2  +  1/3 + … +  1/15  
1195757/360360  This “+” invokes __add__.  Next, a Class that Supports  
Computations with Dates  If Today is July 4, 1776,  
then What is Tomorrow’s Date?  
>>> D = SimpleDate ('7/4/1776')  
>>> print D  
July 4, 1776  
>>> E = D.Tomorrow () 
>>> print E  
July 5, 1776  The Check is in the Mail  
and will Arrive in 1000 Days  
>>>"
" D = SimpleDate ('1/1/2016')  
>>> A = D+1000  
>>> print A  
September 27, 2018  How Many Days from  
Pearl Harbor to 9/11?  
>>> D1 = SimpleDate ('9/11/2001')  
>>> D2 = SimpleDate ('12/7/1941')  
>>> NumDays = D1-D2 
>>> print NumDays 
21828 Class Variables  
To pull this off, it will be handy to have a  
“class variable” that houses information  
that figures in date -related computations…  
nDays =[0,31,28,31,30,31,30,31,31,30,31,30,31]  The Attributes  
class SimpleDate (object):  
   """""" 
   Attribut"
"es:  
    m: index of month [ int] 
    d: the day [ int] 
  y: the year [ int] 
       m, d, and y identify a  
        valid date.  
   """""" 
  The Leap Year Problem  
def isLeapYear (self): 
    """""" Returns True if and only if  
 self encodes a date that part of   
 a leap year.   
    """""" 
    thisWay = ((y%100>0) and y%4==0)  
    thatWay = ((y%100==0) and (y%400==0))  
    return thisWay or thatWay 
     An integer y is a leap year if it is not  a century  
year and is divisible by 4 or if is a century"
" year  
and is divisible by 400.  Visualizing a SimpleDate  
Object  
>>> D = SimpleDate (‘7/4/1776’)  
  D      7       m 
    4     d  SimpleDate  
  1776     y The SimpleDate  Constructor  
def __init__( self,s): 
     """""" Returns a reference to a SimpleDate  
 representation of the date encoded in s.  
         
    PreC: s is a date string of the form      
 'M/D/Y'where M, D and Y encode the month 
 index, the day, and the year.  
     """""" 
     v = s.split('/') 
     m = int(v[0]),d = int(v[1]),y = i"
"nt(v[2]) 
     self.m = m, self.d = d, self.y  = y 
 
If s = ‘7/4/1776’  then  v = [ ‘7’,‘4’,‘1776’]  The SimpleDate  Constructor  
Note that   
                    D = SimpleDate (‘7/32/1776’)  
 
and 
                    D = SimpleDate (‘2/29/2015’)  
 
produce SimpleDate  objects that encode  
invalid dates.  The SimpleDate  Constructor  
def __init__( self,s): 
     """""" Returns a reference to a SimpleDate  
 representation of the date encoded in s.  
         
    PreC: s is a date string of the form   "
"   
 'M/D/Y'where M, D and Y encode the month 
 index, the day, and the year.  
     """""" 
     v = s.split('/') 
     m = int(v[0]);d = int(v[1]);y = int(v[2]) 
     self.m = m; self.d = d; self.y  = y 
A good place to guard against “bad” input using assert . Use Class Variable nDays 
 
nDays =[0,31,28,31,30,31,30,31,31,30,31,30,31]  
 
 
   v = s.split('/') 
m = int(v[0]);d = int(v[1]);y = int(v[2]) 
assert 1<=m<=12, 'Invalid Month'  
assert 1<=d<= self.nDays [m], 'Invalid  Day'  
 
Needs more work. Does n"
"ot handle leap year situations.   
Nothing wrong with  SimpleDate (‘2/29/2016’)  Some SimpleDate  Methods  
Tomorrow       the next day’s date  
 
__eq__           when are two dates the same?  
 
__add__       ‘7/4/1776’ + 364   is  ‘7/3/1777’  
 
__sub__    ‘3/2/2016’ – ‘2/28/2016’   is   3  Informally…  Visualizing the Overall Class  
class SimpleDate (object):  
 
 
 
 
 
 
 
 
 
 
 
                                 
   def __init__( self,s): 
Methods  Class Variables  
def __str__(self):      
def __eq"
"__(self,other ): 
def isLeapYear (self):  def __sub__( self,other ): def __add__( self,other ) 
def Tomorrow(self):  nDays = [ blah ]  
Constructor  The Method Tomorrow   
>>> D = SimpleDate (‘7/4/1776’)  
>>> T = D.Tomorrow () 
>>> print T 
July 5, 1776    D      7       m 
     4     d  SimpleDate  
  1776     y 
       7       m 
    5     d  SimpleDate  
 y T Pretty printing  
via __ str__ 
  1776    Need a bunch of if constructions to handle  
end-of-month and end -of-year situations  
with possible le"
"ap year issues:  
 
   ‘7/4/1776’   --->  ‘7/5/1776’  
  ‘2/28/1776’  --->  ‘2/29/1776’  
  ‘2/28/1777’  --->  ‘3/1/1777’  
  ‘7/31/1776’  --->  ‘8/1/1776’  
  ‘12/31/1776’ --->  ‘1/1/1777’  The Method Tomorrow   The  __eq__  Method  
 def __eq__(self,other ): 
   """""" Returns True if and only if other  
 encodes the same date as self  
   """""" 
    B1 = self.m == other.m  
    B2 = self.d == other.d  
    B3 = self.y == other.y 
    return B1 and B2 and B3  
>>> D1 = SimpleDate ('7/4/1776')  
>>> D2 = Simple"
"Date ('4/1/1066')  
>>> D1==D2  
False The  __add__   Method  
 def __add__( self,n): 
    """""" Returns a date that is n days  
    later than self.  
    PreC: n is a nonegative  integer.  
    """"""  
    Day = self  
    for k in range(n):  
        Day = Day.Tomorrow () 
    return Day  
>>> D = SimpleDate (‘1/1/2016’)  
>>> E = D + 365  
>>> print E  
December 31, 2016  The  __sub__   Method  
 def __sub__( self,other ): 
    """"“ D2-D1 returns the number of days from          
 D1 to D2. D2 must be the la"
"ter date.  
    """"""  
    k = 0 
    Day = other  
    while not (Day==self):  
        k+=1 
        Day = Day.Tomorrow () 
    return k  
>>> D1 = SimpleDate ('9/11/2001')  
>>> D2 = SimpleDate ('12/7/1941')  
>>> D1-D2 
21828 Referencing a Class Variable  
def Tomorrow(self):  
   m = self.m 
   d = self.d 
   y = self.y 
   Last = self.nDays [m] 
   if isLeapYear (y) and m==2:  
        Last+=1 
            : 
nDays =[0,31,28,31,30,31,30,31,31,30,31,30,31]  More on Copying Objects  
A subtle issue is in"
"volved if you try to copy  
objects that have attributes that are  
objects themselves.  
 
 More on Copying Objects  
 
 
 class MyColor: 
    """""" 
    Attributes:  
        rgb: length -3 float list  
        name: str 
    """""" 
    def __init__( self,rgb,name ): 
        self.rgb = rgb 
        self.name = name  To illustrate consider this class  
 More on Copying Objects  
  
  rgb   ‘red’     name 
       0  0  1 A >>> A = MyColor([1,0,0],’red’)  
   More on Copying Objects  
  
  rgb   ‘red’     name "
"
       0  0  1 A >>> B = copy(A)  
 
  rgb   ‘red’     name 
      B   More on Copying Objects  
  
  rgb   ‘red’     name 
       0  0  1 A >>> B = copy(A)  
 
  rgb   ‘red’     name 
      B Now let’s  
make  
a yellow    More on Copying Objects  
  
  rgb   ‘yellow’    name 
       0  1  1 A >>> A.rgb[1]=1  
>>> A.name = ‘yellow’  
 
  rgb   ‘red’     name 
      B Unintended  
Effect  
 
B.Rgb  refers  
to a yellow  
triple    More on Copying Objects  
  
  rgb   ‘red’     name 
       0  0  1 A >>> B "
"= deepcopy (A) 
 
  rgb   ‘red’     name 
       0  0  1 B deepcopy   
copies  
everything  "
"21. Recursion  
Recursive Tiling  
Recursive Evaluation of n!  
Tracking a Recursive Function Call  
Random Mondrian  
 What is Recursion?   
A function is recursive if it calls itself.  
 
A pattern is recursive if it is defined  
in terms of itself.  
I can tell you what  
this 
is in terms of what  
that 
is. The Concept of Recursion  
Is Hard But VERY Important   
Teaching Plan:  
 
 Develop a recursive triangle -tiling procedure 
 informally.  
 
 Fully implement (in Python) a recursive 
 rectangle -ti"
"ling procedure.  
 
 Fully implement a recursive function for n!  
 
 Fully implement a recursive function for 
 sorting (in a later lecture).  
 
 Recursive Graphics   
 
 
 We will develop a graphics procedure that 
draws this:  
The procedure will call itself.  We are tiling  
a triangle with  
increasingly  
smaller  
triangles.  Tiling a Triangle  
We start  
with one  
big triangle:  
And are to  
end up with  
this: Tiling a Triangle  
Requires Repetition  
Given a  
yellow  
triangle  Define the  
i"
"nner triangle  
and the 3  
corner  
triangles  Color the  
inner triangle  
and repeat the  
process  on the  
3 corner triangles  “Repeat the Process”  
Visit every  
yellow triangle  
and replace it  
with this  
We Get This…  
“Repeat the Process”  
Visit every  
yellow triangle  
and replace it  
with  
We Get This…  
“Repeat the Process”  
Visit every  
yellow triangle  
and replace it  
with  
We Get This…  
Etc. 
The Notion of Level  
A level -0 
    tiling  A level -1 
   tiling  A level -2 
  tili"
"ng  A level -3 
   tiling  The Connection Between Levels  
A level -2 
   tiling  A level -3 
   tiling  
To display a level -3 tiling you do this:  
   - display the inner triangle T0  
   - display a level -2 tiling of corner triangles T1, T2, and T3  T0 
T1 T2 
T3 The Connection Between Levels  
To display an level -L tiling you do this:  
   - display the inner triangle T0  
   - display an level -(L-1) tiling of triangles T1, T2, and T3  T0 
T1 T2 
T3 Some Tools to Pull This Off  
class Point(object): "
" 
  def __init__(self,x,y):  
   self.x = x  
      self.y = y  
   
  def Mid(self,other):  
       """""" Returns a point that encodes  
   the  midpoint of theline segment  
  that connects the Point self and  
   the Point other.  
    """""" Midpoints from Vertices  
P12 = P1.Mid(P2)  
P23 = P2.Mid(P3)  
P31 = P3.Mid(P1)  T0 
T1 T2 
T3 
P1 P3 P2 
P12 P23 
P31 Some Tools to Pull This Off  
 
def DrawTriangle(P1,P2,P3,c):  
     """""" Draws a triangle with vertices  
  P1, P2, and P3 and FillColor c  
     
  Pr"
"eC: P1, P2, and P3 are points  
  and c is a rgb list.  
     """""" 
 Coloring the Inner Triangle  
DrawTriangle(P12,P23,P31,MAGENTA)  T0 
T1 T2 
T3 
P1 P3 P2 
P12 P23 
P31 The Overall Procedure  
def Tile( P1,P2,P3 ,L): 
   if L ==0:  
     # Base case. Draw a yellow triangle  
     DrawTriangle(P1,P2,P3,YELLOW)  
   else: 
     # Compute side midpoints P12,P23,P31  
          
     # Color inner triangle MAGENTA  
      
  # Draw level L -1 tilings of T1,T2,T3  The Overall Procedure  
# Compute side midpoin"
"ts P12,P23,P31  
          
P12 = P1.Mid(P2)  
P23 = P2.Mid(P3)  
P31 = P3.Mid(P1)  The Overall Procedure  
# Color the inner triangle magenta  
          
DrawTriangle(P12,P23,P31,MAGENTA  The Overall Procedure  
# Draw level -(L-1) tilings of T1, T2, T3  
          
Tile(P1,P31,P12,L -1) 
Tile(P2,P12,P23,L -1) 
Tile(P3,P23,P31,L -1) 
These are the recursive calls . The Overall Procedure  
def Tile( P1,P2,P3 ,L): 
   if L ==0:  
     # Base case. Draw a yellow triangle  
     DrawTriangle(P1,P2,P3,YELLOW) "
" 
   else: 
     # Compute side midpoints P12,P23,P31  
     # Color inner triangle MAGENTA  
  # Draw level L -1 tilings of T1,T2,T3  
Tile(P1,P31,P12,L -1) 
Tile(P2,P12,P23,L -1) 
Tile(P3,P23,P31,L -1) A Note on Chopping  
up a Region  
into Triangles…  
 
 It is Important!  
Step One in simulating flow around an airfoil is to 
generate a triangular mesh and (say) estimate the 
velocity at each little triangle using physics and math.  An 
Area  
Of 
 Interest  Next Up  
 
A Non -Graphics Example  
of Recu"
"rsion:  
The Factorial Function  Recursive Evaluation of 
Factorial  
Recall the factorial function:  
def F(n):  
   x = 1 
   for k in range(1,n+1):  
      x = x*k 
   return x  
 5! = 1x2x3x4x5   Recursive Evaluation of 
Factorial  
Q. How would you compute  6!  given that you  
have computed  5! = 120 ?  
 5! = 1x2x3x4x5   A.  6! = 120 x 6  Recursive Evaluation of 
Factorial  
 How does this work?   def F(n):  
   if n<=1:  
      return 1  
   else: 
      a = F(n-1) 
      return n*a  Executing F(3) "
" 
m = 3 
x = F(m)  
print x 
  We are in the calling script    
m –-> 
 
x --> 
  3 
  Executing F(3)  
m = 3 
x = F(m)  
print  def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The function F is called with argument 3. We open up a call frame.    
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  We encounter a function call. F is call"
"ed with argument equal to 2.    
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  We open up a call frame.   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
  
   
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return"
" 1  
  else: 
    a = F(n-1) 
    return n*a  
  We encounter a function call. F is called with argument 1   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
  
   
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  We open up a call frame.   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) "
"
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
  
   
n –-> 
 
a --> 
 
return  
  3 
  
  def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
n –-> 
 
a --> 
 
return  
  1 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The value of 1 is “assigned” to return   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  "
"3 
   
n –-> 
 
a --> 
 
return  
  2 
  
   
n –-> 
 
a --> 
 
return  
  3 
  
  def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
n –-> 
 
a --> 
 
return  
  1 
  
1 Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The value is sent back to the caller.   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
"
"1 
   
n –-> 
 
a --> 
 
return  
  3 
  
  def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
n –-> 
 
a --> 
 
return  
  1 
  
1 Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  That function call is over   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
1 
   
n –-> 
 
a --> 
 
return  
  3 
  
  def F("
"n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
n –-> 
 
a --> 
 
return  
  1 
  
1 Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  Control now passes to this “edition” of F   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
1 
   
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print "
"x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  Control passes to this “edition” of F. The value  2 is “assigned” to return   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
1 
2  
n –-> 
 
a --> 
 
return  
  3 
  
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The value is returned to the caller."
"   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
1 
2  
n –-> 
 
a --> 
 
return  
  3 
2 
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The function call is over   def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
 
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  2 
1 
2  
n –-> 
 
a --> 
 
ret"
"urn  
  3 
2 
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  Control now passes to this “edition” of F    
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  3 
2 
  Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The value 6 is “assigned” to return    
m –-> 
 
x --> 
  3 
   
n –-> 
 
a --> 
 
return  
  3 
2 
6 Executing F(3)  
m = 3 
x = F(m)"
"  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  The value is returned to the caller.    
m –-> 
 
x --> 
  3 
6  
n –-> 
 
a --> 
 
return  
  3 
2 
6 Executing F(3)  
m = 3 
x = F(m)  
print x def F(n):  
  if n<=1:  
    return 1  
  else: 
    a = F(n-1) 
    return n*a  
  This function call is over.    
m –-> 
 
x --> 
  3 
6  
n –-> 
 
a --> 
 
return  
  3 
2 
6 Executing F(3)  
m = 3 
x = F(m)  
print x 
  Control passes to the script that asked for F(3"
")    
m –-> 
 
x --> 
  3 
6 Executing F(3)  
m = 3 
x = F(m)  
print x 
  All Done!    
m –-> 
 
x --> 
  3 
6 
 6  Output : Another Example: Random 
Mondrians  
Using Python:  Random Mondrian  
Given This:  
Random Mondrian  
Draw This:  
The Subdivide Process  
Applies to a Rectangle  
L W 
 Given a rectangle specified by its length, width, and center,  
either randomly  color it or randomly subdivide it.   (x,y) Subdivision Starts with a  
Random Dart Throw  This Defines 4 Smaller 
Rectangles  
 Repeat "
"the process on each of the 4 smaller rectangles…     This Defines 4 Smaller 
Rectangles  
 We can again repeat the process on each  
of the 16 smaller rectangles. Etc.    The Notion of Level  
A 1-level Partitioning        A 2 -level Partitioning  def Mondrian( x,y,L,W,level ): 
   if level ==0:  
     c = RandomColor ()) 
   DrawRect (x,y,L,W,FillColor =c) 
   else: 
  # Subdivide into 4 smaller rectangles  
   Mondrian( upper left rectangle info ,level-1) 
   Mondrian( upper right rectangle info ,level-1)"
" 
   Mondrian( lower left rectangle info ,level-1) 
   Mondrian( lower right rectangle info ,level-1) 
 
   Pseudocode  
We look at a few details. Complete implementation online  How to Generate  
Random Colors  
We need some new technology to organize the 
selection random colors.  
 
We need lists whose entries are lists.  Lists with Entries that Are 
Lists  
An Example:  
cyan     = [0.0,1.0,1.0]  
magenta  = [1.0,0.0,1.0]  
yellow   = [1.0,1.0,0.0]  
colorList = [cyan,magenta,yellow]  
 
 
 Pick a Color"
" at Random  
cyan     = [0.0,1.0,1.0]  
magenta  = [1.0,0.0,1.0]  
yellow   = [1.0,1.0,0.0]  
colorList = [cyan,magenta,yellow]  
r = randi(0,2)  
randomColor = colorList[r]  
 
 
 Package the Idea…  
from simpleGraphics import *  
from random import randint as randi  
 
def RandomColor():  
   “““ Returns a randomly selected  
   rgb list.”””  
   c = [RED,GREEN,BLUE,ORANGE,CYAN]  
   i = randi(0,len(c) -1) 
   return c[i]  How to Randomly Subdivide  
a Rectangle  
xc = randu(x -L/2,x+L/2)  
yc = randu(y -"
"W/2,y+W/2)   
 
 
                                                  
 
 
                                                             (x,y) 
(xc,yc)  
L W The Math Behind the  
Little Rectangles  
The upper right rectangle is typical:  
 
 Length:   L1 = (x+L/2) -xc 
 Width:   W1 = (y+W/2) -yc 
 Center:  (xc+L1/2,yc+W1/2)   
 
 
                                                  
 
 
                                                             (x,y) 
(xc,yc)  
L W The Procedure Mondrian  
A couple of feature"
"s  
to make the design more  
interesting:  
 
(1)The dart throw that  
determines the subdivision  
can’t land too near the edge.  
No super skinny tiles!  
 
(2) Randomly decide  
whether or not to subdivide.  
This creates a nice diversity  
in size.  Overall Conclusions  
Recursion is sometimes the simplest way  
to organize a computation.  
 
It would be next to impossible to do the  
triangle tiling problem any other way.  
 
On the other hand, factorial computation  
is easier via for -loop iteration"
".   Overall Conclusions  
Infinite recursion (like infinite loops) can  
happen so careful reasoning is required.  
 
Will we reach the “base case”?  
 
Graphics examples: We will reach Level==0  
Factorial:                We will reach n==1  
 
 "
"22. Searching a List   
Topics:  
 Linear Search  
 Binary Search  
 Measuring Execution Time  
 The Divide and Conquer Framework  
 
 
 
 Search  
Examples:  
 
 Is this song in that playlist?  
 
 Is this number in that phone book?  
 
 Is this name in that  phone book?  
 
 Is this fingerprint in that archive of  
 fingerprints?  
 
 Is this photo in that yearbook?  
 
  More on Using Phone Books  
The Manhatten  
phone book has  
1,000,000+ entries.  
 
How is it possible  
to locate a name  
by examini"
"ng just a  
tiny , tiny fraction  
of those entries?  
There must be a great  
search algorithm behind  
the scenes.  Linear Search  LinSearch : The Spec  
def LinSearch (x,a): 
    """""" Returns an int k with the 
 property that a[k]==x is True.  
  If no such k exists, then  
    k==-1. 
     
    PreC: a is a nonempty list of 
 ints and x is an int.  
    """""" 
Could also apply the same ideas for searching  a list of strings.  Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   "
"7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 0 
23 k-> 
x-> 
Walk down the list looking for a match  Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 0 
23 k-> 
x-> 
Walk down the list looking for a match  Nope  Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0"
"  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 1 
23 k-> 
x-> 
Walk down the list looking for a match  Nope  Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 2 
23 k-> 
x-> 
Walk down the list looking for a match  Nope  Linear Search  
86 73 35 43"
" 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 3 
23 k-> 
x-> 
Walk down the list looking for a match  Nope  Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 4 
23 k-> 
x-> 
Walk down the list looking for a match  Yup"
" Linear Search  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 4 
23 k-> 
x-> 
Walk down the list looking for a match  All done  Linear Search: No Match Case  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 11 
7 k-> 
x"
"-> 
Walk down the list looking for a match  Nope  Linear Search: No Match Case  
86 73 35 43 23 45 42 15 62 25 51 35 a-> 0  1   2   3   4  5  6   7   8   9  10  11 
def  LinSearch (x,a): 
   for k in range( len(a)): 
       if x == a[k]:  
          return k  
   return -1 7 x-> Yup 
Return -1 if no match  Linear Search: While 
Implementation  
def  LinSearchW (x,a): 
   k=0 
   while k< len(a) and a[k]!=x:  
       k+=1 
   if k==len(a): 
       return -1 
   else: 
   return k  
 Now we assume that the li"
"st  
to be searched is sorted  
from little to big.  Binary Search  
a = [10,20,40,60,90]  
 
a = [‘brown’,’dog’,’fox’,‘lazy’,‘quick’,’the ’]  Back to Using Phone Books  
 
 
The Ithaca  
phone book has  
10,000+ entries.  
 
The Manhatten  
phone book has  
1,000,000+ entries. But it does not  
take 100 x longer to look something up. Why?  
 
 
Key Idea: Repeated Halving  
To find Derek Jeter’s number…  
  
B = phone book  
while (B is longer than 1 page):  
   1. P = middle page of B  
   2. Let Q be the "
"first name on P  
   3. if  ‘Jeter” comes before Q:  
         Rip away the 2nd half of B  
      else: 
         Rip away the 1st half of B.  
 
Scan remaining page P line -by-line for ‘Jeter’  What Happens to Phone Book 
Length?  
Original:     3000 pages  
After 1 rip:  1500 pages  
After 2 rips:  750 pages  
After 3 rips:  375 pages  
After 4 rips:  188 pages  
After 5 rips:   94 pages  
 
After 12 rips:   1 page  Binary Search  
The idea of repeatedly halving the size of 
the “search space” is the main"
" idea behind 
the method of binary search.  
 
An item in a sorted array of length n  
can be located with  approximately log2 n 
comparisons.  
log2 8 = 3      log2 64  = 7      log2 2**k   = k  What is log2(n) ? 
   n                  ceil(log2(n)) 
--------------------------  
     10           4  
    100           7  
   1000          10  
  10000          14  
 100000          17  
1000000          20  BinSearch : The Spec  
def BinSearch (x,a): 
    """""" Returns an int k with the 
 property that a[k]="
"=x is True.  
  If no such k exists, then  
    k==-1. 
     
    PreC: a is a nonempty list of 
 ints that is sorted from smallest  
    to largest. x is an int.  
    """""" Example:  
Does this List have an Element  
With Value Equal to 70?  
12 15 35 33 42 45 51 73 62 75 86 98 0  1   2   3   4  5  6   7   8    9 10  11 Let’s Look For x  in a  
L: 
Mid: 
R: 0 
5 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x ???? 
 
x: 70 Mid = (L+R)/2  The Midpoint Compu"
"tations  
 L       R     (L+R)/2 
------------------------------  
  0      11           5  
  2       6           4  
  1     100          50  
   Let’s Look For x  in a  
L: 
Mid: 
R: 0 
5 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x ???? 
 
x: 70 Let’s Look For x  in a  
L: 
Mid: 
R: 0 
5 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Yes! 
So throw away  
The “left half”  
 x: 70 Let’s Look Fo"
"r x in a  
L: 
Mid: 
R: 0 
5 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Yes! 
So throw away  
The “left half”  
 x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 0 
5 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Revise L and Mid  
 x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 5 
8 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  ???  
 
 
 x: 70 "
"Let’s Look For x  in a  
L: 
Mid: 
R: 5 
8 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
No 
So throw away the  
“right half”   
 
 x: 70 Let’s Look For x = 70 
L: 
Mid: 
R: 5 
8 
11 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Revise R and Mid   
 
 
 x: 70 Let’s Look For x = 70 
L: 
Mid: 
R: 5 
6 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x "
" 
 
Revise R and Mid   
 
 
 x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 5 
6 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x ????  
  
 
 
 x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 5 
6 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Yes 
 
Throw away the  
Left half  
  x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 6 
7 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  1"
"1 
a[Mid] <= x  
 
Yes  
  
 
 
 x: 70 Let’s Look For x in a  
L: 
Mid: 
R: 6 
7 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
a[Mid] <= x  
 
Throw away the  
left half  
  
 
 x: 70 Let’s Look For x in a  
Mid: 
R: 6 
7 
8 12 15 35 33 42 45 51 73 62 75 86 98 a-> 0  1   2   3   4  5  6   7   8    9 10  11 
Done! At this  
point we just  
compare x 
with a[L] and 
a[L+1 ] . 
  
 x: 70 L: L = 0 
R = len(a)-1 
while R-L > 1: 
    # a[L]<=x<=a[R]  
     Mid = (L+R)/2  
"
"     if x <= a[mid]:  
         R = Mid 
     else: 
         L = Mid What We Just Did  
Note that a[L]<=x<=a[R} remains True throughout the loop  A Loop  
Invariant  L = 0 
R = len(a)-1 
while R-L > 1: 
    # a[L]<=x<=a[R]  
     Mid = (L+R)/2  
     if x <= a[mid]:  
         R = Mid 
     else: 
         L = Mid What We Just Did  
What is the situation when the loop terminates?  L = 0 
R = len(a)-1 
while R-L > 1: 
    # a[L]<=x<=a[R]  
     Mid = (L+R)/2  
     if x <= a[mid]:  
         R = Mid 
     e"
"lse: 
         L = Mid What We Just Did  
R-L<=1     implies R = L+1  After the Loop Ends  
a[L] a[L+1] 
This is True:    a[L]<=x<=a[L+1]  After the Loop Ends  
a[L] a[L+1] 
if x==a[L]:  
   return L  
elif x==a[L+1]:  
   return L+1  
else: 
   return -1 Measuring Execution Time  
We now have two ways to search a list:  
 
  LinSearch (x,a) 
  BinSearch (x,a) 
 
Intuition: BinSearch  much faster.  
 
Can we quantify this with a “stop watch”?  The timeit  Module  
This module can be used to time how  
long "
"it takes to execute a chunk of code.  
 
Typical chunk = some function of interest.  
 
This is called benchmarking.  
 Benchmarking  
Let’s benchmark LinSearch (x,a) and  
BinSearch (x,a). 
 
Compare how long it takes when len(a)  equals   
1000, 10000, 100000, and 1000000.  
 
Our intuition tells us that as len(a) increases,  
BinSearch  will be dramatically faster.  BinSearch  vs LinSearch  
    n       tBin     tLin      tLinW 
--------------------------------------       
   1000    0.0007   0.0064    "
"0.0119  
  10000    0.0009   0.0668    0.1203  
 100000    0.0011   0.8296    1.2082  
1000000    0.0015  17.7388   13.9341  
 
 tBin  = time for BinSearch  
tLin  = time for LinSearch  (for loop version)  
tLinW = time for LinSearch  (while-loop version)  BinSearch  vs LinSearch  
    n       tLin/tBin    
-----------------------        
   1000         9             
  10000        74    
 100000       754     
1000000      7095    
 
 
Reporting ratios is more illuminating since we do not really  
care a"
"bout the time units in this informal comparison  Using the timeit  Module  
We show how this module was use to  
get the results on the previous slides.  
 
Our LinSearch  vs BinSearch  example is very  
typical: is one function faster than another?  
 A Benchmarking Framework  
from timeit import *  
Set-up code 
Code to Benchmark  S = “““ 
””” 
B = “““ 
””” 
p = 10; m = 100  
t = min(Timer( B,setup=S).repeat( p,m)) Yes, these are doc  
strings.  The Set -Up and Bench Codes  
 
k=BinSearch (x,s) 
 from ran"
"dom import randint as randi 
from ShowSearch  import BinSearch  
n = 10000  
s = [randi(0,10*n) for i in range(n)]  
s.sort() 
x = s[n/2]  
The set -up code is run once.  
 
It is not timed.  
 
It just sets up the code to 
be timed.  A Benchmarking Framework  
from timeit import *  
Set-up code 
Code to Benchmark  S = “““ 
””” 
B = “““ 
””” 
p = 10; m = 100  
t = min(Timer( B,setup=S).repeat( p,m)) An “experiment”  
consists of running  
the blue code  
m times.  
 
The stopwatch  
will time how long  
it "
"takes to do one  
experiment  
Larger values necessary if the blue code executes very quickly   A Benchmarking Framework  
from timeit import *  
Set-up code 
Code to Benchmark  S = “““ 
””” 
B = “““ 
””” 
p = 10; m = 100  
t = min(Timer( B,setup=S).repeat( p,m)) Timer returns  
a length -p 
list. Each  
element is  
the stopwatch  
time for 1  
experiment  
This helps control for other stuff that may be running on your computer.   A Benchmarking Framework  
from timeit import *  
Set-up code 
Code to Bench"
"mark  S = “““ 
””” 
B = “““ 
””” 
p = 10; m = 100  
t = min(Timer( B,setup=S).repeat( p,m)) In general, it is  
best to take  
the mininum  as 
the most reliable.  
The benchmark  
time is assigned  
to t 
This helps control for other stuff that may be running on your computer.   Why Benchmarking is  
Important  
Confirms/refutes what our intuition might  
say about efficiency.  
 
Makes us sensitive to the various issues  
that affect efficiency.  
 
Steers us away from simplistic comparisons  
of differen"
"t  methods  that can be used  
on the same problem.  "
"24. Sorting a List   
Topics:  
 Selection Sort  
 Merge Sort  
 
 
 Our examples will  
highlight the interplay between  
 functions and  lists   Sorting a List of Numbers  
 50   40   10   80   20   60  x --> 
 10   20   40   50   60   80  x --> Before:  
After:  We Will First Implement the 
Method of Selection Sort  
 50   40   10   80   20   60  x --> At the Start:  
High-Level:  
 
     for k in range( len(x)-1) 
      Swap x[k] with the smallest  
      value in x[k:]  Selection Sort: How It Works  
 "
"50   40   10   80   20   60  x --> Before:  
Swap x[0] with the smallest value in x[0:]  Selection Sort: How It Works  
 50   40   10   80   20   60  x --> Before:  
Swap x[0] with the smallest value in x[0:]  
 10   40   50   80   20   60  x --> After:  Selection Sort: How It Works  
 10   40  50   80   20   60  x --> Before:  
Swap x[1] with the smallest value in x[1:]  Selection Sort: How It Works  
 10   40  50   80   20   60  x --> Before:  
Swap x[1] with the smallest value in x[1:]  
 10   20   50   "
"80   40   60  x --> After:  Selection Sort: How It Works  
Before:  
Swap x[2] with the smallest value in x[2:]   10   20   50   80   40   60  x --> Selection Sort: How It Works  
Before:  
Swap x[2] with the smallest value in x[2:]  
 10   20   40   80   50   60  x --> After:   10   20   50   80   40   60  x --> Selection Sort: How It Works  
Before:  
Swap x[3] with the smallest value in x[3:]   10   20   40   80   50   60  x --> Selection Sort: How It Works  
Before:  
Swap x[3] with the smallest value i"
"n x[3:]  
 10   20   40   50   80   60  x --> After:   10   20   40   80   50   60  x --> Selection Sort: How It Works  
Before:  
Swap x[4] with the smallest value in x[4:]   10   20   40   50   80   60  x --> Selection Sort: How It Works  
Before:  
Swap x[4] with the smallest value in x[4:]  
 10   20   40   50   60   80  x --> After:   10   20   40   50   80   60  x --> Selection Sort: Recap  
 50   40   10   80   20   60  
 10   40   50   80   20   60  
 10   20   50   80   40   60  
 10   20   40   80"
"   50   60  
 10   20   40   50   80   60  
 10   20   40   50   60   80  
 10   20   40   50   60   80  The Essential Helper Function:  
Select( x,i) 
def Select( x,i): 
    """""" Swaps the smallest value in 
 x[i:] with x[ i] 
     
    PreC: x is a list of integers  and 
 i is an in that satisfies 
 0<=i<len(x)"""""" 
  Does not return anything and it has a list argument   How Does it Work?  
The calling program has a list. E.g.,  
 0 --->  50 
 1 --->  40 
 2 --->  10 
 3 --->  80 
 4 --->  20 
 5 --->  60  "
" a --> 
  
 
           
 
 
 
 
 
 
 
                                                   How Does it Work?  
The calling program executes  Select(a,0)  
and control passes to Select 
 0 --->  50 
 1 --->  40 
 2 --->  10 
 3 --->  80 
 4 --->  20 
 5 --->  60   a --> 
  
 
           
 
 
 
 
 
 
 
                                                   How Does Select Work?  
- Nothing new about the assignment of 0 to i. 
- But there is no assignment of the list a to x.  
- Instead x now refers  to the same li"
"st as a.  
 0 --->  50 
 1 --->  40 
 2 --->  10 
 3 --->  80 
 4 --->  20 
 5 --->  60   a --> 
  
 
           
 
 
 
 
 
 
 
                                                    
 
           
 
 
 
 
 
 
 
                                                   x --------------------- > 
 
i --->        0  How Does Select Work?  
If inside Select we have  
       t = x[0]; x[0] = x[2]; x[2] = t  
it is as if we said  
     t = a[0]; a[0] = a[2]; a[2] = t  
 0 --->  50 
 1 --->  40 
 2 --->  10 
 3 --->  80 
 "
"4 --->  20 
 5 --->  60   a --> 
  
 
           
 
 
 
 
 
 
 
                                                    
 
           
 
 
 
 
 
 
 
                                                   x --------------------- > 
 
i --->        0   
 
           
 
 
 
 
 
 
 
                                                   How Does Select Work?  
It changes the list a in the calling program.  
We say x and a are aliased. They refer  
to the same list  
 0 --->  10 
 1 --->  40 
 2 --->  50 
 3 --->  80 
 4 --"
"->  20 
 5 --->  60   a --> 
  
 
           
 
 
 
 
 
 
 
                                                   x --------------------- > 
 
i --->        0  Let’s Assume This Is 
Implemented  
def Select( x,i): 
    """""" Swaps the smallest value in 
 x[i:] with x[ i] 
     
    PreC: x is a list of integers  and 
 i is an in that satisfies 
 0<=i<len(x)""""""  50   40   10   80   20   60  
 10   40   50   80   20   60  
 10   20   50   80   40   60  
 10   20   40   80   50   60  
 10   20   40   50   80   60  "
"
 10   20   40   50   60   80  
 10   20   40   50   60   80  The list a looks like this  After this:  
Initialization  
Select(a,0)  
Select(a,4)  
Select(a,5)  Select(a,3)  Select(a,1)  
Select(a,2)  def SelectionSort (a): 
    n = len(a) 
    for k in range(n):  
        Select(a,k) In General We Have This  Next Problem  
Merging Two Sorted Lists  
into a  
Single Sorted List  Example  
12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 75 65 x->  
y->  
z->  x and y are input  
They are sorted  
 
z is t"
"he output  12 33 45 35 
15 42 65 55 75 x->  0 
0 ix: 
iy: Merging Two Sorted Lists  
z-> []  y->  ix and iy  
keep track  
of where  
we are in x  
and y  12 33 45 35 
15 42 65 55 75 x->  0 
0 ix: 
iy: Merging Two Sorted Lists  
z-> []  y->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 65 55 75 
12 0 
0 ix: 
iy: Merge  
Yes. So update ix   x->  
y->  
z->  12 33 45 35 
15 42 65 55 75 
12 1 
0 ix: 
iy: Merge  
x->  
y->  
z->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 6"
"5 55 75 
12 15 1 
0 ix: 
iy: 
iz: Merge  
x->  
y->  
z->  
No. So update iy   12 33 45 35 
15 42 65 55 75 
12 15 1 
1 ix: 
iy: Merge  
y->  x->  
z->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 65 55 75 
12 15 33 1 
1 ix: 
iy: Merge  
y->  x->  
z->  
Yes. So update ix   12 33 45 35 
15 42 65 55 75 
12 15 33 2 
1 ix: 
iy: Merge  
y->  x->  
z->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 65 55 75 
12 15 35 33 2 
1 ix: 
iy: Merge  
y->  x->  
z->  
Yes. So update ix  "
" 12 33 45 35 
15 42 65 55 75 
12 15 35 33 3 
1 ix: 
iy: Merge  
y->  x->  
z->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 3 
1 ix: 
iy: Merge  
x->  
y->  
z->  
No. So update iy…   12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 3 
2 ix: 
iy: Merge  
x->  
z->  y->  
x[ix] <= y[iy]   ???  Do we pick from x ?  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 3 
2 ix: 
iy: Merge  
x->  
y->  
z->  
Yes. So update ix.   12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 4 
"
"2 ix: 
iy: Merge  
x->  
y->  
z->  
    Done with x. Pick from y  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 4 
2 ix: 
iy: Merge  
x->  
y->  
z->  
So update iy   12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 4 
3 ix: 
iy: Merge  
x->  
y->  
z->  
    Done with x. Pick from y  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 65 4 
3 ix: 
iy: Merge  
x->  
y->  
z->  
So update iy.   12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 65 4 
4 ix: 
iy: Merge  
x->  
y->  
z->  
    Done with x. P"
"ick from y  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 75 65 4 
4 ix: 
iy: Merge  
x->  
y->  
z->  
Update iy  12 33 45 35 
15 42 65 55 75 
12 15 35 33 42 45 55 75 65 4 
5 ix: 
iy: Merge  
x->  
y->  
z->  
       All Done  The Python Implementation…  def Merge(x,y):  
   n = len(x); m = len(y);  
   ix = 0; iy = 0; z = []  
   for iz in range(n+m):  
       if   ix>=n:  
           z.append(y[iy]);  iy+=1  
       elif iy>=m: 
           z.append(x[ix]);  ix+=1  
       elif x[ix] <= y[iy]:  
     "
"      z.append(x[ix]);  ix+=1  
       elif x[ix] > y[iy] : 
           z.append(y[iy]);  iy+=1  
   return z  
  
 
x-list exhausted  y-list exhausted  x-value smaller y-value smaller  Build z up  
via repeated  
appending  def Merge(x,y):  
   n = len(x); m = len(y);  
   ix = 0; iy = 0; z = []  
   for iz in range(n+m):  
       if   ix>=n:  
           z.append(y[iy]);  iy+=1  
       elif iy>=m: 
           z.append(x[ix]);  ix+=1  
       elif x[ix] <= y[iy]:  
           z.append(x[ix]);  ix+=1  
   "
"    elif x[ix] > y[iy] : 
           z.append(y[iy]);  iy+=1  
   return z  
  
 
x-list exhausted  y-list exhausted  x-value smaller y-value smaller  len(x)+len(y)  
is the total length  
of the merged list  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 and len(v)>0 :  
        if u[0]<= v[0]:  
            g = u.pop(0)  
        else: 
            g = v.pop(0)  
        z.append(g)  
    z.extend(u)  
    z.extend(v)  
    return z  Implementation Using Pop  
Make co"
"pies of the  
Incoming lists  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 and len(v)>0 :  
        if u[0]<= v[0]:  
            g = u.pop(0)  
        else: 
            g = v.pop(0)  
        z.append(g)  
    z.extend(u)  
    z.extend(v)  
    return z  Implementation Using Pop  
Build z up via  
repeated appending  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 and len(v)>0 : 
        if u[0]<= v[0]:  
            g = u.pop("
"0)  
        else: 
            g = v.pop(0)  
        z.append(g)  
    z.extend(u)  
    z.extend(v)  
    return z  Implementation Using Pop  
Every “pop” reduces the  
length by 1. The loop shuts  
down when one of u or v is  
exhausted  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 and len(v)>0 :  
        if u[0]<= v[0]:  
            g = u.pop(0)  
        else: 
            g = v.pop(0)  
        z.append( g) 
    z.extend(u)  
    z.extend(v)  
    return z  I"
"mplementation Using Pop  
g gets the popped value  
and it is appended to z  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 and len(v)>0 :  
        if u[0]<= v[0]:  
            g = u.pop(0)  
        else: 
            g = v.pop(0)  
        z.append(g)  
    z.extend(u)  
    z.extend(v)  
    return z  Implementation Using Pop  
Add what is left in u.  
OK if u is the empty list  def Merge(x,y):  
    u = list(x)  
    v = list(y)  
    z = [] 
    while len(u)>0 an"
"d len(v)>0 :  
        if u[0]<= v[0]:  
            g = u.pop(0)  
        else: 
            g = v.pop(0)  
        z.append(g)  
    z.extend(u)  
    z.extend(v)  
    return z  Implementation Using Pop  
Add what is left in v.  
OK if v is the empty list  MergeSort  
Binary Search is an example of a “divide  
and conquer” approach top probkem  solving.  
 
A method for sorting a list that features  
this  strategy is MergeSort  Motivation  
You are asked to sort a list but you  have  
two “helpers”:  H"
"1 and H2.  
 
Idea:   
 
 1. Split the list in half and have each 
helper sort one of the halves.  
 
 2. Then merge the two sorted lists into  
 a single larger list.  
This idea can be repeated if H1 has two helpers  
and H2 has two helpers.   Subdivide the Sorting Task  
J N R C P D F L A Q B K M G H E 
A Q B K M G H E J N R C P D F L Subdivide Again  
A Q B K M G H E J N R C P D F L 
M G H E A Q B K P D F L J N R C  And Again  
M G H E A Q B K P D F L J N R C 
M G H E A Q B K P D F L J N R C  And One La"
"st Time  
J N R C P D F L A Q B K M G H E  Now Merge  
G M E H A Q B K D P F L J N C R 
J N R C P D F L A Q B K M G H E  And Merge Again  
H M E G K Q A B L P D F N R C J 
G M E H A Q B K D P F L J N C R  And Again  
M Q H K E G A B P R L N F J C D 
H M E G K Q A B L P D F N R C J  And One Last Time  
M Q H K E G A B P R L N F J C D E F C D A B J K G H N P L M Q R  Done!  
E F C D A B J K G H N P L M Q R  Done!  
E F C D A B J K G H N P L M Q R 
Let’s write a function to do this making use of  
def Merge( x"
",y): 
   """""" Returns a float list that is the 
 merge of sorted lists x and y.  
     
     PreC: x and y are lists of floats 
 that are sorted from small to big.  
     """"""  8 Merges Producing length -2 lists  
G M E H A Q B K D P F L J N C R 
J N R C P D F L A Q B K M G H E Handcoding  the n =16 case  
A0 = Merge(a[0],a[1])  
A1 = Merge(a[2],a[3])  
A2 = Merge(a[4],a[5])  
A3 = Merge(a[6],a[7])  
A4 = Merge(a[8],a[9])  
A5 = Merge(a[10],a[11])  
A6 = Merge(a[12],a[13])  
A7 = Merge(a[14],a[15])   4 Merges"
" Producing Length -4 lists  
H M E G K Q A B L P D F N R C J 
G M E H A Q B K D P F L J N C R Handcoding  the n =16 case  
B0 = Merge(A0,A1)  
B1 = Merge(A2,A3)  
B2 = Merge(A4,A5)  
B3 = Merge(A6,A7)   2 Merges Producing Length -8 Lists  
M Q H K E G A B P R L N F J C D 
H M E G K Q A B L P D F N R C J Handcoding  the n =16 case  
C0 = Merge(B0,B1)  
C1 = Merge(B2,B3)    1 Merge Producing a Length -16 List  
M Q H K E G A B P R L N F J C D E F C D A B J K G H N P L M Q R All Done!  
D0 = Merge(C0,C1)  
For"
" general n, it can be handled using recursion.  def MergeSort (a): 
     n = length(a)  
     if n==1:  
         return a  
     else: 
         m  = n/2  
       u0 = list(a[:m])  
   u1 = list(a[m :]) 
       y0 = MergeSort (u0) 
        y1 = MergeSort (u1) 
       return Merge(y0,y1)  
 
 Recursive Merge Sort  
A function  
can call  
Itself!  Back To Merge Sort  def MergeSort (a): 
     n = length(a)  
     if n==1:  
         return a  
     else: 
         m  = n/2  
       u0 = list(a[:m])  
   u1 ="
" list(a[m :]) 
       y0 = MergeSort (u0) 
        y1 = MergeSort (u1) 
       return Merge(y0,y1)  
 
 Recursive Merge Sort  
A function  
can call  
Itself!  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  "
"7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A S"
"orted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”"
"   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in whi"
"ch  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schemati"
"c  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 1"
"2:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12 "
" 12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  A Sorted List is produced at each “:”   Let’s look at  the order in which  
lists are sorted.  A Schematic  
4:8 0:8 8:16 
0:4 0:16 
8:12 12:16  
0:2 2:4 4:6 6:8 8:10 10:12  12:14  14:16  
0 1  2 3   4 5  6  7  8  9 10  11 12 13 14 15  
  All Done!   Some Conclusions  
Infinite recursion (like infinite loops) can  
happen so careful reasoning is required.  
 
Will we reach the “base case”?  
 
In MergeSort , a recursive call always  
involves"
" a list that is shorter than the input  
list. So eventually we reach the len(a)==1  
base case.   
 "
"25. Inheritance and Related 
OOP* Ideas  
Topics:  
    The classes Card , Deck  and Hand 
 Subclasses  
 Inheritance  
 Method Overriding  
*OOP = Object Oriented Programming  Will Cover These Topics  
With a Single Example  
It will involve operations with playing cards.  
 
 
Closely follows Chapter 18 in Think Python  We Are Going to Define  
Three Classes  
class Card:  
 “““ Represents a single playing card. ””” 
 
class Deck:  
 “““ Represents a deck of cards”””  
 
class Hand:  
 “““ Represents a ha"
"nd of cards”””  
 
 
 
 Decks and Hands  
Things to do with a deck of cards:  
  1. Shuffle     2. Sort*   
  3. Add a card   4. Remove a card  
 
 
Things to do with a hand of cards:  
  1. Compare      2. Sort*   
  3. Add a card   4. Remove a card  
 
 *Maybe sort in different ways  Representing a Card  
A card has a suit and a rank.  
 
There are 4 possible suits.  
 
There are 13 possible ranks.  
 
Anticipate a class with two attributes  
 Representing a Card  
['Clubs','Diamonds','Hearts','Spades '] "
"
     
['Ace','Two','Three ', 'Four','Five','Six ', 
    'Seven','Eight','Nine’,'Ten ', 
           'Jack', ' Queen','King '] 
 A card has a suit and a rank.  
There are 4 possible suits.  
There are 13 possible ranks  
 The Class Card 
class Card:  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def __cmp__(self,other ): 
 The Class Card 
class Card:  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
"
" 
     def __cmp__(self,other ): 
 Class Variable  
Class Variable  
Constructor  
For pretty printing  
For comparing one  
card to another  Class Variables  
suit_names  = ['Clubs', 'Diamonds',  
              'Hearts','Spades ’   ] 
    
rank_names  = [None,  'Ace', 'Two', 'Three',  
         'Four', ' Five','Six ', 'Seven',  
      'Eight','Nine’,'Ten ', 'Jack',  
             'Queen','King '] 
 Class Variables  
suit_names  = ['Clubs', 'Diamonds',  
              'Hearts','Spades ’   ] 
    
rank_names"
"  = [None,  'Ace', 'Two', 'Three',  
         'Four', ' Five','Six ', 'Seven',  
      'Eight','Nine’,'Ten ', 'Jack',  
             'Queen','King '] 
 
Putting  None  in the 0th entry makes for more intuitive  
subscripting :  rank_names [7]  is  ‘Seven ’ Suits are “Indexed”  
suit_names  = ['Clubs', 'Diamonds',  
              'Hearts','Spades ’   ] 
    
0      Clubs  
1      Diamonds  
2      Hearts  
3      Spades  
An ordering:   Clubs  <  Diamonds  <  Hearts  <  Spades  Class Variables  
suit"
"_names  = ['Clubs', 'Diamonds',  
              'Hearts','Spades ’   ] 
    
rank_names  = [None,  'Ace', 'Two', 'Three',  
         'Four', ' Five','Six ', 'Seven',  
      'Eight','Nine’,'Ten ', 'Jack',  
             'Queen','King '] 
 The Class Card 
class Card(object):  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def __cmp__(self,other ): 
 Constructor  
Let’s look at the constructor…  The Constructor:  Basic Idea  
def __init__( self,suit,r"
"ank ): 
  """""" suit and rank are ints """""" 
  self.suit  = suit 
  self.rank  = rank 
c = Card(2,8)  
 
Says: 
 Create a card object that represents  
 the eight -of-hearts  The Constructor With  
a Convenient no -Argument Option  
We’d like  
    c = Card()   
to generate a random Card.  
def __init__( self,suit =None,rank =None): 
    if suit==None and rank==None:  
       self.suit  = randi(0,3)   # random suit  
       self.rank  = randi(1,13)  # random rank  
    else: 
        self.suit  = suit 
       "
" self.rank  = rank 
Using the Optional Argument Idea  The Class Card 
class Card(object):  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def __cmp__(self,other ): 
 For pretty printing  
Let’s look at the __str__ method…  def __str__(self)  
A special method that “pretty prints” a card  
when we use  print 
 
>>> c = Card(2,13)  
>>> print c  
  King of Hearts  
 def __str__(self)  
suit_names  = ['Clubs', 'Diamonds',  
                     'Hearts"
"','Spades ’   ] 
def __str__(self):  
    i = self.suit    # suit index  
    theSuit = self.suit_names [i] 
    j = self.rank    # rank index  
   theRank = self.rank_names [j] 
  return theRank + ‘ ‘ + theSuit 
 
Shows how to access class variables  The Class Card 
class Card(object):  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def __cmp__(self,other ): 
 For comparing one  
card to another  
Let’s look at the __cmp__ method…  Comparing Cards "
" 
What we’d like to do:  
 
>>> C1 = Card(2,13)  # King of Hearts  
>>> C2 = Card(0,5)   # Five of Clubs  
>>> C1 > C2  
True 
 
The __cmp__ method makes this possible  Comparing Cards  
What we’d like to do if L is a list of references  
to Card objects:  
 
 
The __cmp__ method makes this possible  L.sort() 
for c in L:  
    print c Sorting requires comparisons  
between the things that are  
being sorted  How Do We Compare  2 Cards?  
First compare their suits:  
 
  Spades   >  Hearts   >  Diamonds   >"
"  Clubs  
If there is a tie, then compare their ranks:  
 
             K  >  Q  >  J  >  10  > … >   2  >  Ace How It Works  
def __cmp__(self,other ): 
     if self.suit  > other.suit : 
            return 1  
     if self.suit  < other.suit : 
            return -1 
     if self.rank  > other.rank : 
            return 1  
     if self.rank  < other.rank : 
            return -1 
     return 0  
Returning +1 means that the Card self  is greater than  
the Card other. How It Works  
def __cmp__(self,other"
" ): 
     if self.suit  > other.suit : 
            return 1  
     if self.suit  < other.suit : 
            return -1 
     if self.rank  > other.rank : 
            return 1  
     if self.rank  < other.rank : 
            return -1 
     return 0  
Returning -1 means that the Card self  is less than  
the Card other. How It Works  
def __cmp__(self,other ): 
     if self.suit  > other.suit : 
            return 1  
     if self.suit  < other.suit : 
            return -1 
     if self.rank  > other.rank"
" : 
            return 1  
     if self.rank  < other.rank : 
            return -1 
     return 0  
Returning  0 means that the Card self  is the same as  
the Card other. Example  
for k in range(7):  
    YourCard  = Card()  
    MyCard   = Card()  
    if YourCard  > MyCard: 
        Winner = 'You'  
    elif MyCard > YourCard : 
        Winner = 'Me'  
    else: 
        Winner =  'Tie‘  
 
    print YourCard , MyCard, Winner  Two random cards  
Yours is “higher”  
Mine is “higher”  
If we get here, th"
"e two 
cards are the same.       Your Card              My Card         Winner  
----------------------------------------------------  
     Six of Hearts        Six of Spades        Me  
   Eight of Spades      Queen of Hearts        You  
    Five of Diamonds    Queen of Clubs         You  
   Queen of Clubs       Eight of Diamonds      Me  
     Two of Clubs        Five of Spades        Me  
     Six of Clubs        Four of Spades        Me  
    Nine of Clubs       Seven of Spades        Me  Sample Outp"
"ut  This Completes the Discussion  
of the  Class Card 
class Card(object):  
   suit_names  = 
  rank_names  = 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def __cmp__(self,other ): 
 Next Up : The  Class Deck 
class Deck(object):  
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def pop_card (self):     
 
  def add_card (self,card ): 
 
  def shuffle(self):  
 
  def sort(self):  
 Constructor  
Pretty Print  
Sort the Deck  Shuffle the Deck  Add a card to "
"the deck  Remove a card from the deck  The Attributes  
DeckOfCards : list of Card objects  
          n: int 
         
n is the number of cards in the  
deck. 
         
The ""top"" of the deck is  
         self.DeckOfCards [0] 
 
The ""bottom"" of the deck is  
         self.DeckOfCards [self.n] The Constructor  
def __init__(self):  
  self.n = 52 
     self.DeckOfCards  = [] 
     for suit in range(4):  
         for rank  in range(1,14):  
           card = Card( suit,rank ) 
           self.DeckOfCards."
"append (card) 
 It will build a length -52 list of cards:  The Constructor  
def __init__(self):  
  self.n = 52 
     self.DeckOfCards  = [] 
     for suit in range(4):  
        for rank  in range(1,14):  
           card = Card( suit,rank )    
      self.DeckOfCards.append (card) 
Nested loops are used to cover all possible  
suits and ranks.  The Constructor  
def __init__(self):  
  self.n = 52 
     self.DeckOfCards  = [] 
      for suit in range(4):  
         for rank  in range(1,14):  
           "
"  card = Card( suit,rank ) 
             self.DeckOfCards .append(card) 
The list is built via repeated appending  The Constructor  
def __init__(self):  
  self.n = 52 
     self.DeckOfCards  = [] 
     for suit in range(4):  
         for rank  in range(1,14):  
           card = Card(suit,rank ) 
           self.DeckOfCards.append (card) 
Reminder: one constructor can call another constructor.  Create and Print a Deck   
D = Deck()  
print D     Ace of Clubs  
    Two of Clubs  
  Three of Clubs  
   Fou"
"r of Clubs  
   Five of Clubs  
    Six of Clubs  
  Seven of Clubs  
  Eight of Clubs  
   Nine of Clubs  
    Ten of Clubs  
   Jack of Clubs  
  Queen of Clubs  
   King of Clubs  
    Ace of Diamonds  
    Two of Diamonds  
 
       etc The __ str__ method  
is invoked and produces  
52 lines of output ---------------- > def shuffleDeck (self): 
   shuffle( self.DeckOfCards ) Randomly Shuffle a Card Deck  
Makes use of the list method shuffle . The list function shuffle 
This function can be applied to "
"any list. A random permutation.  
 NOT  THE PERFECT SHUFFLE  >>> a = [1,2,3,4,5,6,7,8,9,10]  
>>> shuffle(a)  
>>> a 
[10, 1, 3, 9, 2, 5, 7, 4, 8, 6]  
>>> shuffle(a)  
>>> a 
[4, 9, 1, 3, 7, 10, 5, 6, 8, 2]  Create, Shuffle, and Print a Deck   
D = Deck()  
D.shuffle () 
print D     Jack of Spades  
    Four of Hearts  
   Seven of Diamonds  
   Three of Spades  
   Eight of Diamonds  
   Seven of Clubs  
     Ace of Hearts  
     Six of Spades  
     Ace of Diamonds  
    Five of Diamonds  
   Eight of Cl"
"ubs  
   Eight of Hearts  
   Queen of Diamonds  
     Six of Diamonds  
     Six of Hearts  
 
         etc Remove a Card  
def pop_card (self,Where ): 
     return self.cards.pop () 
>>> x = [10,20,30,40]  
>>> x.pop(2)  
30 
>>> x 
[10, 20, 40]  Recall how to pop an entry in a list:  Remove a Card  
def pop_card (self,Where ): 
  if Where=='Top':  
            c = self.DeckOfCards.pop (0) 
    elif Where==' Bot': 
            c = self.DeckOfCards.pop () 
     elif Where==None:  
            k = randi(0,s"
"elf.n -1) 
            c = self.DeckOfCards.pop (k) 
     self.n -= 1 
     return c  
Three alternatives. The selected card can come off the top or  
bottom of the deck or it can be selected randomly.  Add a Card to a Deck  
def add_card (self,card ): 
      self.DeckOfCards .append(card) 
self.DeckOfCcards    is a list of cards  Sort a Deck  
def sort(self):  
   self.DeckOfCards.sort () 
This is possible because we defined a  
    
  __cmp__  
 
method in the Card class.  
 An Example    
D = Deck()  
D."
"shuffle () 
for k in range(5):  
    c = D.pop_card ('Top') 
    print c 
    D.add_card (c) 
 
 
 
 Create and shuffle a deck. Then repeatedly select a  
card off the top of the Deck, display it, and put it  
back in the deck at the bottom.  This Completes the Discussion  
of  the Deck Class 
class Deck(object):  
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
     def pop_card (self):     
 
  def add_card (self,card ): 
 
  def shuffle(self):  
 
  def sort(self):  
 Next Up: The  Hand "
"Class 
class Hand(Deck):  
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
  def sort(self):  
 The  Hand Class 
class Hand( Deck): 
     def __init__( self,suit,rank ): 
 
  def __str__(self):  
 
  def sort(self):  
 
The Hand Class inherits  all the methods from the Deck class.  
 
What Does this Mean?  Usually we would write Hand(object)  The  Hand Class 
class Hand( Deck): 
     def __init__( self,suit,rank ): 
 
    def __str__(self):  
 
  def sort(self):  
 
Hand  Class methods over"
"ride  the methods from the  
Deck  class that have the same name. The Deck  class  
also has methods called __str__ and sort . 
What does “overriding” mean?  For pretty printing  Constructor  
For sorting the  
cards in a hand  Create a Deck. Shuffle It.  
Extract 10 Cards. Make a Hand. 
Print it.  
D = Deck()  
D.shuffle () 
H = Hand(‘CVL’)  
for k in range(10):  
  c = D.pop_card () 
     H.add_card (c) 
print H CVL: 
      Ace of Hearts  
    Three of Clubs  
     Four of Spades  
     Four of Diamonds  "
"
     Five of Hearts  
      Six of Hearts  
    Seven of Spades  
    Eight of Spades  
    Queen of Clubs  
    Queen of Spades  Create a Deck. Shuffle It.  
Extract 10 Cards. Make a Hand. 
Print it.  
D = Deck()  
D.shuffle () 
H = Hand(‘CVL’)  
for k in range(10):  
  c = D.pop_card () 
     H.add_card (c) 
print H CVL: 
    Queen of Clubs  
    Three of Clubs  
    Eight of Spades  
      Six of Hearts  
    Queen of Spades  
      Ace of Hearts  
     Five of Hearts  
     Four of Spades  
    Seven o"
"f Spades  
     Four of Diamonds  The add_card  method  is inherited  
from the Deck class  Create a Deck. Shuffle It.  
Extract 10 Cards. Make a Hand. 
Print it.  
D = Deck()  
D.shuffle () 
H = Hand(‘CVL’)  
for k in range(10):  
  C = D.pop_card () 
     H.add_card (C) 
print H CVL: 
    Queen of Clubs  
    Three of Clubs  
    Eight of Spades  
      Six of Hearts  
    Queen of Spades  
      Ace of Hearts  
     Five of Hearts  
     Four of Spades  
    Seven of Spades  
     Four of Diamonds  The p"
"rint function from the Hand  
class overrides the print function  
from the Deck Class  Inheritance Chit Chat  
 
The existing class Deck  is the parent  
 
The new class Hand  is the child  
 
Hand  is a subclass  of Deck 
 
Inheritance is a very important mechanism when  
it comes to maintaining and updating software.  Decks and Hands  
Things to do with a deck of cards:  
  1. Shuffle     2. Sort*   
  3. Add a card   4. Remove a card  
 
 
Things to do with a hand of cards:  
  1. Compare      2. Sort* "
"  
  3. Add a card   4. Remove a card  
 
 *Maybe sort in different ways  Another Example of Overriding  
As written, when a Deck is sorted, it is sorted  
by suit first and then  by rank.  
 
To be different, when a Hand is sorted, let’s  
sort by rank first and then by suit.  
 
 Seven of Clubs  
  Ten of Diamonds  
  Six of Hearts  
Eight of Hearts  
  Ace of Spades  
     Ace of Spades           
  Six of Hearts  
Seven of Clubs  
Eight of Hearts  
  Ten of Diamonds  
   vs The sort Method in the  
Hand"
" Class  
def sort(self):  
      self.cards.sort (MyCompare ) 
def MyCompare (H1,H2):  
    if H1.rank > H2.rank:  
        return 1  
    if H1.rank < H2.rank:  
        return -1 
    if H1.suit > H2.suit:  
        return 1  
    if H1.suit < H2.suit:  
        return -1 
    return 0  Sorts by  
rank first,  
then suit.  
This sort  
Method  
overrides  
the sort method  
in Deck, which  
sorts by  
suit first,  
then rank.     Three of Hearts  
    Four of Spades  
   Seven of Diamonds  
    Five of Sp"
"ades  
   Queen of Diamonds  
    Four of Hearts  
     Ten of Diamonds  
   Queen of Hearts  
     Two of Spades  
     Ace of Clubs               Ace of Clubs  
  Seven of Diamonds  
    Ten of Diamonds  
  Queen of Diamonds  
  Three of Hearts  
   Four of Hearts  
  Queen of Hearts  
    Two of Spades  
   Four of Spades  
   Five of Spades      A random  
10-card deck D      D.sort() 
    Sorts by suit first, then rank . Since D is a Deck  object, Python invokes the  
sort  method defined in the Deck  "
"class.    Three of Hearts  
    Four of Spades  
   Seven of Diamonds  
    Five of Spades  
   Queen of Diamonds  
    Four of Hearts  
     Ten of Diamonds  
   Queen of Hearts  
     Two of Spades  
     Ace of Clubs        Ace of Clubs  
      Two of Spades  
    Three of Hearts  
     Four of Hearts  
     Four of Spades  
     Five of Spades  
    Seven of Diamonds  
      Ten of Diamonds  
    Queen of Diamonds  
    Queen of Hearts      A random  
10-card Hand   H     H.sort() 
    Sorts by rank fir"
"st, then suit . Since H is a Hand  object, Python invokes the  
sort  method defined in the Hand  class. A Couple of Examples  
 
 
 Dealing 4 Bridge Hands  
D = Deck(); D.shuffle () 
L = [] 
for k in range(4):  
   L.append (Hand(str(k)) 
for k in range(52):  
   L[k%4].add_card (D.pop_card ()) 
for k in range(4):  
   print L[k].sort()  
 
 
 Set up and shuffle the deck  Dealing 4 Bridge Hands  
D = Deck(); D.shuffle () 
L = [] 
for k in range(4):  
   L.append (Hand(str(k)) 
for k in range(52):  
   L[k%"
"4].add_card (D.pop_card ()) 
for k in range(4):  
   print L[k].sort()  
 
 
 Set Up a length -4 list of Hands  Dealing 4 Bridge Hands  
D = Deck(); D.shuffle () 
L = [] 
for k in range(4):  
   L.append (Hand(str(k)) 
for k in range(52):  
   L[k%4].add_card ( D.pop_card () ) 
for k in range(4):  
   print L[k].sort()  
 
 
 Get a card from the Deck  Dealing 4 Bridge Hands  
D = Deck(); D.shuffle () 
L = [] 
for k in range(4):  
   L.append (Hand(str(k)) 
for k in range(52):  
   L[k%4].add_card (D.pop_car"
"d ()) 
for k in range(4):  
   print L[k].sort()  
 
 
 Add to every 4th hand Dealing 4 Bridge Hands  
D = Deck(); D.shuffle () 
L = [] 
for k in range(4):  
   L.append (Hand(str(k)) 
for k in range(52):  
   L[k%4].add_card (D.pop_card ()) 
for k in range(4):  
   print L[k].sort()  
 
 
 Sort and print each Hand  Next Example from Poker  Probability of a Full House  
Core Problem: When does a 5 -card hand consist  
of two of one rank and three of another?  
    Seven of Spades  
    Seven of Diamonds  
 "
"     Ten of Clubs  
      Ten of Spades  
      Ten of Diamonds   Four of Spades  
 Four of Diamonds  
 Jack of Hearts  
 Jack of Clubs  
 Jack of Spades  Is a Hand H a Full House?  
H.sort() 
r = [] 
for c in H.cards: 
  r.append (c.rank) 
B1 = (r[0]==r[1]==r[2])and (r[3]==r[4])  
B2 = (r[0]==r[1])and (r[2]==r[3]==r[4])  
If B1 or B2:  
    print ‘Full House’  
 
 
 Is a Hand H a Full House?  
H.sort() 
r = [] 
for c in H.cards: 
  r.append (c.rank) 
B1 = (r[0]==r[1]==r[2])and (r[3]==r[4])  
B2 = (r[0]==r["
"1])and (r[2]==r[3]==r[4])  
if B1 or B2:  
    print ‘Full House’  
 
 
 Sort the Hand by rank  Three Hands  
    Seven of Spades  
    Seven of Diamonds  
    Seven of Clubs  
      Ten of Spades  
      Ten of Diamonds   Four of Spades  
 Four of Diamonds  
 Jack of Hearts  
 Jack of Clubs  
 Jack of Spades  
 Four of Spades  
 Four of Diamonds  
 Five of Hearts  
 Jack of Clubs  
 Jack of Spades  Yes: Yes: 
No: Is a Hand H a Full House?  
H.sort() 
r = [] 
for c in H.cards: 
  r.append (c.rank) 
B1 = (r["
"0]==r[1]==r[2])and (r[3]==r[4])  
B2 = (r[0]==r[1])and (r[2]==r[3]==r[4])  
If B1 or B2:  
    print ‘Full House’  
 
 
 Form a list of the ranks  Is a Hand H a Full House?  
H.sort() 
r = [] 
for c in H.cards: 
  r.append (c.rank) 
B1 = (r[0]==r[1]==r[2])and (r[3]==r[4])  
B2 = (r[0]==r[1])and (r[2]==r[3]==r[4])  
if B1 or B2 : 
    print ‘Full House’  
 
 
 Boolean Business  "
"26. Data Visualization  
Topics  
 
         How to define a useful class for   
  for manipulating sunrise/sunset  
  data.  
 How to graphically display facts about  
  that data   using numpy  and pyplot . The Problem  
For various cities around the world, we would  
like to examine the “Sun Up” time  
throughout the year.  
 
How does it vary from day to day?  
 
What are the monthly averages?  
Sun Up Time = Sunset Time – Sunrise Time   
Average Sun -Up (Hours):  
 
       City     Latitude   June   Se"
"ptember  December   March  
---------------------------------------------------------------  
      London     51.50     16.55     12.64      7.93     11.89  
      Ithaca     42.43     15.24     12.47      9.13     11.95  
     NewYork     40.73     15.04     12.45      9.31     11.96  
       Cairo     30.05     14.05     12.34     10.25     11.99  
       Miami     25.78     13.72     12.29     10.56     12.02  
       Lagos      6.58     12.50     12.15     11.75     12.08  
Johannesburg    -26.20     1"
"0.52     11.94     13.75     12.23  
      Sydney    -33.88      9.94     11.87     14.36     12.30  How Does Sun -Up 
Depend on Latitude  and Month?  Visualization!  
How Does Sun -Up Time  
 Vary Day -to-Day?  
How Does Sun -Up Time  
 Vary Month -To-Month?  
Recall the Motivating Problem  
For various cities around the world, we would  
like to examine the “Sun Up” time  
throughout the year.  
 
How does it vary from day to day?  
 
What are the monthly averages?  
Let’s define a class that makes this e"
"asy.  Our Plan  
1.We define a class Daylight  that facilitates  
     data acquisition.  
 
2.  We introduce numpy  arrays and show how to  
 use the pylab  for plottiing  The Class Daylight  
5 Attributes  
 
 Name :  name of the city [ str] 
 Lat:  latitude in degrees  [float]  
 Long: longitude in degrees [float]  
 RiseTime : rise time in hours   
                    [length-365 numpy array] 
 SetTime:  set time in hours  
                     [length-365 numpy array]    What the Constructor Does  
It "
"will have one argument: the name of a city  
as a string.  
 
It will then read the . dat file  associated with 
that city and proceed to set up the 5 
attributes.  A Folder Called RiseSetData  Has 
.dat Files for Each these Cities  
Anaheim      Anchorage     Arlington    Athens        Atlanta  
Baltimore    Bangkok       Beijing      Berlin        Bogata 
Boston       BuenosAires    Cairo        Chicago       Cincinnati  
Cleveland    Denver        Detroit      Honolulu      Houston  
Ithaca       Johanne"
"sburg  KansasCity    Lagos         London  
LosAngeles    MexicoCity     Miami        Milwaukee     Minneapolis  
Moscow       NewDelhi       NewYork      Oakland       Paris  
Philadelphia Phoenix       Pittsburgh   RiodeJaneiro   Rome 
SanFrancisco  Seattle       Seoul        Sydney        Tampa  
Teheran      Tokyo         Toronto      Washington    Wellington  
 
For us, .dat files are  the same as .txt files 
Downloaded from :  http://www.usno.navy.mil/  What  do the lines in 
Ithaca.dat  
look like?  "
"There Are 33 Lines  
  Ithaca 
  W07629N4226  
  1   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  2   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  3   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 
 
 28   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 29   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 30   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 31   R S  R S  R S  R S  R S  R S  R S  The Data for a Particular "
"City 
is Housed in a 33 -line .dat file 
  Ithaca 
  W07629N4226  
  1   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  2   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  3   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 
 
 28   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 29   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 30   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 31   R S  R S  R S  R S  R S  R S  R S  
Line "
"2 encodes its longitude and latitude  Helper Function: LongLat  
def LongLat(s): 
    Long = float( s[1:4])+ float(s[4:6])/60 
    if s[0]=='E': 
       Long = -Long 
    Lat = float( s[7:9])+ float(s[9:11])/60 
    if s[6]=='S': 
        Lat = -Lat 
    return ( Lat,Long ) A latlong  string has length 11  
        W08140N4129 The Data for a Particular City 
is Housed in a 33 -line .dat file 
  Ithaca 
  W07629N4226  
  1   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  2   R S  R S  R S  R "
"S  R S  R S  R S  R S  R S  R S  R S  R S  
  3   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 
 
 28   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 29   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 30   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 31   R S  R S  R S  R S  R S  R S  R S  
The remaining lines house the rise -set data.  
Each R and S is a length -4 string:  ‘0736’  Helper Function:  ConvertTime  
def ConvertTime (s): 
    x = float(s"
"[:2])+float(s[2:])/60  
    return x  
In comes a length -4 string and back comes  
a float that encodes the time in hours  
 
‘0736’   ---->  7 + 36/60 hours   ----> 7.6 The Data for a Particular City 
is Housed in a 33 -line .dat file 
  Ithaca 
  W07629N4226  
  1   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  2   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
  3   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  
 
 
 28   R S  R S  R S  R S  R S  R S  R S  R "
"S  R S  R S  R S  R S  
 29   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 30   R S  R S  R S  R S  R S  R S  R S  R S  R S  R S  R S   
 31   R S  R S  R S  R S  R S  R S  R S  
Day-Number followed by 12 rise -set pairs, one  
pair for each month  Rise/Set data for April 3  The Class Daylight  
Attributes:  
 
    City: name of the city [ str] 
     Lat: latitude in degrees [float]  
    Long: longitude in degrees [float]  
RiseTime : length -365 numpy array of      
   sunrise times  
 SetTim"
"e: length -365 numpy array of  
   sunset times   The Constructor  
Sample Call  
 
       C = Daylight(‘Ithaca’)  
 
Reads the file Ithaca.dat  into a list of  
33 strings. Each string is deciphered.  
 
Creates the Daylight  object that house’s  
Ithaca’s name, latitude, longitude, the 365  
sunrise times and the 365 sunset times.  We Need Some New Tools  
To Graphically Display the Data  
 
from numpy import *  
from pylab import *  
We use numpy  for arrays  
and  
pylab  for plotting.  A Simple Plot  
"
"A = Daylight(‘Ithaca’)  
D = A.SunUp() 
plot(D) 
show() 
How does this work?  A Simple Plot  
A = Daylight(‘Ithaca’)  
D = A.SunUp() 
plot(D) 
show() 
 def SunUp(self): 
    """"""returns a  length -365 numpy 
    array of sun -up times. """"""  
    return self.SetTime  - self.RiseTime  
You can subtract one numpy  array from another.  How about a title and a labeling of the y -axis?  A Simple Plot  
A = Daylight(‘Ithaca’)  
D = A.SunUp() 
plot(D) 
 
titlestr  = '%s  Lat = %6.2f  Long = %6.2f' % ( A.City,A.Lat,A"
".Long ) 
title(titlestr,fontsize =16) 
ylabel('Hours of Sunlight',fontsize =16) 
show() Modify the x range and the y range  
A Simple Plot  
A = Daylight(‘Ithaca’)  
D = A.SunUp() 
plot(D) 
 
titlestr  = '%s  Lat = %6.2f  Long = %6.2f' % ( A.City,A.Lat,A.Long ) 
title(titlestr,fontsize =16) 
ylabel('Hours of Sunlight',fontsize =16) 
 
xlim(0,364) 
ylim(5,20) 
 
show() Label the x -axis with month names  
Add a Grid  
Monthly Averages  
 def MonthAves (self): 
     x = zeros((12,1))  
     D = self.SunUp () "
"
     start  = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]  
     finish = [30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333,364]  
     for k in range(12):  
         z = D[start[k]:finish[k]]  
         x[k] = sum(z)/ len(z) 
     return x  A Bar Plot  
A = Daylight(‘Ithaca’)  
M = A.MonthAves () 
 
bar(range(12), M,facecolor ='magenta')  
xlim(-.2,12) 
ylabel('Average Hours of Sunlight')  
title(A.City,fontsize =16) 
show() More on Numpy  Arrays  1-dimensional Array Basics  
>>> from numpy "
"import *  
>>> x = array([1,2,3])  
>>> x 
array([1, 2, 3])  
>>> x[2]  
3 
X is a 1d array. (2d arrays soon!)  
 
It has 3 entries  
 
The entries are floats.  
  1-dimensional Array Basics  
>>> y = array([1,2,3], dtype='int') 
>>> z = y[2]/y[1]  
>>> z 
1 
This is how you create an array of ints. 
  1-dimensional Array Basics  
>>> a = array([10,20,30])  
>>> b = array([5,4,15])  
>>> a+b 
array([15, 24, 45])  
>>> a-b 
array([ 5, 16, 15])  
>>> a/b 
array([2, 5, 2])  
>>> a*b 
array([ 50,  80, 450])  
Y"
"ou can add, subtract, divide, and multiply arrays.  
  1-dimensional Array Basics  
>>> f = array([10,20])  
>>> g = array([1,2,3])  
>>> f+g 
Traceback  (most recent call last):  
  File ""<stdin>"", line 1, in <module>  
ValueError : operands could not be  
broadcast together with shapes (2,) (3,)  
But they better be the same size!.  
  1-dimensional Array Basics  
>>> u = [1,2,3]  
>>> type(u)  
<type 'list'>  
>>> v = array([10,20,30])  
>>> type(v)  
<type 'numpy.ndarray '> 
>>> z = u+v 
>>> z 
array([1"
"1, 22, 33])  
>>> type(z)  
<type 'numpy.ndarray '> You can  
mix “regular”  
lists of  
numbers 
with 
numpy  
arrays  
  1-dimensional Array Basics  
>>> x = array([-10.3,12.6, -89.7]) 
>>> y = abs(x) 
>>> y 
array([ 10.3,  12.6,  89.7])  
You can apply a function to an array  
if it is ok to apply the function to  
each entry in the array.  
  The numpy  linspace  function  
x = linspace (1,3,5) 
1.0  1.5  2.0  2.5  3.0  x : 
linspace (a,b,n) is a length –n 
list of values that are equally spaced  
from "
"x = a to x = b.  Plotting a With Pylab  
Assume: 
 from numpy import *  
 from pylab import *  Displaying an Array  
Assume: 
 from numpy import *  
 from pylab import *  U = Daylight(‘Ithaca’)  
D = U.SunUP() 
plot(D) Displaying an Array  Table    Plot 
  x     sin(x)  
0.00     0.0  
1.57     1.0  
3.14     0.0  
4.71    -1.0 
6.28     0.0  
Plot based on 5 points  Table    Plot 
  x     sin(x)  
0.000    0.000  
0.784    0.707  
1.571    1.000  
2.357    0.707  
3.142    0.000  
3.927   -0.707   
4.712"
"   -1.000 
5.498   -0.707 
6.283    0.000  
Plot based on 9 points  Table    Plot 
Plot based on 200 points —looks smooth  Generating Tables and Plots  
  x     sin(x)  
0.000    0.000  
0.784    0.707  
1.571    1.000  
2.357    0.707  
3.142    0.000  
3.927   -0.707   
4.712   -1.000 
5.498   -0.707 
6.283    0.000  x = linspace (0,2*pi,9 ) 
y = sin(x ) 
plot(x,y) 
show() 
plot(x,y) 
x,y  1-dim arrays of numbers  
That have the same length  
 
plot(x,y) “connects the dots”:  
 
(x[0],y[0]) ,..., (x[n -1"
"],y[n-1]) Drawing Lines  
for k in range(6,20):  
    # Draw horizontal line from (0,k) to (365,k)  
    plot(array([0,365]) ,array([k,k]), 
                      color='red',linestyle =':') 
Drawing Lines  
for k in range(6,20):  
    # Draw horizontal line from (0,k) to (365,k)  
    plot(array([0,365]) ,array([k,k]), 
                      color='red',linestyle =':') 
Connect  
 two dots  A Note on subplot 
subplot(2,1,1)  
   <code> 
subplot(2,1,2)  
   <code> 
 
Show()  1 
 2 
When you want  
more than"
" one  
plot in the window.  A Note on subplot 
subplot(2,2,1)  
   <code> 
subplot(2,2,2)  
   <code> 
subplot(2,2,3)  
   <code> 
subplot(2,2,4)  
   <code> 
 
Show()  1  2 
 3 4  2 "
"27. Two-Dimensional Arrays  
Topics  
 Motivation  
 The numpy  Module  
 Subscripting  
 functions and 2d Arrays  
 
 Visualizing  
A 2D array has rows and columns.  
 
This one has 3 rows and 4 columns.  
 
We say it is a “3 -by-4” array ( a.k.a matrix)  12 17 49 61 
38 18 82 77 
83 53 12 10 Can have a 2d array  
of strings or  
objects.  
 
But we will just  
deal with 2d arrays  
of numbers.  Rows and Columns  
This is row 1.  12 17 49 61 
38 18 82 77 
83 53 12 10 Rows and Columns  
This is column 2.  1"
"2 17 49 61 
38 18 82 77 
83 53 12 10 Entries  
This is the (1,2) entry.  12 17 49 61 
38 18 82 77 
83 53 12 10 Where Do They Come From?  
Entry ( i,j) is the distance from city i to city j  
Where  Do they Come From?  
Entry ( i,j) is 1 if node i is connected to  
node j and is 0 otherwise  
Captures the connectivity in  
a network       
      Nodes  
4 and 6  
Are  
connected  Where Do They Come From  
An m -by-n array  
of pixels.  
 
Each pixel encodes  
3 numbers: a red value,  
a green value, a blue  "
"
value  
 
So all the information  
can be encoded in three  
2D arrays  
2d Arrays in Python  
A = [[12,17,49,61],[38,18,82,77],[83,53,12,10]]  
A list of lists.  12 17 49 61 
38 18 82 77 
83 53 12 10 Accessing Entries  
A = [[12,17,49,61],[38,18,82,77],[83,53,12,10]]  A[1][2] 12 17 49 61 
38 18 82 77 
83 53 12 10 Accessing Entries  
A = [[12,17,49,61],[38,18,82,77],[83,53,12,10]]  A[2][1] 12 17 49 61 
38 18 82 77 
83 53 12 10 Setting Up 2D Arrays  
def zeros( m,n): 
    v = [] 
    for k in range(n):  
  "
"      v.append (0.0) 
    A = [] 
    for k in range(m):  
        A.append (v) 
    return A  
 Here is a function that returns a reference to  
an m-by-n array of zeros:  Python is Awkward  
Turns out that base Python is not very handy  
for 2D array manipulations.  
 
The numpy  module makes up for this.  
 
We will learn just enough numpy  so that  
we can do elementary plotting, image  
processing and other things.  
 
 Introduction to 2D Arrays  
in numpy  
A few essentials illustrated  
by examples. "
" Setting up a 2D Array of 0’s  
>>> from numpy import *  
>>> m = 3  
>>> n = 4  
>>> A = zeros((m,n))  
>>> A 
array([[ 0.,  0.,  0.,  0.],  
       [ 0.,  0.,  0.,  0.],  
       [ 0.,  0.,  0.,  0.]])  
Note how the row and column dimensions are passed to zeros  Accessing an Entry  
>>> A = zeros((3,2))  
>>> A[2,1] = 10  
>>> A 
array([[  0.,   0.],  
       [  0.,   0.],  
       [  0.,  10.]])  
A nicer notation than A[2][1].  Accessing an Entry  
>>> A = array([[1,2,3],[4,5,6]])  
>>> A 
array([[1, 2"
", 3],  
       [4, 5, 6]])  
Using the array constructor to build a  
3-by-2 array. Note all the square brackets.  Use Copy to Avoid Aliasing  
>>> A = array([[1,2],[3,4]])  
>>> B = A  
>>> A[1,1] = 10  
>>> B 
array([[ 1,  2],  
       [ 3, 10]])  2D arrays are  
objects  >>> A = array([[1,2],[3,4]])  
>>> B = copy(A)  
>>> A[1,1] = 10  
>>> B 
array([[1, 2],  
       [3, 4]])   1  2 
 3  4 Iteration and 2D Arrays  
 
Lots of Nested Loops  
 Nested Loops and 2D Arrays  
A = array((3,3))  
for i in range(3"
"):  
   for j in range(3):  
        A[i,j] = (i+1)*(j+1)  
   1     2    3 
   2    4    6 
   3    6    9 A  
3x3 
times  
table  Nested Loops and 2D Arrays  
A = array((3,3))  
             
            
            
Allocates memory, but doesn’t put any values  
in the boxes. Much more efficient than the  
Repeated append framework.  Understanding 2D Array Set -Up 
for i in range(3):  
   for j in range(3):  
        A[i,j] = (i+1)*(j+1)  
for i in range(3):  
    A[i,0] = (i+1)*(0+1)  
    A[i,1] = (i+"
"1)*(1+1)  
    A[i,2] = (i+1)*(2+1)  
Equivalent!  Understanding 2D Array Set -Up 
for i in range(3):  
    A[i,0] = (i+1)*(0+1)  
    A[i,1] = (i+1)*(1+1)  
    A[i,2] = (i+1)*(2+1)  
   1     2    3 
            
            Row 0 is  
set up when  
i = 0 Understanding 2D Array Set -Up 
for i in range(3):  
    A[i,0] = (i+1)*(0+1)  
    A[i,1] = (i+1)*(1+1)  
    A[i,2] = (i+1)*(2+1)  
   1     2    3 
   2    4    6 
            Row 1 is  
set up when  
i = 1 Understanding 2D Array Set -Up 
for i in ran"
"ge(3):  
    A[i,0] = (i+1)*(0+1)  
    A[i,1] = (i+1)*(1+1)  
    A[i,2] = (i+1)*(2+1)  
   1     2    3 
   2    4    6 
   4    6    9 Row 2 is  
set up when  
i = 2 Extended Example  
A company has m factories and each of which  
makes n products.  We’ll refer to such a company  
as an m-by-n company .  
 
Customers submit purchase orders in  
which they indicate how many of each  
product they wish to purchase. A length -n list  
of numbers that expresses this called a PO list.  Cost and Inventory  
 
"
"The cost of making a product varies from  
factory to factory.  
 
Inventory varies from factory to factory.  
 Three Problems  
A customer submits a purchase order that is to 
be filled by a single factory.  
 
 
 Q1. How much would it cost each factory  
 to fill the PO?  
 
 Q2. Which  factories have enough inventory  
 to fill the PO?  
 
 Q3. Among the factories that can fill the PO, 
which one can do it most cheaply?  
 
 Ingredients  
To set ourselves up for the solution to these  
problems we need t"
"o understand:  
 
 -The idea of a Cost Array (2D)  
 
    - The idea of an Inventory Array (2D)  
 
 - The idea of a Purchase Order Array (1D)  
 
We will use numpy  arrays throughout.  Cost Array  
C ---> 
   10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
The value of C[k,j]  is what it costs  
factory  k  to make product  j.   Cost Array  
C ---> 
   10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
The value of C[k,j]  is what it costs  
factory  k  to make product  j.   It costs  
$12 for  
factory 1  "
"
to make  
product 3  Inventory Array  
38 5 99 34 
82 19 83 12 I --->  
51 29 21 56 42 42 
87 
The value of I[k,j] is the inventory in  
factory  k  of product  j.   Inventory Array  
38 5 99 34 
82 19 83 12 I --->  
51 29 21 56 42 42 
87 
The value of I[k,j] is the inventory in  
factory  k  of product  j.   Factory 1  
can sell up  
to 83 units  
of product 2.  Purchase Order  
The value of PO[j]  is the number  
product  j’s that the customer wants   1 0 12 5 29 PO ---> 
   Purchase Order  
The value of"
" PO[j]  is the number  
product  j’s that the customer wants   1 0 12 5 29 PO ---> 
   The customer  
wishes to  
purchase 29  
product 3 units  We Will Develop a Class  
called  
Company 
We will package data and methods in a way  
that makes it easy to answer Q1, Q2, and Q3  
and to perform related computations.  First, Some Handy Numpy  
Features  Computing Row and Column  
Dimension  
I = array([[10,36,22],[12,35,20 ]]) Suppose:  
A 2-by-3 
array.  10 36 22 
12 35 20 I --> 
   Computing Row and Column  "
"
Dimension Using shape  
(m,n) = I.shape  Suppose:  
10 36 22 
12 35 20 I --> 
   
  2     3   m: n: Useful in functions  
and methods with 2D  
array arguments  
(m,n) is a “ tuple ” 
shape is  an attribute of the array class  Finding the Location of the 
Smallest Value Using argmin  
>>> from numpy import *  
>>> x = array([20,40,10,70.60])  
>>> iMin = x.argmin () 
>>> xMin = x[iMin] 
>>> print iMin, xMin 
2   10 
There is  also an argmax  method  >>> x = array([20,10,30])  
>>> y = array([2,1,3])  
>>> "
"z = array([10,40,15])  
 
>>> x>y 
array([ True,  True,  True], dtype=bool) 
>>> all(x>y)  
True 
 
>>> x>z 
array([ True, False,  True], dtype=bool) 
>>> any(x>z)  
True Comparing Arrays  >>> x = inf 
>>> 1/x 
0 
>>> x+1 
Inf 
>>> inf > 9999999999999  
True inf 
A special float that behaves like infinity  Now Let’s Develop the  Class  
Company 
Start with the attributes and the  
constructor.  The Class Company : Attributes  
class Company(object):  
    """""" 
   Attributes:  
     C : m-by-n cost array [fl"
"oat]  
     I : m-by-n inventory array [float]  
    TV : total value [float]  
    """""" 
Total Value: How much is the total inventory worth ?  The Class Company : Constructor  
def __init__( self,Inventory,Cost ): 
     self.I = Inventory  
     self.C = Cost 
     (m,n) = Inventory.shape  
     TV = 0 
     for k in range(m):  
         for j in range(n):  
             TV += Inventory[ k,j]*Cost[k,j] 
     self.TV = TV  
The incoming arguments are the Inventory  
and Cost Arrays  Row and Column Dimensions"
"  
def __init__( self,Inventory,Cost ): 
     self.I = Inventory  
     self.C = Cost 
     (m,n) = Inventory.shape  
     TV = 0 
     for k in range(m):  
         for j in range(n):  
             TV += Inventory[ k,j]*Cost[k,j] 
     self.TV = TV  
To compute the row and column dimension of a  
numpy  2D array, use the shape attribute.  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
I"
"nventory Array  Cost Array  The nested loop  
takes us to each  
array entry  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
Inventory Array  Cost Array  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
Inventory Array  Cost Array  Computing Total Value  
TV = 0 
for k in"
" range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
Inventory Array  Cost Array  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
Inventory Array  Cost Array  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I"
" --> 
   
Inventory Array  Cost Array  Computing Total Value  
TV = 0 
for k in range(m):  
    for j in range(n):  
          TV += I[k,j]*C[k,j] 
30 40 50 
60 70 80 C --> 
   10 36 22 
12 35 20 I --> 
   
Inventory Array  Cost Array  Now Let’s Develop Methods  
to Answer These 3 Questions   
Q1. How much would it cost each factory  
to fill a purchase order?  
 
Q2. Which  factories have enough inventory  
to fill a purchase order?  
 
Q3. Among the factories that can fill the  
purchase order, which one "
"can do it most cheaply?  
 
 Q1. How Much Does it Cost 
Each Factory to Process  
a Purchase order?  1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
1*10 + 0*36 + 12*22 + 29* 15 + 5*62 For  factory 0:   PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
s = 0; 
for j in range(5):  
  s = += C[0,j] * PO[j] For  
factory 0:   j = 0 
PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
For  
factory 0:   j = 1 
s = 0 
for j in range(5"
"):  
  s = += C[0,j] * PO[j] PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
s = 0; 
for j=1:5  
  s = s + C(1,j) * PO(j) For  
factory 0:   j = 2 
s = 0 
for j in range(5):  
  s = += C[0,j] * PO[j] PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
s = 0; 
for j=1:5  
  s = s + C(1,j) * PO(j) For  
factory 0:   j = 3 
s = 0 
for j in range(5):  
  s = += C[0,j] * PO[j] PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21"
" 16 66 62 
59 
s = 0; 
for j=1:5  
  s = s + C(1,j) * PO(j) For  
factory 0:   j = 4 
s = 0 
for j in range(5):  
  s = += C[0,j] * PO[j] PO ---> 
   C ---> 
   1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 
s = 0; 
for j=1:5  
   s = s + C(2,j)*PO(j)  For  
factory 1:   s = 0 
for j in range(5):  
  s = += C[1,j] * PO[j] PO ---> 
   C ---> 
   1 0 12 5 29 
For  
factory k:   s = 0 
for j in range(5):  
  s = += C[k,j] * PO[j] PO ---> 
   10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 C ---> "
"
   def Order(self,PO):  
    “““ Returns an m -by-1 array that  
    houses how much it costs  
  each factory to fill the PO.  
 
    PreC: self is a Company object  
    representing m factories and n  
    products. PO is a length -n 
 purchase order list.  
    ”””  To Answer Q1 We Have  1 0 12 5 29 10 36 22 15 
12 35 20 12 
13 37 21 16 66 62 
59 What the Order Method Does  
1019 
 930 
1040 self.C --> 
   
PO --> 
   
 Returns  [1019,930,1040]  def Order(self,PO):  
    C = self.C  
    (m,n) = C.shap"
"e  
    theCosts = zeros((m,1))  
    for k in range(m):  
        for j in range(n):  
           theCosts[k] += C[k,j]*PO[j]  
    return theCosts  Implementation…  >>> A = Company(I,C)  
>>> x = A.Order(PO) 
>>> kMin = x.argmin () 
>>> xMin = x[kMin] 
 
 Using Order  
Assume that the following are initialized:  
 
  I   the Inventory array  
         C   the Cost array  
        PO  the purchase order array  
 kMin  is the index of the factory that can most  
cheaply process the PO and xMin is the cost  "
" Q2. Which Factories  
Have Enough Inventory to  
Process a Purchase Order?  Who Can Fill the Purchase Order 
(PO)?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes 
Factory 2 can’t because  12 < 29 I --> 
   
PO --> 
   Who Can Fill the Purchase Order 
(PO)?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes 
We need to compare the rows of I with PO.  I --> 
   
PO --> 
   Who Can Fill the Purchase Order 
(PO)?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
"
"87 
1 0 12 5 29 Yes 
No 
Yes 
  all( I[0,:] >= PO )  is True  I --> 
   
PO --> 
   Who Can Fill the Purchase Order 
(PO)?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes 
  all( I[1,:] >= PO )  is False  I --> 
   
PO --> 
   Who Can Fill the Purchase Order 
(PO)?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes 
  all( I[2,:] >= PO )  is True  I --> 
   
PO --> 
   To Answer Q2 We Have…  
def CanDo(self,PO): 
    """""" Return the indices of those  
    fa"
"ctories with sufficient 
 inventory.  
 
    PreC: PO is a purchase order 
 array. """"""  
     Who Can Fill the PO?  
def CanDo(self,PO):  
    I = self.I  
    (m,n) = I.shape  
    Who = []  
    for k in range(m):  
       if all( I[k,:] >= PO):  
           Who.append(k)  
    return array(Who)  Grab the  
 inventory array  
and compute  
its row and col  
dimension.,  Who Can Fill the PO?  
def CanDo(self,PO):  
    I = self.I  
    (m,n) = I.shape  
    Who = []  
    for k in range(m):  
       if all"
"( I[k,:] >= PO):  
           Who.append(k)  
    return array(Who)  Initial ize Who to  
the empty list.  
Then build it up  
thru repeated  
appending  Who Can Fill the PO?  
def CanDo(self,PO):  
    I = self.I  
    (m,n) = I.shape  
    Who = []  
    for k in range(m):  
       if all( I[k,:] >= PO): :  
           Who.append(k)  
    return array(Who)  If every element  
of I[k,:] is >= the  
corresponding entry  
in PO, then factory k  
has sufficient inventory  Who Can Fill the PO?  
def CanDo(self"
",PO):  
    I = self.I  
    (m,n) = I.shape  
    Who = []  
    for k in range(m):  
       if all( I[k,:] >= PO):  
           Who.append(k)  
    return array(Who)  Who is  
not a  
numpy  array,  
but 
array(Who ) is >>> A = Company(I,C)  
>>> kVals = A.CanDo(PO) 
 
 Using CanDo  
Assume that the following are initialized:  
 
  I   the Inventory array  
         C   the Cost array  
        PO  the purchase order array  
kVals is an array that contains the indices of  
those factories with enough inve"
"ntory   >>> A = Company(I,C)  
>>> kVals = A.CanDo(PO) 
 
 Using CanDo  
Assume that the following are initialized:  
 
  I   the Inventory array  
         C   the Cost array  
        PO  the purchase order array  
If  k in kVals  is True, then  
 
 all(A.I[k,:]>= PO)  
 
is True  Q3: Among the  
Factories with enough  
Inventory, who can fill the  
PO Most Cheaply??  For Q3 We Have  
def theCheapest (self,PO): 
     """""" Return the tuple (kMin,costMin ) 
  where kMin is the index of the factory  
     tha"
"t can fill the PO most cheaply and  
  costMin is the associated cost. If no  
  such factory exists, return None.  
 
     PreC: PO is a purchase order list. """"""  
   
        theCosts  = Order(PO)  
        Who = CanDo(P0) 
        if len(Who)==0:  
            return None  
        else: 
            Who Can Fill the Purchase Order 
Most Cheaply?  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes I --> 
   
PO --> 
   
kMin = 0,   costMin = 1019  1019 
1040 Implementation  
 def t"
"heCheapest(self,PO):  
    theCosts = Order(PO)  
    Who = CanDo(PO)  
    if len(Who)==0:  
        return None  
    else: 
        # Find kMin and costMin  Implementation Cont’d  
# Find kMin and costMin  
costMin = inf  
for k in Who:  
   if theCosts[k]<costMin:  
       kMin = k  
       costMin = theCosts[k]  
return (kMin,costMin)  
 >>> A = Company(I,C)  
>>> (kMin,costMin ) = A.Cheapest (PO) 
 
 Using Cheapest  
Assume that the following are initialized:  
 
  I   the Inventory array  
         C"
"   the Cost array  
        PO  the purchase order array  
The factory with index kMin can deliver  
PO most cheaply and the cost is costMin   Updating the Inventory  
After Processing a PO  Updating Inventory  
38 5 99 34 
82 19 83 12 
51 29 21 56 42 42 
87 
1 0 12 5 29 Yes 
No 
Yes I --> 
   
PO --> 
   
Before 1019 
1040 Updating Inventory  
37 5 87 5 
82 19 83 12 
51 29 21 56 42 37 
87 
1 0 12 5 29 I --> 
   
PO --> 
   
After def UpDate(self,k,PO ): 
    n = len(PO) 
    for j in range(n):  
        # "
"Reduce the inventory of product j  
        self.I[k,j] = self.I[k,j] - PO[j] 
        # Decrease the total value  
        self.TV = self.TV - self.C[k,j]*P0[j] Method for Updating  
the  Inventory Array  
After Processing a PO  
Maintaining the class invariant, i.e., the connection  
between the I, C, and TV attributes.  
 
   "
"3. Conditional Execution  
Topics:  
 Boolean values  
 Relational operators  
 if statements  
 The Boolean type  Motivation  
a = input(‘Enter a pos float: ‘)  
b = input(‘Enter a pos float: ‘)  
print a**b, b**a  Assign positive float values to variables a 
and b and print the values a**b and b**a. Problem:  
Solution:  Motivation  
 
              ? Problem:  
Solution:  
7**2 < 2**7                   2**3  <   3**2  Assign positive float values to variables a 
and b and print the values a**b and b**a. "
"Solution Using If -Else 
a  = input(‘Enter a pos float: ‘)  
b  = input(‘Enter a pos float: ‘)  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa 
This is what is called “conditional execution.”   
 
 
 
 
 
 If-Else: How Does it Work?  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa   128 aTob    
bToa       49 
Let’s suppose the value of a is 2 and the value of b is 7. Solution Using If -Else 
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print"
" aTob 
else: 
   print bToa   128 aTob    
bToa       49 
The comparison  
 
     aTob > bToa 
  
is called a boolean  expression.  
It is either True or False  
     
 
Is the value of aTob  larger than the value of bToa  ? 
. Solution Using If -Else 
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa   128 aTob    
bToa       49 
The boolean  expression  
 
     aTob > bToa 
 
is  True   so execute  
 
     print aTob 
    
Is the value of aTob  larger than the value of bToa  ?"
" Yes!  
. If-Else: How Does it Work?  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa    49 aTob    
bToa       128 
Now let’s suppose the value of a is 7 and the value of b is 2. If-Else: How Does it Work?  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa    49 aTob    
bToa      128  
 
Is the value of aTob  larger than the value of bToa  ? If-Else: How Does it Work?  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print b"
"Toa    49 aTob    
bToa       128 
The boolean  expression  
 
    aTob > bToa 
 
is  False   so execute  
  
    print bToa 
    
Is the value of aTob  larger than the value of bToa  ? No!  
. If-Else: How Does it Work?  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   print bToa Note the punctuation and  
the indentation.  
 
This is essential syntax.  
 
Forgetting the colons  
is a major boo boo! 
    “Synonym”  
aTob = a**b 
bToa = b**a 
if aTob > bToa: 
   print aTob 
else: 
   pri"
"nt bToa if a**b > b**a: 
   print a**b  
else: 
   print b**a  
In a comparison, legal to have general 
expressions on either side of the “<“.  
    The if-else  Construction  
if 
else: Boolean expression  
Statements to execute if the  
     expression if True 
Statements to execute if the  
     expression if False  : 
This is an example of conditional execution.   
The if -else construction is sometimes called “alternative execution”  The if-else  Construction  
if 
else:   a**b > b**a  
z = b**a  
z = "
"a**b  : 
print ‘The smaller value is:’,z The blue box decides  
whether the green box  
or the pink box is executed.  
    
After that choice is processed, this print statement  
is carried out.  
    Reminder that Indentation Is  
Important  
If x is even, then the code on the left will print the value of x/2 while the code  
on the right will print the value of x/2 twice (on separate lines).  if x%2==0:  
   y = x/2 
   print y 
else: 
   y = (x+1)/2  
   print y 
   if x%2==0:  
   y = x/2 
   print y 
e"
"lse: 
   y = (x+1)/2  
print y 
   Another Example  
s = s[0:4] + ’ ies’ The last character in a string 5 -character  
string  is  ’y’. Change the ‘ y’ to ‘i’ and add  
‘es’ Problem:  
Solution:  
Want:    ‘carry’   to become   ‘carries’         
Use string slicing and concatenation:     ‘ carr’ + ‘ies’ A Modified Problem  
If the last character in a 5 -character  
string  s  is  ’y’, then  
       1. change the ‘ y’ to  ‘i’  
       2. add ‘es’  
       3. assign the result to a variable plural .   
Otherw"
"ise , just add  ‘ s’ and assign the  
       result to a variable plural . 
         
This will require the if -else construction.  Solution  
if s[4]==‘y’:  
   plural = s[0:4] + ’ ies’ 
else: 
   plural = s + ‘s’  
print s,plural  
Remember: s[0:4] names the substring comprised of the first 4 characters.  Discussion of Solution  
if s[4]==‘y’: 
   plural = s[0:4] + ’ ies’ 
else: 
   plural = s + ‘s’  
print s,plural  
A new comparison is being used.  
 
If you want to check to see if two expressions have "
" 
      the same value, use  == .  
 
Why? If you say s[4]=‘y’ it looks like an assignment.  
    Discussion of Solution  
if s[4]==‘y’: 
   plural = s[0:4] + ’ ies’ 
else: 
   plural = s + ‘s’  
print s,plural  
The print statement is executed after the if -else  
is processed. E.g.  
 
                   carry  carries  
    Relational Operators  
 
  <  Less than  
  >  Greater than  
  <=  Less than or equal to  
  >=  Greater than or equal to  
  ==  Equal to  
  !=  Not equal to  Relational Operators "
"in Action  
  x < y      True     
 2*x > y      False  
 x <= y     True  
 x >= y     False  
 x == y/2   True  
 x != y/2.  False  x ---> y --->    3    6 
If the expression on the left is a different numerical type  
then the expression on the right, everything is converted to float.  Boolean Operations with Strings  
Comparing for equality…  
 
>>> s = ‘ abc’ 
>>> s ==‘ abc’ 
True 
>>> s == ‘ abc ‘ 
False                    
 
Two strings are equal if they have the same length and agree in each positio"
"n.  Boolean Operations with Strings  
 
>>> s = ‘Dog’  
>>> s >‘Horse’  
False 
>>> s < ‘Horse’  
True   
>>> s < ‘dog’  
True                  
 
Alphabetical order. If s < t is true then s comes before t in the “extended 
dictionary” based on this ordering of characters:  
 ‘ 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz’  Comparing for alphabetical order…  Relational Operators in Action  
     x < y      False     
      x > y      True  
‘hoc’+x <= y     True  
    x >= y     True  
   "
" x == y[3:] True  
    x != x+’ ‘  True x ---> y --->  ‘key’   ‘hockey’  
Comparisons based on alphabetical order.  
x<y is false because ‘key’ does not come before ‘hockey’ in the dictionary.  Another Problem  
 
Assume that s1 and s2 are initialized strings.  
  
Write code that prints them in alphabetical  
order on separate lines.  
                            Solution  
if s1<s2:  
    print s1  
    print s2  
else: 
    print s2  
    print s1  
 s1 --->   
s2 --->     ‘cat’  
  ‘dog’  
  s1 < s2  
I"
"s this True or False?  Solution  
if s1<s2:  
    print s1  
    print s2  
else: 
    print s2  
    print s1  
 s1 --->   
s2 --->     ‘cat’  
  ‘dog’  
cat 
dog  
 
 
 
 
It’s true!  
Output:                             Solution  
if s1<s2:  
    print s1  
    print s2  
else: 
    print s2  
    print s1  
 s1 --->   
s2 --->     ‘dog’  
  ‘cat’  
  s1 < s2  
Is this True or False?  Solution  
if s1<s2:  
    print s1  
    print s2  
else: 
    print s2  
    print s1  
 s1 --->   
s2 --->     ‘dog’  "
"
  ‘cat’  
cat 
dog  
 
 
 
 It’s false!  
Output:  Indentation Is Important  
if s1<s2:  
    print s1  
    print s2  
else: 
    print s2  
print s1  
 s1 --->   
s2 --->     ‘cat’  
  ‘dog’  
cat 
dog 
cat  
 
 
 
 
Output:  What if You Have More than Two 
Alternatives?  
For example, given a numerical test 
score between 0 and 100, print out the 
letter grade equivalent according to 
these rules:  
 
   A   90-100 
   B   80-89 
   C   70-79 
   U   <70 The If -Elif-Else Construction  
x = input(‘Score"
": ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  
Read “ elif”  as “else if”  The If -Elif-Else Construction  
x = input(‘Score: ‘)  
if x>=90 : 
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  
Read “ elif”  as “else if”  Note the  
punctuation  
and the  
indentation.  If-Elif-Else: How it Works  
   75 x --->   x = input(‘Score: ‘)  
if x>=90:  
   "
" grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. No.  
3. Proceed to the next  
       comparison.               If-Elif-Else: How it Works  
   75 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. No.  
3. Proceed to the next  
       comparison.               If-Elif-Else: How it Works  "
"
   75 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. Yes.  
3. Execute the statement(s)  
    it guards and proceed to  
    whatever follows the  
    if-elif-else              
The indentation scheme “tells” Python what comes after the if -elif-else If-Elif-Else: How it Works  
   95 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = "
"‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade               
1. Is this true?  
2. Yes.  
3. Execute the statement(s)  
    it guards and proceed to  
    whatever follows the  
    If-elif-else If-Elif-Else: How it Works  
   65 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. No.  
3. Proceed to the next  
       comparison.               If-Eli"
"f-Else: How it Works  
   65 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. No.  
3. Proceed to the next  
       comparison.               If-Elif-Else: How it Works  
   65 x --->   x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  1. Is this true?  
2. No.  
3. Execute"
" “the else”  
4. Proceed to what  
    follows the if -elif-else.              Equivalent Scripts  
x = input(‘Score: ‘)  
if x>=90:  
    grade = ‘A’  
elif x>=80: 
    grade = ‘B’  
elif x>=70: 
    grade = ‘C’  
else: 
    grade = ‘U’  
print grade  
The one on the left is better. The letter grade is an essential feature of the 
computation and having a variable that houses it is a reminder of that fact.  x = input(‘Score: ‘)  
if x>=90:  
    print ‘A’  
elif x>=80: 
    print ‘B’  
elif x>=70: 
    pri"
"nt ‘C’  
else: 
    print ‘U’  Legal Not to Have the “Else”  
grade = ‘B’  
nApples = input(‘#Apples sent to Prof:‘)  
if nApples<10: 
   grade = grade + ‘ -’ 
print grade  
Let’s review all the “if” variations…  Standard if-else  
if 
else  A boolean  expression  
: : 
Code that is executed  after the 
whole “if” is processed.  
Exactly one of the green boxes is executed  if-elif  
if 
elif  A boolean  expression  
: : 
 Another boolean  expression  : 
If both boolean  expressions are false, no green box i"
"s executed.  
Otherwise, the “first” green box that is “guarded” by a true boolean  expression  
is executed.  Multiple if-elif With Else 
if 
elif : 
: 
elif 
else 
The first green box guarded by a true boolean  expression is executed.  
If they are all false, then the else’s green box is executed.  : 
: Multiple if-elif With No Else  
if 
elif : 
: 
elif 
elif 
Note that if all the boolean  expressions are False, then no green code is executed.  
Otherwise the first green box guarded by a true boolean  ex"
"pression is executed.  : 
: Boolean Operations  
  Rainy          Sunny               Rainbow   
------------------------------------------------    
  True    True        True    
  True    False       False 
  False   True        False  
  False   False       False  
It is possible to combine two boolean  values 
get a new boolean  value. 
    Boolean Operations  
   Sleepy        Tired               Crabby   
------------------------------------------------    
  True    True        True    
  True    Fa"
"lse       True  
  False   True        True 
  False   False       False  
It is possible to combine two boolean  values 
get a new boolean  value. 
    The and Operation  
(x < y) and (x < z)    True   
(x > y) and (x < z)   False 
(x < y) and (x > z)    False  
(x > y) and (x > z)    False  x ---> y --->    3    6 z --->    9 The and Operation  
  
                                                      and  
----------------------------------------------------    
   True     True          True    
   True"
"     False         False 
   False    True          False  
   False    False         False  
Here            and          are Boolean -valued expressions  Example 1  
s = input(‘length -4 string: ‘)  
 
if (s[0]==s[3]) and (s[1]==s[2]):  
   print ‘palindrome’  
else: 
   print ‘not a palindrome’  
 Fact: A length -4 string is a palindrome if  
the first and last characters are the same and  
the middle two characters are the same.  Example 2  
x = input(‘x: ‘)  
L = input(‘L: ‘)  
R = input(‘R: ‘)  
 
if "
"(L<=x) and (x<=R):  
   print ‘Inside’  
else: 
   print ‘Outside’  
 Fact: x is inside the interval [L,R] if it is  
no smaller than L and no bigger than R.  
x L R Equivalent Solutions  
x = input(‘x: ‘)  
L = input(‘L: ‘)  
R = input(‘R: ‘)  
 
if (L<=x) and (x<=R):  
   print ‘Inside’  
else: 
   print ‘Outside’  
 x = input(‘x: ‘)  
L = input(‘L: ‘)  
R = input(‘R: ‘)  
 
if L<=x<=R :  
   print ‘Inside’  
else: 
   print ‘Outside’  
                                                                 The "
"or Operation  
  
                                                       or  
----------------------------------------------------    
   True     True          True    
   True     False         True  
   False    True          True 
   False    False         False  
Here            and          are Boolean -valued expressions  Example 1  
x = input(‘x: ‘)  
L = input(‘L: ‘)  
R = input(‘R: ‘)  
 
if (x<L) or (R<x):  
   print ‘Outside’  
else: 
   print ‘Inside’  
 Fact: x is inside the interval [L,R] if "
"it is  
 no smaller than L and no bigger than R.  
x L R Equivalent Solutions  
if (x<L) or (R<x):  
   print ‘Outside’  
else: 
   print ‘Inside’  
 Fact: x is inside the interval [L,R] if it is  
 no smaller than L and no bigger than R.  
x L R if (L<=x) and (x<=R):  
   print ‘Inside’  
else: 
   print ‘Outside’  
 
Often you can arrange a  
conditional execution in  
several ways.  The not Operation  
not (x < y)    False      
not (x > y)    True  x ---> y --->    3    6 The not Operator  
  
         "
"                 not  
------------------------------------    
  True           False    
  False          True  
  
Here            is a boolean -valued expression  A Note on Boolean Variables  
Boolean expressions either have the value True  
or the value  False . 
 
When a Boolean expression is evaluated, the  
result can be stored in a variable, e.g.,  
 
      outsideInterval  =  x<L or R<x  
 
We say that outsideInterval  is a Boolean  
variable.  Boolean Variables For Clarity  
Y = input(‘Enter a 4 "
"-digit integer: ‘)  
CenturyYear  = (Y%100 == 0)  
if CenturyYear : 
    LeapYear  = (Y%400 == 0)  
else: 
  LeapYear  = (Y%4 == 0)  
 
Thus, 1960, 2000 and 2400 are leap years. 1961 and 1900 are not. This code  
assigns the value of True  to LeapYear  if Y encodes a leap year. It assigns the 
value of False  to LeapYear  if Y does not encode a leap year.  A Summarizing Example  
Input a string. If it has even length, then  
hyphenate in the middle:  
 
                baseball          base -ball 
 
If it "
"has odd length, then hyphenate around the  
middle character:  
       
               frisbee             fri-s-bee The len Function  
If ever you need to compute the length of  
a string then use the built -in function len. 
s = ‘abcdef’ 
n = len(s) 
m = n/2 
First = s[:m]  
Second = s[m:]       x ---> ‘abcdef ’ 
  6   
 3  
‘def’  ‘abc’      n ---> 
     m ---> 
Second ---> First ---> The len Function  
If ever you need to compute the length of  
a string then use the built -in function len. 
s = ‘abcdef"
"g’ 
n = len(s) 
m = n/2 
First = s[:m]  
Second = s[m:]       x ---> ‘abcdefg ’ 
  7   
 3  
‘defg ’ ‘abc’      n ---> 
     m ---> 
Second ---> First ---> So Let’s Solve this Problem  
Input a string. If it has even length, then  
hyphenate in the middle:  
 
                baseball          base -ball 
 
If it has odd length, then hyphenate around the  
middle character:  
       
               frisbee             fri-s-bee Developing a Solution  
Instead of just showing the solution, let’s  
“derive” t"
"he solution using a methodology  
that is called stepwise refinement . 
The course is really about problem solving with the computer.  
So developing problem -solving strategies is VERY IMPORTANT  “Reformat” the task.  
Read in the string  
Compute its length  
if the length is even  
    Hyphenate in the middle  
else 
    Hyphenate around around the middle  
    character.  
Still in English, but it looks a little more like python.  “Reformat” the task.  
Read in the string  
Compute its length  
if the l"
"ength is even  
    Hyphenate in the middle  
else 
    Hyphenate around around the middle  
    character.  
Turn these into Python   
 Refine  
s = input(‘Enter a string: ‘)  
n = len(s) 
if the length is even  
    Hyphenate in the middle  
else 
    Hyphenate around around the middle  
    character.  
We have turned the first two lines into python.  Refine Some More  
s = input(‘Enter a string: ‘)  
n = len(s) 
if the length is even  
    Hyphenate in the middle  
else 
    Hyphenate around around the "
"middle  
    character.  
How do we check if the value in n is even?                                                                     Refine Some More  
h = input(‘Enter a string: ‘)  
n = len(s) 
if n%2==0:  
   # s has even length  
    Hyphenate in the middle  
else: 
    # s has odd length  
    Hyphenate around around the middle  
    character.  
We add comments to summarize what we may assume about the value of n.  Refine Some More  
h = input(‘Enter a string: ‘)  
n = len(s) 
if n%2==0:  
   # s "
"has even length  
    Hyphenate in the middle  
else: 
    # s has odd length  
    Hyphenate around around the middle  
    character.                                                  
Figure out the even -length hyphenation  Even-Length Hyphenation  
We look at a small example.  
These statements  
    s = ‘abcdef’ 
    h = s[0:3] + ‘ -’ + s[3:]  
 assign ‘abc-def’ to h. 
 
In general:  
        m = n/2 
     h = s[0:m] + ‘ -’ + s[m:]  
  
 Refine Some More  
h = input(‘Enter a string: ‘)  
n = len(s) 
if"
" n%2==0:  
   # s has even length  
  m = n/2 
     h = s[0:m] + ‘ -’ + s[m:]  
else: 
    # s has odd length  
    Hyphenate around around the middle  
    character.   
 Refine Some More  
h = input(‘Enter a string: ‘)  
n = len(s) 
if n%2==0:  
   # s has even length  
  m = n/2 
     h = s[0:m] + ‘ -’ + s[m:]  
else: 
    # s has odd length  
    Hyphenate around around the middle  
    character.   
 
Figure out the odd -length hyphenation  Odd-Length Hyphenation  
We look at a small example.  
This 
 "
"s = ‘abcdefg’ 
 h = s[0:3] + ‘ -’ + s[3] + ‘ -’ + s[3:]  
 assigns ‘abc-d-efg’ to h. 
 
In general:  
    m = n/2 
 h = s[0:m] + ‘ -’ + s[m] + ‘ -’+ s[m+1:]  
  
 Done!  
h = input(‘Enter a string: ‘)  
n = len(s) 
if n%2==0:  
    # s has even length  
    m = n/2 
    h = s[0:m] + ‘ -’ + s[m:]  
else: 
    # s has odd length  
        m = n/2 
    h = s[0:m]+‘ -’+s[m]+‘ -’+s[m+1:]  
  
 Summary  
1.A Boolean expression evaluates to  
 either  True  or False 
 
2. A Boolean expression is made up of 
compar"
"isons that are either True  or 
False  
 
3. The and, or, not operations combine 
Boolean values.  
 
4. Various if constructions can be used to 
organize conditional execution.  
 "
"STRING MANIPULATION,
GUESS -and-CHECK, 
APPROXIMATIONS, 
BISECTION
(download slides and . pyfiles ĂŶĚ follow along!)
6.0001 LECTURE 3
6.0001 LECTURE 3 1LAST TIME
strings
branching –if/elif/else
while loops
for loops
6.0001 LECTURE 3 2TODAY
string manipulation
guess and check algorithms
approximate solutions
bisection method
6.0001 LECTURE 3 3STRINGS
think of as a sequence of case sensitive characters
can compare strings with ==, >, < etc .
len()is a function used to retrieve the length of the 
s"
"tring in the parentheses
s = ""abc""
len(s) evaluates to 3
6.0001 LECTURE 3 4STRINGS
square brackets used to perform indexing into a string 
to get the value at a certain index/position
s = ""abc""
s[0] evaluates to ""a""
s[1] evaluates to ""b""
s[2] evaluates to ""c""
s[3] trying to index out of bounds, error
s[-1] evaluates to ""c""
s[-2] evaluates to ""b""
s[-3] evaluates to ""a""
6.0001 LECTURE 3 5index :   0  1 2     indexing always starts at 0
index :   -3 -2 -1    last element always at index -1STRINGS
c"
"an slice strings using [start:stop:step ]
if give two numbers, [ start:stop ], step=1 by default
you can also omit numbers and leave just colons
6.0001 LECTURE 3 6s = ""abcdefgh ""
s[3:6] evaluates to ""def"", same ass[3:6:1]
s[3:6:2]evaluates to ""df""
s[::] evaluates to ""abcdefgh "", same as s[0:len(s):1]
s[::-1]evaluates to ""hgfedbca "", same as s[-1:-(len(s)+1): -1]
s[4:1:-2]evaluates to ""ec""STRINGS
strings are “ immutable ” –cannot be modified 
s = ""hello""
s[0] = 'y' gives an error
s = 'y'+s[1:len(s)]"
" is allowed,
s bound to new object
6.0001 LECTURE 3 7s""hello""
""yello""for LOOPS RECAP
for loops have a loop variable that iterates over a set of 
values
for varin range(4):   var iterates over values 0,1,2,3
<expressions> expressions inside loop executed 
with each value for var
for varin range(4,6): var iterates over values 4,5
<expressions>
range is a way to iterate over numbers, but a for loop 
variable can iterate over any set of values , not just numbers!
6.0001 LECTURE 3 8STRINGS AND LOOPS
these"
" two code snippets do the same thing
bottom one is more “ pythonic ” 
s = ""abcdefgh ""
for index in range( len(s)):
if s[index] == ' i' or s[index] == 'u':
print(""There is an ior u"")
for char in s:
if char == ' i' or char == 'u':
print(""There is an ior u"")
6.0001 LECTURE 3 9CODE EXAMPLE: 
ROBOT CHEERLEADERS
an_letters = ""aefhilmnorsxAEFHILMNORSX ""
word = input(""I will cheer for you! Enter a word: "")
times = int(input(""Enthusiasm level (1 -10): ""))
i= 0
while i< len(word):
char = word[ i]
if char in an_lette"
"rs :
print(""Give me an "" + char + ""! "" + char)
else:
print(""Give me a  "" + char + ""! "" + char)
i+= 1
print(""What does that spell ?"")
for iin range(times):
print(word , ""!!!"")
6.0001 LECTURE 3 10for char in word:EXERCISE
s1 = ""mitu rock""
s2 = ""irule mit""
if len(s1) == len(s2):
for char1 in s1:
for char2 in s2:
if char1 == char2:
print(""common letter"")
break
6.0001 LECTURE 3 11GUESS -AND -CHECK
the process below also called exhaustive enumeration
given a problem…
you are able to guess a value for solution
"
"you are able to check if the solution is correct
keep guessing until find solution or guessed all values
6.0001 LECTURE 3 12GUESS -AND -CHECK 
–cube  root
cube = 8
for guess in range(cube+1):
if guess**3 == cube:
print(""Cube root of"", cube, ""is"", guess)
6.0001 LECTURE 3 13GUESS -AND -CHECK 
–cube  root
cube = 8
for guess in range(abs(cube)+1):
if guess**3 >= abs(cube):
break
if guess**3 != abs(cube):
print(cube , 'is not a perfect cube')
else:
if cube < 0:
guess = -guess
print('Cube root of '+str(cube)+' "
"is '+str(guess))
6.0001 LECTURE 3 14APPROXIMATE SOLUTIONS
good enough solution
start with a guess and increment by some small value
keep guessing if |guess3-cube| >= epsilon
for some small epsilon
decreasing increment size slower program
increasing epsilon less accurate answer
6.0001 LECTURE 3 15APPROXIMATE SOLUTION 
–cube root
cube = 27
epsilon = 0.01
guess = 0.0
increment = 0.0001
num_guesses = 0
while abs(guess** 3 -cube) >= epsilon:
guess += increment
num_guesses += 1
print('num_guesses =', num_g"
"uesses )
if abs(guess** 3 -cube) >= epsilon:
print('Failed on cube root of', cube)
else:
print(guess, 'is close to the cube root of', cube)and guess <= cube :
6.0001 LECTURE 3 16BISECTION SEARCH
half interval each iteration
new guess is halfway in between
to illustrate, let’s play a game!
6.0001 LECTURE 3 17GUESS
GUESS
GUESSBISECTION SEARCH 
–cube root
cube= 27
epsilon = 0.01
num_guesses = 0
low = 0
high = cube
guess = (high + low )/2.0
while abs(guess**3 -cube) >= epsilon:
if guess**3 < cube :
low = gue"
"ss
else:
high = guess
guess = (high + low)/2.0
num_guesses += 1
print 'num_guesses =', num_guesses
print guess, 'is close to the cube root of', cube
6.0001 LECTURE 3 18BISECTION SEARCH 
CONVERGENCE
search space
◦first guess: N/2
◦second guess: N/4
◦kth guess: N/2k
guess converges on the order of log2Nsteps
bisection search works when value of function varies 
monotonically with input
code as shown only works for positive cubes > 1 –why?
challenges modify to work with negative cubes!
modify to work wi"
"th x < 1!
6.0001 LECTURE 3 19x< 1
if x < 1, search space is 0 to x but cube root is greater 
than x and less than 1
modify the code to choose the search space 
depending on value of x
6.0001 LECTURE 3 20MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"4. Modules and Functions  
Topics:  
 
 Modules  
 Using import 
 Using functions from  math  
 A first look at defining functions  
 
 
 The Usual Idea of a Function  
 
 
 
          sqrt 
 
 9 3 
A factory that has inputs and builds outputs.  Why are Functions So Important?  
One reason is that they hide detail and  
enable us to think at a higher level.  
 
Who wants to think about how to 
compute square roots in a calculation that  
involves other more challenging things?  
 
r = (sqrt(250+110* sqrt(5)"
")/20)*E  The Process of Implementation  
To implement  a function is to package a  
computational idea in a way that others  
can use it.  
 
We use the example of square root to  
illustrate this.  It Starts with an Insight  
The act of computing the square root  
of a number  x is equivalent to building a  
square whose area is x.  
 
If you can build that square and measure  
its side, then you have sqrt(x). Making a Given Rectangle  
“More Square”  
L  x/L = W  
How can we make this rectangle “ more squ"
"are ”  
while preserving its area?  Observation  
If the square and rectangle  have area x,  then  
we see that  the sqrt(x) is in between L and W . Recipe for an Improved L  
L x/L 
L = (L+x/L)/2      
x/L L 
Take the  
average of the  
length and width  Repeat and Package  
x L L = x 
L = (L+x/L)/2 
L = (L+x/L)/2 
L = (L+x/L)/2 
L = (L+x/L)/2 
L = (L+x/L)/2 
In comes x, the “raw material”.  
A square root is fabricated and shipped.  Repeat and Package  
x L L = x 
L = (L+x/L)/2 
L = (L+x/L)/2 
L = (L+x/L)"
"/2 
L = (L+x/L)/2 
L = (L+x/L)/2 
How do we make something like        in Python?  
 
We talk about “built in” functions first.      Talking About Functions  
A function has a name and arguments.  
m = max( x,y) 
name  arguments  
We say that   max(x,y) is a function call . Built-in Functions  
 
The list of “built -in” Python functions  is quite 
short.  
 
Here are some of the ones that require  
numerical arguments:  
 
                  max,  min, abs, round  
   
 
 
 abs(-6) is 6       max( -3,2) is 2"
"       min(9, -7) is -7 
round(6.3) is 6.0    round(3.5) is 4.0    round( -6.3) is -6.0  Calling  Functions  
 
>>> a = 5  
>>> b = 7  
>>> m = max(a** b,b**a) 
>>> diff = abs( a**b–b**a)                   
 
In a function call, arguments can be expressions.  
Thus, the value of the expression  a**b–b**a 
is passed as an argument to abs. Functions in Mathematics vs 
Functions in Python  
 
So far our examples look like the kind of  
functions that we learn about in math.  
 
 “In comes one or more numbers a"
"nd out  
 comes a number.”  
 
However, the concept is more general in  
computing as we will see throughout the course.  
  
 
 >>> a = 5  
>>> b = 6  
>>> c = 7  
>>> d = 8  
>>> m = max(a** d,d**a,b**c,c**b) 
>>> n = max(a*b*c*d,500)  The Number of Arguments is  
Sometimes Allowed to Vary  
The max function can have an arbitrary number of arguments   The Built -In Function len 
A function can have a string argument.  >>> s = ‘ abcde’ 
>>> n = len(s) 
>>> print n  
5 
“In comes a string and out comes its "
"length (as an int)”   Functions and Type  
Sometimes a function only accepts arguments of  
a certain type. E.g., you cannot pass an int 
value to the function len: 
>>> x = 10  
>>> n = len(x) 
TypeError : Object of the type int 
                has no len() Functions and Type  
On the other hand, sometimes a function is  
designed to be flexible regarding the type  
of values it accepts:  
>>> x = 10  
>>> y = 7.0  
>>> z = max( x,y) 
Here, max is returning the larger of two values  
and it does not care "
"if one has type int and the  
other has type float.  Type -Conversion  Functions  
Three important built -in functions convert types:  
int, float , and str. 
 
 >>> a = float(22)/float(7)  
>>> a 
3.142857142857143  
>>> b = int(100*a) 
>>> b 
314 
>>> c = '100*pi = ' + str(b) 
>>> c 
'100*pi = 314'  
        Some Obvious Functions are not 
in the “Core” Python Library!  
>>> x = 9  
>>> y = sqrt(x) 
NameError : name ‘ sqrt’ not defined  
 
How can we address this issue?  Modules  
A way around this is to "
"import  functions (and  
other things you may need) from “modules” that  
have been written by experts.  
 
Recall that a module  is a file that contains  
Python code.  
 
That file can include functions that can be  
imported for your use.  Widely -Used Modules  
A given Python installation typically comes  
equipped with a collection of standard modules  
that can be  routinely accessed.  
 
Here are some that we will use in CS 1110:  
 
  math  numpy urllib2 
  string scipy PIL 
  random timeit datetime"
"  
 
 The CS1110  Plan for Learning 
about Functions in Python  
1. Practice  using the math  module. Get solid with 
the import mechanism.  
 
2. Practice  using the SimpleMath  module. Get 
solid with how functions are defined.  
 
3. Practice  designing and using your own “math -
like” functions.  The Plan Cont’d  
4. Practice  using the SimpleGraphics  module. 
Get solid using procedures that produce 
graphical output.  
 
5. Practice  using methods from the string class.  
 
6. Practice using simple cl"
"asses as a way to solid 
with methods that can be applied to objects.  
   (Several weeks away.)  
 Procedures and Methods are special types of functions.  The Plan Cont’d  
Over the entire semester we keep revisiting the  
key ideas to see how they play out in more  
complicated situations.  
 
All along the way we develop skills for  
  1.  Designing Functions  
  2. Testing Functions  
 
 Part Art, Part Science, Part Engineering. That’s Software Engineering   By Analogy  
Tricycle in the Driveway. And th"
"en … 
Tricycle on the sidewalk. And then … 
2-wheeler w/ trainers. And then … 
2-wheeler no turning. And then … 
2-wheeler and turning in street. And then … 
2-wheeler w/ derailleur. And eventually … 
Tour de France!  
 
 
  Learn by Doing   from math import sqrt 
        : 
r = (sqrt(250+110* sqrt(5))/20)*E  
        : Let’s Start by Revisiting  
 import  
MyModule.py  If you want  to use the square root function  
from the math module, then it must be imported:  Useful functions in  math 
ceil(x)   the sm"
"allest integer >= x  
floor(x)   the largest integer <= x  
sqrt(x)  the square root of x  
exp(x)   e**x where e = 2.7182818284…  
log(x)   the natural logarithm of x  
log10(x)   the base -10 logarithm of x  
sin(x)   the sine of x (radians)  
cos(x)  the cosine of x (radians)  
 Legal:   from math import sin,cos,exp,log    math.floor , math.ceil , 
round, int 
Let’s look at what these functions do and  
the type of the value that  they return.  
 
Note: round and int are part of basic python — 
no need t"
"o have them imported.  math.floor , math.ceil , 
round, int 
  x   math.floor (x) math.ceil (x)  round(x) int(x) 
-------------------------------------------------  
 2.9     2.0           3.0          3.0      2  
 2.2     2.0           3.0          2.0      2  
  2      2.0           2.0          2.0      2  
 2.5     2.0           3.0          3.0      2  
-3.9    -4.0          -3.0         -4.0     -3 
-3.2    -4.0          -3.0         -3.0     -3 math.floor , math.ceil , 
round, int 
These functions a"
"ll return values of type float:  
 
 math.floor (x)      largest integer <= x 
 math.ceil (x)      smallest integer >= x 
 round(x)        nearest integer to x 
 
This function returns a value of type int: 
 
 int(x)        round towards 0  
 Finding Out What’s in a Module?  
If a module is part of your Python installation,  
then you can find out what it contains like this:  
 
>>> help(‘random’)  
But if the module is “famous” (like all the ones  
we will be using), then just Google it.  
 
 
 What’s in a"
" Module?  
If you  know the name of a particular function  
and want more information:  
 
>>> help(‘ math.sqrt ’) 
What’s With the “dot” Notation:   math.sqrt ?   from math import *  
        : 
r = (sqrt(250+110* sqrt(5))/20)*E  
x = cos(pi*log(r)) 
        : Need Stuff from a Module? 
Method 1  
MyModule.py  
This is handy. You now have permission to use everything  
in the math module by its name.  However, this can open the 
door to name conflict if the imported module is big like math.   import math  "
"
        : 
r = (math.sqrt (250+110* math.sqrt (5))/20)*E  
x = math.cos (math.pi*math.log (r)) 
        : Need Stuff from a Module?  
Method 2.  
MyModule.py  
You again have permission to use everything in the math 
module by its name.  But you must use its “full name” and that  
involves  using the “dot notation.”    from math import sqrt, pi, cos, log 
        : 
r = (sqrt(250+110* sqrt(5))/20)*E  
x = cos(pi*log(r)) 
        : Need Stuff from a Module?  
Method 3.  
MyModule.py  
Here you take only wha"
"t you need from the source module.  
You get to use “nice” names without using the dot notation. 
The danger of name conflicts minimized because you are 
explicitly aware of what is imported.   Appreciating “Full Names”   
import M1  
import M2  
import M3    
     :         
 
 
 
 
                            
 
 
 
 
                            
 
 
 
 
                    Your code                      M1     M2     M3    
Unambiguous names in your code even if some  
of the module functions have the sa"
"me name.     Appreciating “Full Names”   
from M1 import *  
from M2 import *  
from M3 import *    
     :         
 
 
 
 
                            
 
 
 
 
                            
 
 
 
 
                    Your code                      M1     M2     M3    
Now function calls in your code can be ambiguous.  
Easy to lose track of things if M1, M2, and M3 
include tons of functions . Appreciating “Full Names”   
from M1 import f1  
from M2 import f2  
from M3 import f2    
     :         
 
 
 
"
" 
                            
 
 
 
 
                            
 
 
 
 
                    Your code                      M1     M2     M3    
Selective importing is ok since you are “on top of”  
exactly what is being imported. And you can  
use the short name, e.g., f1 instead of M1.f1 The time has come to see how functions are  
actually defined.  
 
To do this we introduce a small “classroom”  
module that we call SimpleMath . Building Your Own Functions   Visualizing SimpleMath.py  
Recall that  
"
"a module is  
simply a . py file 
that contains  
Python code.  
 
This particular  
module houses 
three functions:  
sqrt , sin, and cos SimpleMath.py  
 
 
 
 
 
 
 
                  sqrt 
sin  
cos  How are Functions Defined?  
 I can drive a car without knowing what is under the hood.    Let’s look at the three function definitions  
in SimpleMath  not worrying (for now) about  
their inner workings.  
 
This plays nicely with the following fact:  
you can use a function without understanding  
how it"
" works.  
 A Square Root Function  
The function  
header begins  
with def. 
 
It indicates the  
name of the  
function and  
its arguments.  
 
Note the colon  
and indentation.  def sqrt(x): 
    x = float(x)  
    L = x  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    return L                                      A Square Root Function  
This is the body of 
the function.  
 
It computes a value 
L (hopefully a good 
square root.)  
 
T"
"he calling program 
will be informed of 
this value because  
of the return 
statement.  def sqrt(x): 
    x = float(x)  
    L = x  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    return L   
 
 
 
 
 
 
 
 
                                                    The Cosine and Sine Functions  
def cos(x): 
    x = float(x)  
    y = 1.0-(x**2/2)+(x**4/24) -(x**6/720)  
    return y  
def sin(x):  
    x = float(x)  
    y = x-(x**3/6)+(x**5/12"
"0) -(x**7/5040)  
    return y  
They too have headers  
 DO NOT WORRY ABOUT THE MATH. THIS IS ABOUT THE STRUCTURE  
OF PYTHON FUNCTIONS    The Cosine and Sine Functions  
def cos(x): 
    x = float(x)  
    y = 1.0-(x**2/2)+(x**4/24) -(x**6/720)  
    return y  
def sin(x):  
    x = float(x)  
    y = x-(x**3/6)+(x**5/120) -(x**7/5040)  
    return y  
They too have bodies  Fruitful Functions  
All three of these functions are fruitful  
functions.  
 
Fruitful functions return a value.  
 
Not all functi"
"ons are like that.  
 
We will discuss the mechanics of how fruitful  
functions return values later.  Making Functions Usable  
Again, the great thing about functions in 
programming is that you can use a function 
without understanding how it works.  
However, for this to be true the author(s) of 
the function must communicate how -to-use 
information through docstrings  and comments. 
There are rules for doing this . Rule 1. The Module Starts With  
Authorship Comments  
# SimpleMath.py  
# Lady Gaga (lg"
"123)  
# January 2, 2016  
"""""" Module to illustrate three simple  
math-type functions.  
 
Very crude implementations for the  
square root, cosine, and sine  
functions.""""""  
Module Name, author(s), last -modified date . 
And we follow that format in CS 1110.  Rule 2. The Module 
Specification  
# SimpleMath.py  
# Lady Gaga (lg123)  
# January 2, 2016  
"""""" Module to illustrate three simple  
math-type functions.  
 
Very crude implementations for the  
square root, cosine, and sine  
functions. """""" 
 If"
" the module SimpleMath.py  is in the home directory, then by typing  
help(‘SimpleMath ’) the “purple comments” and more will pop up    Rule 3. Each Function Starts 
with a Docstring  “Specification’’  
def sqrt(x): 
     """"""Returns an approximate square  
     root of x.  
     
     Performs five steps of rectangle  
     averaging.  
     
     Precondition: The value of x is a  
 positive number.""""""  
Short summary that states what  the function 
returns. Also called the post condition.   
 Rule 3. Each"
" Function Starts 
with a Docstring  “Specification’’  
def sqrt(x): 
     """"""Returns an approximate square  
     root of x . 
     
     Performs five steps of rectangle  
     averaging.  
     
     Precondition: The value of x is a  
 positive number.""""""  
Longer prose giving further useful information  
to the person using the function.   
 Rule 3. Each Function Starts 
with a Docstring  “Specification’’  
def sqrt(x): 
     """"""Returns an approximate square  
     root of x . 
     
     Performs five "
"steps of rectangle  
     averaging.  
     
     Precondition: The value of x is a  
 positive number ."""""" 
Conditions that the arguments must satisfy  
if the function is to work. Otherwise, no guarantees.   
 Specifications for cos and sin 
def cos(x): 
     """"""Returns an approximation to the  
 cosine of x.  
     
     PreC: x is a number that  
 represents a radian value.""""""  
def sin(x):  
     """"""Returns an approximation to the  
 sine of x.  
     
     PreC: x is a number that  
 represents a radi"
"an value.""""""  Now let’s compare these three functions  
in the SimpleMath  module with their  
counterparts in the math  module.  Check out Square Root  
import math  
import SimpleMath  
            : 
x = input('x = ')  
MySqrt = SimpleMath.sqrt (x) 
TrueSqrt  = math.sqrt (x) 
            : ShowSimpleMath.py  Check out Square Root  
x = 25 
SimpleMath.sqrt (x) =   5.00002318  
      math.sqrt (x) =   5.00000000  Sample Output…  Check out Cosine and Sine  
import math  
import SimpleMath  
           : 
th"
"eta = input('theta (degrees) = ')  
theta = ( math.pi*theta)/180  
MyCos = SimpleMath.cos(theta)  
TrueCos = math.cos(theta)  
MySin = SimpleMath.sin(theta)  
TrueSin = math.sin(theta)  
           : ShowSimpleMath.py  Check out Cosine and Sine  
Sample Output…  
theta (degrees) = 60  
SimpleMath.cos(theta) =   0.49996457  
      math.cos(theta) =   0.50000000  
SimpleMath.sin(theta) =   0.86602127  
      math.sin(theta) =   0.86602540  Summary of What You Need to 
Know  
1.How to gain access to functions "
"in other  
modules using import . 
 
2. How to define a function using def. 
 
3. How to document modules and functions  
through structured doc strings.  "
"DECOMPOSITION, 
ABSTRACTION, 
FUNCTIONS
(download slides and . pyfiles ĂŶĚ follow along!)
6.0001 LECTURE 4
6.0001 LECTURE 4 1LAST TIME
while loops vs for loops
should know how to write both kinds
should know when to use them
guess -and-check and approximation methods
bisection method to speed up programs
6.0001 LECTURE 4 2TODAY
structuring programs and hiding details
functions
specifications
keywords: return vs print
scope
6.0001 LECTURE 4 3HOW DO WE WRITE CODE?
so far…
•covered language mechani"
"sms
•know how to write different files for each computation
•each file is some piece of code
•each code is a sequence of instructions
problems with this approach
•easy for small -scale problems
•messy for larger problems
•hard to keep track of details
•how do you know the right info is supplied to the right 
part of code
6.0001 LECTURE 4 4GOOD PROGRAMMING
more code not necessarily a good thing
measure good programmers by the amount of 
functionality
introduce functions
mechanism to achieve decompositio"
"n and abstraction
6.0001 LECTURE 4 5EXAMPLE –PROJECTOR
a projector is a black box
don’t know how it works
know the interface: input/output
connect any electronic to it that can communicate 
with that input
black box somehow converts image from input source 
to a wall, magnifying it
ABSTRACTION IDEA : do not need to know how 
projector works to use it
6.0001 LECTURE 4 6EXAMPLE –PROJECTOR
projecting large image for Olympics decomposed into 
separate tasks for separate projectors
each projector takes i"
"nput and produces separate 
output
all projectors work together to produce larger image
DECOMPOSITION IDEA : different devices work 
together to achieve an end goal
6.0001 LECTURE 4 7APPLY THESE CONCEPTS
6.0001 LECTURE 4 8TO PROGRAMMING!CREATE STRUCTURE with 
DECOMPOSITION
6.0001 LECTURE 4 9in projector example, separate devices
in programming, divide code into modules 
•are self-contained
•used to break up code
•intended to be reusable
•keep code organized
•keep code coherent
this lecture, achieve dec"
"omposition with functions
in a few weeks, achieve decomposition with classesSUPRESS DETAILS with 
ABSTRACTION
6.0001 LECTURE 4 10in projector example, instructions for how to use it are 
sufficient, no need to know how to build one
in programming, think of a piece of code as a black box
•cannot see details
•do not need to see details
•do not want to see details
•hide tedious coding details
achieve abstraction with function specifications or 
docstringsFUNCTIONS
write reusable pieces/chunks of code, cal"
"led functions
functions are not run in a program until they are 
“called ” or “ invoked ” in a program
function characteristics:
•has a name
•has parameters (0 or more)
•has a docstring (optional but recommended)
•has a body
•returns something
6.0001 LECTURE 4 11defis_even( i):
""""""
Input: i, a positive int
Returns True if iis even, otherwise False
""""""
print(""inside is_even"")
return i%2 == 0
is_even(3)HOW TO WRITE and 
CALL/INVOKE A FUNCTION
6.0001 LECTURE 4 12defis_even( i):
"""""" 
Input: i, a positive int
"
"Returns True if iis even, otherwise False
""""""
print(""inside is_even"")
return i%2 == 0IN THE FUNCTION BODY
6.0001 LECTURE 4 13deff( x ):
x = x + 1
print('in f(x): x =', x)
return x
x = 3
z = f( x )formal parameter gets bound to the value of 
actual parameter when function is called 
new scope/frame/environment created when enter a function
scope is mapping of names to objectsVARIABLE SCOPE
6.0001 LECTURE 4 14deff( x ):
x = x + 1
print('in f(x): x =', x)
return x
x = 3
z = f( x )VARIABLE SCOPE
6.0001 LECTU"
"RE 4 15Global scope
f
x
zSome 
codef scope
x3
3VARIABLE SCOPE
6.0001 LECTURE 4 16Global scope
f
x
zSome 
codef scope
x4
3deff( x ):
x = x + 1
print('in f(x): x =', x)
return x
x = 3
z = f( x )VARIABLE SCOPE
6.0001 LECTURE 4 17Global scope
f
x
zSome 
code
3f scope
x4deff( x ):
x = x + 1
print('in f(x): x =', x)
return x
x = 3
z = f( x )returns 4VARIABLE SCOPE
6.0001 LECTURE 4 18Global scope
f
x
zSome 
code
3
4deff( x ):
x = x + 1
print('in f(x): x =', x)
return x
x = 3
z = f( x )ONE WARNING IF NO 
return STA"
"TEMENT
defis_even( i):
"""""" 
Input: i, a positive int
Does not return anything
""""""
i%2 == 0
Python returns the value None, if no return given
represents the absence of a value
6.0001 LECTURE 4 19return vs.        print
return only has meaning 
inside a function
only one return executed 
inside a function
code inside function but 
after return statement not 
executed
has a value associated 
with it, given to function 
callerprint can be used outside
functions
can execute many print 
statements inside "
"a function
code inside function can be 
executed after a print 
statement
has a value associated with 
it, outputted to the console
6.0001 LECTURE 4 20FUNCTIONS AS ARGUMENTS
arguments can take on any type, even functions
6.0001 LECTURE 4 21deffunc_a():
print 'inside func_a'
deffunc_b(y):
print 'inside func_b'
return y
deffunc_c(z):
print 'inside func_c'
return z()
print func_a()
print 5 + func_b(2)
print func_c(func_a)FUNCTIONS AS ARGUMENTS
6.0001 LECTURE 4 22deffunc_a():
print 'inside func_a'
deffunc_b("
"y):
print 'inside func_b'
return y
deffunc_c(z):
print 'inside func_c'
return z()
print func_a()
print 5 + func_b(2)
print func_c(func_a)Global scope
func_a
func_b
func_cSome 
code
Some 
code
Some 
codefunc_a scope
returns None NoneGlobal scope
func_a
func_b
func_cFUNCTIONS AS ARGUMENTS
6.0001 LECTURE 4 23deffunc_a():
print 'inside func_a'
deffunc_b(y):
print 'inside func_b'
return y
deffunc_c(z):
print 'inside func_c'
return z()
print func_a()
print 5 + func_b(2)
print func_c(func_a)Some 
code
Some 
code
S"
"ome 
codefunc_b scope
y 2
returns 2None
7Global scope
func_a
func_b
func_cFUNCTIONS AS ARGUMENTS
24deffunc_a():
print 'inside func_a'
deffunc_b(y):
print 'inside func_b'
return y
deffunc_c(z):
print 'inside func_c'
return z()
print func_a()
print 5 + func_b(2)
print func_c(func_a)Some 
code
Some 
code
Some 
codefunc_c scope
zfunc_a
func_a scope
returns None
returns NoneNone
7
6.0001 LECTURE 4Noneinside a function, can access a variable defined outside
inside a function, cannot modify a variable defined 
o"
"utside --can using global variables , but frowned uponSCOPE EXAMPLE
6.0001 LECTURE 4 25defg(y):
print(x)
print(x + 1)
x = 5
g(x)
print(x)defh(y):
x += 1
x = 5
h(x)
print(x)deff(y):
x = 1
x += 1
print(x)
x = 5
f(x)
print(x)inside a function, can access a variable defined outside
inside a function, cannot modify a variable defined 
outside --can using global variables , but frowned uponSCOPE EXAMPLE
6.0001 LECTURE 4 26defg(y):
print(x)
x = 5
g(x)
print(x)defh(y):
x += 1
x = 5
h(x)
print(x)deff(y):
x = 1
x +"
"= 1
print(x)
x = 5
f(x)
print(x)HARDER SCOPE EXAMPLE
Python Tutor is your best friend to 
help sort this out!
http ://www.pythontutor.com /IMPORTANT 
and
TRICKY!
6.0001 LECTURE 4 27defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x
x = 3
z = g(x)SCOPE DETAILS
Global scope
g
x
zSome 
code
3
6.0001 LECTURE 4 28SCOPE DETAILS
gscope
x 
hSome 
code3
6.0001 LECTURE 4 29Global scope
g
x
zSome 
code
3defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x
x = 3
z = g(x)SCOPE DETAILS
g"
"scope
x 
hSome 
code34
6.0001 LECTURE 4 30Global scope
g
x
zSome 
code
3defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x
x = 3
z = g(x)SCOPE DETAILS
Global scope
g
x
zSome 
code
3gscope
x 
hSome 
code3hscope
x
“abc” 4
6.0001 LECTURE 4 31defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x
x = 3
z = g(x)returns NoneSCOPE DETAILS
g scope
x 
hSome 
code
None4
6.0001 LECTURE 4 32Global scope
g
x
zSome 
code
3defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x"
"
x = 3
z = g(x)returns 4SCOPE DETAILS
6.0001 LECTURE 4 33Global scope
g
x
zSome 
code
3
4defg(x):
defh():
x = 'abc'
x = x + 1
print('g: x =', x)
h()
return x
x = 3
z = g(x)DECOMPOSITION & 
ABSTRACTION
powerful together
code can be used many times but only has to be 
debugged once!
6.0001 LECTURE 4 34MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu"
/terms .
"5. Introduction to Procedures  
Topics:  
 
 The module SimpleGraphics   
 Creating and Showing figures  
 Drawing Rectangles, Disks, and Stars  
 Optional arguments  
 Application Scripts  
  
 
 Procedures  
We continue our introduction to functions 
with a focus on procedures.  
 
Procedures are functions that do not 
return a value.  
 
Instead, they  “do something.”  
 
Graphics is a good place to illustrate the 
idea. 
 
  
 The Module SimpleGraphics  
Has Eight Procedures  
 
 
 
 
 
 
 
 
 
 
 
 
 
"
" 
 MakeWindow  
ShowWindow  
DrawRect  
DrawDisk  
DrawStar  SimpleGraphics.py  
We will use this  
module to make  
designs that  
involve  
rectangles,  
disks , stars, etc  DrawLineSeg  
Title DrawText  Examples  
Looks like we will be able to draw tilted rectangles  Example  
How  
does  
color  
work?  What  
if we  
had  
100 rows  
each with  
100 stars ?  
Anticipating loops.   Example  
Xeno’s  Paradox: Will we ever reach the right edge?   Example  
White Rectangle + Red Rectangle + White Disk + Re"
"d Disk +  Tilted White Star   Example  
Let’s write a function to draw this:  
And then apply it two times:  
Functions calling other functions.   
After We Learn About Iteration…  
What if there were billions and billions of stars? Will need loops.   After We Learn About Iteration…  
How long before the square is covered? Need loops.   After We Learn About Recursion…  
Random Mondrian. Repeatedly cut a rectangle into 4 smaller rectangles.   
We now show how to use the eight procedures 
in SimpleGraphics : "
"
 
  MakeWindow  
  ShowWindow  
  DrawRect  
  DrawDisk  
  DrawStar  
  DrawLineSeg  
  DrawText  
        Title 
 A Quick Tour Through the 
SimpleGraphics  Module  
Each of these  
procedures has several  
“options.” We do not  
cover everything in the  
lecture slides. Labs and  
demo scripts cover 
these procedures in 
greater detail.  
 First: Create a Figure Window   
You cannot create any designs until you  
have a figure into which you can “drop”  
rectangles, disks, and stars.  
 MakeWindow  
from"
" SimpleGraphics  import *  
n = 5 
MakeWindow (n) 
Here we have created  
a figure with labeled axes  
that is ready to display  
things in the square defined  
by  
 -5<=x<=+5, -5<=y<=5  
 MakeWindow  
from SimpleGraphics  import* 
n = 5 
MakeWindow (n,bgcolor =PURPLE)  
The “default” is to “paint”  
the figure window white.  
 
So this is what you must  
do to set the background  
color to something  
different.  
 
 
 
MakeWindow  
from SimpleGraphics  import* 
n = 5 
MakeWindow (n,labels =False) 
The “d"
"efault” is to label  
the axes.  
 
So this is what you must  
do to suppress the  
labeling.  
 
 
 
We are using import * to save space and because it is such a tiny module.   Color in simpleGraphics  
The module has thirteen “built -in” colors.  
 
If a SimpleGraphics  procedure wants a color,  
just “hand over” one of these:  
 
YELLOW PURPLE CYAN  ORANGE 
RED  BLUE  GREEN MAGENTA 
PINK  WHITE BLACK  LIGHTGRAY  
   DARKGRAY  
There is more flexibility than this. More later.   MakeWindow  
from SimpleGra"
"phics  import* 
n = 5 
MakeWindow (n,labels =False,bgcolor =ORANGE)  
You can turn off labeling  
and specify a color  
in the same call to  
MakeWindow . 
 
Optional Arguments  
The function MakeWindow  has four arguments.  
 
Three of the arguments are “optional”.  
 
When there are several optional arguments,  
their order is immaterial. These are equivalent:  
 
  MakeWindow (n,labels =False,bgcolor =ORANGE)  
  MakeWindow (n,bgcolor =ORANGE,labels =False)  
 
 
Note: You need the “assignment” for an op"
"tional argument.  
  This is illegal: MakeWindow (5,False,ORANGE)  Let’s Draw a Rectangle  
with DrawRect  
You must tell DrawRect   
 
       - the center of the rectangle.  
       - the horizontal dimension of the rectangle  
 - the vertical dimension of the rectangle  
 
You have the option of telling DrawRect   
 
 - the fill color  
 - the width of the perimeter highlight  
 - the color of the perimeter highlight  
 - the rotation angle  
  DrawRect  
from SimpleGraphics  import* 
MakeWindow (5,bgcolo"
"r=YELLOW)  
x=0; y=0; L=5; W=3  
DrawRect (x,y,L,W) 
ShowWindow () 
The default is a rectangle  
with no fill color. So all you  
get is the perimeter.  
 
Nothing is  
actually displayed  
until this command  
is executed. More  
later.  DrawRect  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; L=5; W=3  
DrawRect (x,y,L,W,FillColor =MAGENTA)  
ShowWindow () 
Use the optional color  
argument to specify a fill  
color. 
 
DrawRect  
from simpleGraphics  import* 
MakeWindow (5,bgcol"
"or=YELLOW)  
x=0; y=0; L=5; W=3  
DrawRect (x,y,L,W,FillColor =MAGENTA,EdgeWidth =6) 
ShowWindow () 
Use the optional EdgeWidth  
argument to specify the  
boldness of the perimeter  
highlight. The default  
is EdgeWidth  = 1 
 
If you don’t want any perimeter highlight, set EdgeWidth =0 DrawRect  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; L=5; W=3  
DrawRect (x,y,L,W,color =MAGENTA,theta =30) 
ShowWindow () 
Use the optional theta 
argument to specify the  
counterclockwise r"
"otation  
of the rectangle about its  
center. (Angle in degrees.)  
 
The default rotation angle is zero.  
Let’s Write a Script to Do This  
The squares are 9x9, 7x7, 5x5, 3x3, and 1x1.  Nested Squares  
DrawRect (0,0,9,9,FillColor=MAGENTA,  
                            EdgeWidth =10) 
DrawRect  
DrawRect (0,0,7,7,FillColor=CYAN,  
             EdgeWidth =8) Nested Squares  
DrawRect (0,0,5,5,FillColor=YELLOW,  
                  EdgeWidth =6) DrawRect  
DrawRect (0,0,3,3,FillColor=PURPLE,  
             "
"      EdgeWidth =4) Nested Squares  
DrawRect (0,0,1,1,EdgeWidth=5)  Nested Squares  
MakeWindow (6,bgcolor=WHITE)  
  
DrawRect (0,0,9,9,FillColor=MAGENTA,  
                           EdgeWidth =10) 
DrawRect (0,0,7,7,FillColor=CYAN,  
                           EdgeWidth =8) 
DrawRect (0,0,5,5,FillColor=YELLOW,  
                           EdgeWidth =6) 
DrawRect (0,0,3,3,FillColor=PURPLE,  
                           EdgeWidth =4) 
DrawRect (0,0,1,1,EdgeWidth=5)  
 
ShowWindow () Let’s Draw a Disk  
wit"
"h DrawDisk  
You must tell DrawDisk   
 
       - the center of the disk.  
       - the radius of the disk  
 
You have the option of telling DrawDisk   
 
 - the fill color  
 - the width of the perimeter highlight  
 - the color of the perimeter highlight  
  DrawDisk  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawDisk (x,y,r) 
ShowWindow () 
The default is a circle  
with no fill color. So all you  
get is the perimeter.  
 
DrawDisk  
from SimpleGraphics  import* 
M"
"akeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawDisk (x,y,r,FillColor =MAGENTA)  
ShowWindow () 
Use the optional color  
argument to specify a fill  
color. 
 
DrawDisk  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawDisk (x,y,r,FillColor =MAGENTA,EdgeWidth =6) 
ShowWindow () 
Use the optional EdgeWidth  
argument to specify the  
boldness of the perimeter  
highlight. The default  
is EdgeWidth  = 1 
 
If you don’t want any perimeter highlight, set EdgeWidth =0 
Let’"
"s Draw This  
Rules:  
 
Big circle center at ( -4,0)  
with radius 4.  
 
Circles are tangent  to each  
other. Centers  on x -axis. 
 
Each circle has half the  
radius of its left neighbor.  Draw the First Disk  
x = -4 
r = 4 
DrawDisk (x,0,r,FillColor= MAGENTA,EdgeWidth =0) 
Draw the Second Disk  
x = x + 1.5*r  
r = r/2 
DrawDisk (x,0,r,FillColor= CYAN,EdgeWidth =0) 
Draw the Third Disk  
x = x + 1.5*r  
r = r/2 
DrawDisk (x,0,r,FillColor= MAGENTA,EdgeWidth =0
) 
Overall  
x = -4; r = 4  
DrawDisk (x,"
"0,r,FillColor= MAGENTA,EdgeWidth =0) 
 
x = x + 1.5*r; r = r/2  
DrawDisk (x,0,r,FillColor= CYAN,EdgeWidth =0) 
 
x = x + 1.5*r; r = r/2  
DrawDisk (x,0,r,FillColor= MAGENTA,EdgeWidth =0) 
 
x = x + 1.5*r; r = r/2  
DrawDisk (x,0,r,FillColor= CYAN,EdgeWidth =0) 
Notice the repetition of the x and r updates. Simpler than figuring  
the centers and radii “by hand”. Also gets us ready for loops.  Let’s Draw a Star  
with DrawStar  
You must tell DrawStar   
 
       - the center of the star.  
       - the rad"
"ius of the star  
 
You have the option of telling DrawStar   
 
 - the fill color  
 - the width of the perimeter highlight  
 - the color of the perimeter highlight  
 - the rotation angle  
  DrawStar  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawStar (x,y,r) 
ShowWindow () 
The default is a star  
with no fill color. So all you  
get is the perimeter.  
 
Note: the radius of a star is the  
distance from its center to  
any tip. 
 
DrawStar  
from SimpleGraphics  im"
"port* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawStar (x,y,r,FillColor =MAGENTA)  
ShowWindow () 
Use the optional color  
argument to specify a fill  
color. 
 
DrawStar  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawStar (x,y,r,FillColor =MAGENTA,EdgeWidth =6) 
ShowWindow () 
Use the optional EdgeWidth  
argument to specify the  
boldness of the perimeter  
highlight. The default  
is EdgeWidth  = 1 
 
If you don’t want any perimeter highlight, then set EdgeW"
"idth =0 
DrawStar  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; r=4  
DrawStar (x,y,r,FillColor =MAGENTA,theta =18) 
ShowWindow () 
Use the optional theta 
argument to specify the  
counterclockwise rotation  
of the rectangle about its  
center. (Angle in degrees.)  
 
The default rotation angle is zero.  
Let’s Draw a Line Segment  
with DrawLineSeg  
You must tell DrawLineSeg   
 
       - the first endpoint of the segment  
       - the second endpoint of the segment  
 
You "
"have the option of telling DrawLineSeg   
 
 - the color of the segment  
 - the line width of the segment   DrawLineSeg  
The default line color is BLACK.  
 
The default line width is 1.  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
a = -3; b = -2; c = 4; d = 2  
DrawLineSeg (a,b,c,d,LineWidth =4, 
                   LineColor ='MAGENTA')  
ShowWindow () Let’s “Draw” Text  
with DrawText  
You must tell DrawText   
 
       - the location of the text.  
       - the text (a string) that "
"is to be displayed  
 
You have the option of telling DrawText  
 
 - the color of the text  
 - the size of the font  
  DrawText  
from SimpleGraphics  import* 
MakeWindow (3,bgcolor=YELLOW)  
x=0; y=0; s = 'This is the origin.'  
DrawText (x,y,s,FontSize =24,FontColor='MAGENTA')  
DrawDisk (0,0,.03,FillColor=BLACK)  
ShowWindow () 
The default text color is BLACK.  
 
The default font size is 10.  
 
The lower left corner of the first  
character is roughly at ( x,y). 
Let’s Talk About Color  
The rgb Re"
"presentation  
[ 0.57 , 0.17, 0.93] A color is a triple of numbers, each between  
zero and one.  
 
The numbers represent the amount of red,  
green, and blue.  
 
This is purple:  The Module SimpleGraphics  
Has 8 Procedures and Data 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                   SimpleGraphics.py  
Data 
In this case  
the data  
encodes the  
“rgb” values  
of thirteen  
colors                    
                  
                                    
                                    "
"
                  
                  The SimpleGraphics  Colors  
YELLOW    = [1.00,1.00,0.00]  
CYAN      = [0.00,1.00,1.00]  
MAGENTA   = [1.00,0.00,1.00]  
RED       = [1.00,0.00,0.00]  
GREEN     = [0.00,1.00,0.00]  
BLUE      = [0.00,0.00,1.00]  
WHITE     = [1.00,1.00,1.00]  
BLACK     = [0.00,0.00,0.00]  
PURPLE    = [0.57,0.17,0.93]  
DARKGRAY  = [0.33,0.33,0.33]  
LIGHTGRAY = [0.67,0.67,0.67]  
ORANGE    = [1.00,0.50,0.00]  
PINK      = [1.00,0.71,0.80]  These are called  
“Global Variables”  
Con"
"vention: Global Variable Names should be UPPER CASE.  Access  
from SimpleGraphics  import* 
MakeWindow (5,bgcolor=YELLOW)  
x=0; y=0; L=5; W=3  
DrawRect (x,y,L,W,FillColor =MAGENTA)  
ShowWindow () 
When a module is imported, it gives access to  
both its functions and its global variables.  
Take a look at the Demos ShowRect.py,  ShowDisk.py , and ShowStar.py  rgb Lists  
Things like [0.74,1.00,0.34]  are called rgb 
lists. 
 
Rules: Square brackets, 3 numbers separated by  
commas, each number between 0"
" and 1.  
 
First number  = red value  
Second number = green value  
Third number = blue value  
 
The bigger numbers mean more of that color.  
 Using rgb Lists  
Instead of using the predefined colors you can  
make up and use your own fill color, e.g.  
  
  c = [0.74,1.00,0.34]  
  DrawDisk (0,0,1,FillColor=c)  
 
 
Google “ rgb values” to look at huge tables of  
colors and rgb values.  
 Title 
from SimpleGraphics  import* 
r=0.8,g=0.4, b=0.8  
MakeWindow (5,bgcolor=[ r,g,b]) 
s = ‘r=%4.2f  g=%4.2f  "
"b = %4.2f’ % ( r,g,b) 
Title(s,FontSize =20) 
ShowWindow () 
You can put a title  
at the top of the  
figure window.  
 
 
 
A Note on Managing Figures  
MakeWindow (etc) 
 
 
MakeWindow (etc) 
 
 
MakeWindow (etc) 
 
 
ShowWindow ()  
                                            
 
                                            
 
                                            Three figure windows 
will be produced.  
 
The green code defines 
what is in the first 
window.  
 
The pink and blue code 
set up the "
"second  
and third windows.  
 
The ShowWindow  says.  
“Show all the windows.”  
 Take a look at the Demos ShowDrawRect.py ,  ShowDrawStar.py, etc.  A Final Example  
Shows two things.  
 
1.You can write a module that uses other  
modules that YOU have written.  
 
2. You can have a module that has both function  
definitions and a script that can be executed.  
 
 
 A Final Example  
We write a procedure to draw this  
and a script that calls it twice:  
We put them both in the SAME module….  A Final Exa"
"mple  
 
 
 from simpleGraphics  import *  
 
def DrawTile (x,y,r,c1,c2,c3):  
    DrawRect (x,y,2*r,2* r,FillColor =c1) 
    DrawDisk (x,y,r,FillColor =c2) 
    DrawStar (x,y,r,FillColor =c3) 
  
if __name__ == '__main__':  
 
    MakeWindow (6,bgcolor= BLACK,labels =False) 
    DrawTile (3,0,2,MAGENTA,PURPLE,YELLOW)  
    DrawTile (-3,0,2,MAGENTA,PURPLE,YELLOW)  
    ShowWindow ()  Tile.py  
See the Demo Tile.py   In command mode, enter   python Tile.py  A Final Example  
 
 
 from SimpleGraphics  import "
"*  
 
def DrawTile (x,y,r,c1,c2,c3):  
    DrawRect (x,y,2*r,2* r,FillColor =c1) 
    DrawDisk (x,y,r,FillColor =c2) 
    DrawStar (x,y,r,FillColor =c3) 
  
if __name__ == '__main__':  
 
    MakeWindow (6,bgcolor= BLACK,labels =False) 
    DrawTile (3,0,2,MAGENTA,PURPLE,YELLOW)  
    DrawTile (-3,0,2,MAGENTA,PURPLE,YELLOW)  
    ShowWindow ()  Tile.py  
See the demo Tile.py   In command mode, enter   python Tile.py                                                                                             "
"                                                   
 
 
 
 This is called  
an “Application  
Script”  So  a Module Can Look Like This  
 
 
 
 
 
  
if __name__ == '__main__':  
 
 
 
                                               
                                              
                                              
                                              
                                              Data 
 
Function  
Definitions  
 
 
Gotta  have 
 
Application  
   Script  
Those are “dou"
"ble underscores” in the if statement.  Summary  
1.Procedures “look like” functions without  
   the “return.” They “do stuff” but do not  
   return values  
 
2. Graphics procedures were used to  
    illustrate the idea.  
 
3. Color can be encoded with three numbers  
    that indicate the amount of red, green,  
    and blue.  
 
4. A single module can house data, functions,  
and a script at the same time  
 "
"TUPLES, LISTS, 
ALIASING, 
MUTABILITY , CLONING
(download slides and . pyfiles and follow along!)
6.0001 LECTURE 5
6.0001 LECTURE 5 1LAST TIME
functions
decomposition –create structure
abstraction –suppress details
from now on will be using functions a lot
6.0001 LECTURE 5 2TODAY
have seen variable types: int , float , bool,string
introduce new compound data types
•tuples
•lists
idea of aliasing
idea of mutability
idea of cloning
6.0001 LECTURE 5 3TUPLES
an ordered sequence of elements, can mix el"
"ement types
cannot change element values, immutable
represented with parentheses
te= ()
t = (2,""mit"",3)
t[0] evaluates to 2
(2,""mit"",3) + (5,6) evaluates to (2,""mit"",3,5,6)
t[1:2] slice tuple, evaluates to (""mit"",)
t[1:3] slice tuple, evaluates to (""mit"",3)
len(t) evaluates to 3
t[1] = 4 gives error, can’t modify object
6.0001 LECTURE 5 4TUPLES
conveniently used to swap variable values
x = y temp= x (x, y) = (y, x)
y = x x = y
y = temp
used to return more than one value from a function
defquotient"
"_and_remainder (x, y):
q = x // y
r = x % y
return(q, r)
(quot, rem) = quotient_and_remainder (4,5)
6.0001 LECTURE 5 5MANIPULATING TUPLES
can iterate over tuples
defget_data (aTuple):
nums= ()
words = ()
for t in aTuple:
nums= nums+ (t[0],)   
if t[1] not in words:   
words = words + (t[1],)
min_n= min(nums)
max_n= max(nums)
unique_words = len(words)
return ( min_n, max_n, unique_words )
6.0001 LECTURE 5 6aTuple:(( ),( ),( ))
nums(         )
words(        )
if not already in words 
i.e. unique strings from"
" aTuple? ? ?LISTS
ordered sequence of information, accessible by index
a list is denoted by square brackets , []
a list contains elements
•usually homogeneous ( ie, all integers)
•can contain mixed types (not common )
list elements can be changed so a list is mutable
6.0001 LECTURE 5 7INDICES AND ORDERING
a_list= []
L = [2, 'a', 4, [1,2]]
len(L)evaluates to 4
L[0] evaluates to 2
L[2]+1evaluates to 5
L[3] evaluates to [1,2] , another list!
L[4] gives an error 
i= 2
L[i-1]evaluates to ‘a’ since L[1]"
"='a' above
6.0001 LECTURE 5 8CHANGING ELEMENTS
lists are mutable !
assigning to an element at an index changes the value
L = [2, 1, 3]
L[1] = 5
Lis now [2, 5, 3] , note this is the same object L
6.0001 LECTURE 5 9L[2,1,3][2,5,3]ITERATING OVER A LIST
compute the sum of elements of a list
common pattern, iterate over list elements
notice
•list elements are indexed 0 to len(L)-1
•range(n) goes from 0 to n-1
6.0001 LECTURE 5 10total = 0 
for iin range( len(L)): 
total += L[ i] 
print totaltotal = 0 
for i"
"in L: 
total += i
print totalOPERATIONS ON LISTS -ADD
add elements to end of list with L.append (element)
mutates the list!
L = [2,1,3]
L.append (5) L is now [2,1,3,5]
what is the dot? 
•lists are Python objects, everything in Python is an object
•objects have data
•objects have methods and functions 
•access this information by object_name.do_something ()
•will learn more about these later
6.0001 LECTURE 5 11OPERATIONS ON LISTS -ADD
to combine lists together use concatenation , + operator, 
to give yo"
"u a new list
mutate list with L.extend (some_list )
L1 = [2,1,3]
L2 = [4,5,6]
L3 = L1 + L2 L3is [2,1,3,4,5,6]
L1, L2 unchanged
L1.extend([0,6]) mutated L1to [2,1,3,0,6] 
6.0001 LECTURE 5 12OPERATIONS ON LISTS -
REMOVE
delete element at a specific index withdel(L[index])
remove element at end of list with L.pop(), returns the 
removed element
remove a specific element with L.remove (element)
•looks for the element and removes it
•if element occurs multiple times, removes first occurrence
•if element no"
"t in list, gives an error
L = [2,1,3,6,3,7,0] # do below in order
L.remove (2)mutates L = [1,3,6,3,7,0]
L.remove (3)mutates L = [1,6,3,7,0] 
del(L[1]) mutates L = [1,3,7,0]
L.pop() returns 0 and mutates L = [1,3,7]
6.0001 LECTURE 5 13CONVERT LISTS TO STRINGS 
AND BACK
convert string to list with list(s), returns a list with every 
character from san element in L 
can use s.split(), to split a string on a character parameter, 
splits on spaces if called without a parameter
use ''.join(L) to turn a lis"
"t of characters into a string , can 
give a character in quotes to add char between every element
6.0001 LECTURE 5 14s = ""I<3 cs"" sis a string
list(s) returns ['I','<','3',' ','c','s']
s.split('<') returns ['I', '3 cs']
L = ['a','b','c ']Lis a list
''.join(L) returns ""abc""
'_'.join(L) returns ""a_b_c""OTHER LIST OPERATIONS
sort() and sorted()
reverse()
and many more! 
https ://docs.python.org/3/tutorial/datastructures.html
L=[9,6,0,3]
sorted(L) returns sorted list, does not mutate L
L.sort() mutate"
"sL=[0,3,6,9 ]
L.reverse ()mutatesL=[9,6,3,0]
6.0001 LECTURE 5 15MUTATION, ALIASING, CLONING
Again, Python Tutor is your best friend 
to help sort this out!
http://www.pythontutor.com /IMPORTANT 
and
TRICKY!
6.0001 LECTURE 5 16LISTS IN MEMORY
lists are mutable
behave differently than immutable types
is an object in memory
variable name points to object
any variable pointing to that object is affected
key phrase to keep in mind when working with lists is 
side effects
6.0001 LECTURE 5 17AN ANALOGY
att"
"ributes of a person
◦singer, rich
he is known by many names
all nicknames point to the same person
•add new attribute to one nickname … 
•… all his nicknames refer to old attributes AND all new ones
6.0001 LECTURE 5 18Justin Bieber singer rich troublemaker
The Bieb singer rich troublemaker
JBeebs singer rich troublemakerALIASES
hot is an alias for warm –changing one changes the 
other!
append() has a side effect
6.0001 LECTURE 5 19
CLONING A LIST
create a new list and copy every element using 
chill = "
"cool[:]
6.0001 LECTURE 5 20
SORTING LISTS
calling sort() mutates the list, returns nothing
calling sorted() 
does not mutate 
list, must assign 
result to a variable
6.0001 LECTURE 5 21
LISTS OF LISTS OF LISTS OF….
can have nested lists
side effects still 
possible after mutation
6.0001 LECTURE 5 22
MUTATION AND ITERATION
Try this in Python Tutor!
avoid mutating a list as you are iterating over it
defremove_dups (L1, L2):
for e in L1:
if e in L2:
L1.remove(e )
L1 = [1, 2, 3, 4]
L2 = [1, 2, 5, 6 ]
remov"
"e_dups (L1, L2)
L1 is [2,3,4] not [3,4] Why? 
•Python uses an internal counter to keep track of index it is in the loop
•mutating changes the list length but Python doesn’t update the counter
•loop never sees element 2
6.0001 LECTURE 5 23defremove_dups (L1, L2):
L1_copy = L1[:]
for e in L1_copy:
if e in L2:
L1.remove(e)MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: h"
ttps:// ocw.mit.edu/terms .
"6. How Modules and Functions  
Work  
 Topics:  
 Modules and Functions  
 More on Importing  
 Call Frames  
 Let’s Talk About Modules  What Are They?  
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
    M1.py     A module is a . py 
file that contains  
Python code  
 
The name of the  
module is the name  
of the file. This is  
the module M1.py 
 
We draw a module  
as a folder with a  
black outline.    
 
 
 
 
 
 
 
 A module may contain  
a single script.  
 
A script will be shown  
as a rectangle with  "
"
a red border.  
 
 
  Inside a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
    Kepler.py     
       : 
       : 
r = 1 
E = sqrt(6)*r  
       : 
       :   
 
 
 
 
 
 
 
 A module may contain  
one or more function  
definitions.  
 
Functions will be  
shown as rectangles  
with green borders.  
 
 
  Inside a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
    SimpleMath.py     
   sqrt    
   cos    
   sin      
 
 
 
 
 
 
 
 A module may contain  
one or more data items.  
 
These are referred to  
as global variable"
"s . They 
should be treated as 
constants whose values 
are never changed.  
 
Data items will be  
shown as rectangles  
with blue borders.  
 Inside a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
  SimpleGraphics.py   
RED = [1.,0.,0.]  
BLUE = [0.,0.,1.]  
CYAN = [0.,1.,1.]    
 
 
 
 
 
 
 
 A module may contain  
one or more data items  
and one or more 
functions.  
 
 
 
  Inside a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
  SimpleGraphics.py   
RED = [1.,0.,0.]  
CYAN = [0.,1.,1.]  
MakeWindow  
DrawRect    
 
 
 "
"
 
 
 
 
 A module may contain  
one or more data items  
and one or more functions 
and a  script.  
 
But in this case, the script 
MUST be prefaced by  
 
if __name__ == ‘__main__’:  
 
 
 Inside a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
  M.py   
         
         
         
         
         Let’s Talk About import What Does import   Allow?  
   
 import M2  
    : 
     
    M1.py     
It means that code inside M1.py  can reference  
the data and functions inside M2.py  
 
 
 
 
 
 
 
 
 
 
  M2.py   
G"
"lobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                What Does import  Allow?  
   
 import M2  
    : 
     
 
    M1.py     
A function             in  M1.py could have a line like  
     a = M2.func2(x,M2.GlobVar1)  
  
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                What Does import   Allow?  
   
 import M2  
    : 
     
 
    M1.py     
The script              in  M1.py could have a line like  
       a = M2.func1(M2.GlobVar"
"1)  
  
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                One Way to Think About this...  
   
 import M2  
    : 
    :    M1.py      
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
is like this…     
  
     
 
 
 
 
 
 
     M1.py     
 
 
 
 
 
 
 
 
 
 
 
  M2  
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
Module  M1.py  contains a folder called M2. Need 
the  "
"“dot notation’’ to extract what is in M2. What Does import*   Allow?  
   
 from M2 import*  
    : 
      
 
    M1.py     
A function             in  M1.py could have  
a line like    a = func1(x,GlobalVar2)  
  
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
No dot  
notation  What Does import*   Allow?  
   
 from M2 import*  
    : 
      
 
    M1.py     
A script             in  M1.py could have  
a line like    a = func2(x,GlobalVar2)  
  
 "
"
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
No dot  
notation  One way to Think about this…  
   
 from M2 import*  
    : 
      
 
    M1.py      
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
is like this…     
 
 
 
 
 
     
      
 
    M1.py     
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                GlobVar1=3.14  It is as if  
GlobVar1 ,  
GlobVar2 , 
func1 , and  
func2 
were"
" defined in  
M1.py “Specific” Importing  
   
 from M2 import func2  
    : 
      
 
    M1.py     
A script            in  M1.py could 
have a  line like  a = func2(3,4)  
  
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
No dot  
notation  “Specific” Importing  
   
 from M2 import func2  
    : 
      
 
    M1.py     
A script            in  M1.py could NOT 
have a  line like  a = func1(4)  
  
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
fu"
"nc1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                One way to think about this…  
   
 from M2 import func2  
    : 
      
 
    M1.py      
 
 
 
 
 
 
 
 
 
 
  M2.py   
GlobVar1=3.14  
func1(x)  
func2(x,y)  GlobVar2=[1,0,0]  
                
       is like this…     
 
 
 
     
      
 
    M1.py     
                func2(x,y)  It is as if  
func2 
was defined  
in M1.py   
 
 
 
 
 
 
 
  
 
 
 
  Using Stuff Within a Module   
 
 
 
 
 
 
 
 
 
 
 
 
 
  M.py   
               
              "
" 
               
               
         The functions and  
global variables  
in M.py can be  
used  throughout  
M.py 
without the dot  
notation  There are rules about when a  
module M2.py  can be imported 
by a module M1.py Does this Always Work?  
Yes, if  M2.py is a module that is part  
of the CS 1110 Python installation, e.g.,  
 
math  numpy urllib2  string  
scipy PIL   random timeit . 
    
import M2  
    :    M1.py     Does this Always Work?  
No UNLESS   M1.py  and M2.py are each  
in the "
"“current working directory ”. 
.    
import M2  
    :    M1.py     Comments on  
“Launching” a Python Computation  
                                                                                                                             
 
 
 
 
 
 In what follows, this   
will be how we indicate 
what’s in the “current 
working directory”  
And this will mean we 
are in the command shell 
and in the “current 
working directory”  cwd >    
           
           
         
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 "
"
 
                                                                                                                                                         
 import M2  
 
 
  M1.py   
         
 cwd > python M1.py  Result: the script in M1.py   
 is executed.   
 
 
 
 
 
  M2.py   
         
          
 import M2  
 
 
 
 
 
 
  M1.py   
         
         
          
 
 
 
 
 
 
 
 
 
 
  M2.py   
         
         
                   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                    "
"                                                                                                                    
 cwd > python M1.py  Result: the script in M1.py   
 is executed. The script in 
M2.py  is not executed   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 import M2  
 
 
 
 
  M1.py   
         
          
 
 
 
 
 
 
 
 
 
 
  M2.py   
         
         
                  
 cwd > python M1.py  Result: Nothing happens because  
there is no  script in  
M1.py  to execute.   
 import M2  
 
 
 
 
 
 
  M1."
"py   
         
         
          
 
 
 
 
 
 
 
 
 
 
  M2.py   
         
         
                   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                                                                                        
 cwd > python M1.py  Error. Python cannot 
find M2   
 import M2  
 
 
 
 
 
 
  M1.py   
         
         
          
 
 
 
 
 
 
 
 
 
 
  M2.py   
         
         
                   
 
 
 
 
 
 
 
 
 
 
 
 
 
 "
"
 
 
                                                                                                                             
 cwd > python M1.py  Error. Python cannot 
find M1   
 import M2  
 
 
 
 
 
 
  M1.py   
         
         
          
 
 
 
 
 
 
 
 
 
 
  M2.py   
         
         
                   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                                                             
 cwd > python M2.py  Fine. M2.p"
"y does not 
need M1.py  Important Distinction  
Distinguish between calling a function  
 
                 y = sqrt(3) 
 
and defining a function  
 
   def sqrt(x): 
     L = x 
     L = (L + x/L)/2  
    L = (L + x/L)/2  
    return L   
A function isn’t executed when it is defined.  
Think of defining a function as setting up a formula that is to be used later.    We now focus our attention  
on the mechanics behind  
function calls.  Somewhat  Like Plugging into a 
Formula  
  
 
  For the simple kind "
"of fruitful functions  
that we have been considering, there is a  
substitution process.  
 
Exactly how does it work?  We Use This Example…  
def T(s):  
“““ Returns as int the number of minutes 
from 12:00 to the time specified by s.  
 
PreC: s is a length -5 string of the form 
‘hh:mm’ that specifies the time.”””   
 
   h = int(s[:2]) 
   m = int(s[3:]) 
   if h<12:  
      z = 60*h+m 
   else: 
      z = m 
   return z  A Script  
s1 = ‘11:15’  
s2 = ‘12:05’  
x = T(s1)  
y = T(s2)  
if y>=x:  
   nu"
"mMin = y-x 
else: 
   numMin = (y+720) -x 
This assigns to numMin  the number of minutes in a 
class that starts at the time specified by s1 and  
ends at the time specified by s2.  function call   
function call   A Script  
 s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin 
Prints the number of minutes in a class that starts  
at the time specified by s1 and ends at the time 
specified by s2. Let us step through its exe"
"cution.    s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  1  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         This box is called  
Global Space. It includes  
all the variables associated  
with the script.  The red dot indicates  
the next thing to do in  
the script.   s1 = ‘11"
":15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  2  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  3  
 
     s1 
     s2 
     x 
     y    "
"             
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’  def T(s):  
   h = int(s[:2]) 
   m = int(s[3:]) 
   if h<12:  
      z = 60*h+m 
   else: 
      z = m 
   return z  
Function call  
 
The defined function T will  
now be asked to process the  
value in s1.  
 
Let’s track what happens…   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
   "
"  numMin = (y+720) -x 
 print numMin  3  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’  def T(s):  
   h = int(s[:2]) 
   m = int(s[3:]) 
   if h<12:  
      z = 60*h+m 
   else: 
      z = m 
   return z  
Function call  
 
We open up a “call frame”  
that shows the “key players”  
associated with the  
function   s1 = ‘11:15’  
 s2 = ‘12:05’  
 "
"x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  3  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
"
"                          
                         
                         
                         
                         
           The variable s is the function’s parameter   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  3  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                   "
"      ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
        The variables h, m, and z is the function’s local variables   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 els"
"e: 
     numMin = (y+720) -x 
 print numMin  3  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
       "
"                  
                         
                         
 return  is a special variable. Will house the value to return   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  4  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int"
"(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  Control passes from the red dot to the blue dot   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  5  
 
     s1 
     s2 
"
"     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                        "
" 
  Assign the argument value (housed in s1) to the parameter s.  ‘11:15’   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  5  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60"
"*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body, business as usual.  ‘11:15’   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  5  
 
     s1 
     s2 
     x 
     y                 
numMin 
     "
"                     
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body, busine"
"ss as usual.  ‘11:15’  
     11  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  6  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     retur"
"n z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body. Business as usual.  ‘11:15’  
11 
15  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  7  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
             "
"            
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         ‘11:15’  
11 
15 
  We step through the function body. Business as usual.  675 "
" s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  8  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m"
" 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body. Business as usual.  ‘11:15’  
11 
15 
675 
675  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  9  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
         "
"                
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  The return value is shipped back the to red dot instruction.  ‘11:15’  
11 
15 
675 
675 675  s1 ="
" ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  10  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
  "
"   z                
return 
                          
                         
                         
                         
                         
  The function call is over. The Call Frame “disappears”…  ‘11:15’  
11 
15 
675 
675 675  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  11  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
      "
"                   
                         
                         ‘11:15’  
‘12:05’  
  And the red dot moves to the next statement in the script  675 Another  
function  
Call!  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  12  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                     "
"    ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We open up the Call Frame   675  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print "
"numMin  13  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                 "
"        
                         
  The value of the argument (housed in s2) is substituted   675 ‘12:05’   s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  13  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:"
"]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  Execution of  the function body starts.   675 ‘12:05’  
 12  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin 14  
 
     s1 
     s2 
     x 
     y "
"                
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step thr"
"ough the function body   675 ‘12:05’  
 12 
  5  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  15  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        "
"z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body.   675 ‘12:05’  
 12 
   5 
   5  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin 16  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
 "
"                        
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
      h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  We step through the function body.   675 ‘12:05’  
 12 
   5 
  "
" 5 
   5  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  18  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                         ‘11:15’  
‘12:05’    def T(s):  
     h = int(s[:2]) 
     m = int(s[3:]) 
     if h<12:  
        z = 60*h+m 
     else: 
        z = m 
     return z  
 
      s 
     "
" h 
     m 
     z                
return 
                          
                         
                         
                         
                         
  That value is sent back to the red dot.    675 ‘12:05’  
 12 
   5 
   5 
   5    5  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  19  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                      "
"   
                         
                         
                         ‘11:15’  
‘12:05’  
  Function call is over. Call Frame disappears. Red dot moves on    675 
   5 
   50  s1 = ‘11:15’  
 s2 = ‘12:05’  
 x = T(s1)  
 y = T(s2)  
 if y>=x:  
     numMin = y-x 
 else: 
     numMin = (y+720) -x 
 print numMin  20  
 
     s1 
     s2 
     x 
     y                 
numMin 
                          
                         
                         
                         
                  "
"       ‘11:15’  
‘12:05’  
  The script is over. Global space disappears.    675 
   5 
   50 50  21  
  The script is over. Global space disappears.    50 "
"RECURSION, 
DICTIONARIES 
(download slides and .py ﬁles and follow along!)
6.0001 LECTURE 6
6.0001	LECTURE	6	 1	QUIZ PREP
§a	paper	and	an	online	component
§open	book/notes
§not	open	Internet,	not	open	computer
§	start	prinSng	out	whatever	you	may	want	to	bring	
6.0001	LECTURE	6	 2	LAST TIME
§	tuples	-	immutable	
§	lists	-	mutable	§	aliasing,	cloning		§	mutability	side	eﬀects	
6.0001	LECTURE	6	 3	TODAY
§recursion	–	divide/decrease	and	conquer
§	dicSonaries	–	another	mutable	object	type	
6.0001	LECTURE	6"
"	 4	RECURSION
Recursion	is	the	process	of	repeaSng	items	in	a	self-s
imilar	way.		
6.0001	LECTURE	6	 5	WHAT IS RECURSION?
§	Algorithmically:	a	way	to	design	soluSons	to	problems	
by	divide-and-conquer	 or	decrease-and-conquer
◦reduce	a	problem	to	simpler	versions	of	the	same	
problem		
§	SemanScally:	a	programming	technique	where	a	
func0on	calls	itself 	
◦	in	programming,	goal	is	to	NOT	have	inﬁnite	recursion	
◦	must	have	1	or	more	base	cases	 that	are	easy	to	solve	
◦	must	solve	the	same	problem	on	some"
"	other	input	 with	the	goal	
of	simplifying	the	larger	problem	input	
6.0001	LECTURE	6	 6	ITERATIVE ALGORITHMS SO FAR
§	looping	constructs	(while	and	for	loops)	lead	to	
itera0ve	algorithms	
§	can	capture	computaSon	in	a	set	of	state	variables 	
that	update	on	each	iteraSon	through	loop	
6.0001	LECTURE	6	 7	MULTIPLICATION –  
ITERATIVE SOLUTION
§	“mulSply	 a	*	b”	is	equivalent	to	“add	a	to	itself	b	Smes”	
a + a + a + a + … + a §	capture	state	by		
◦	an	itera0on	number	(i)	starts	at	b	
     i ß i-1	and	sto"
"p	when	0	    0a    1a	     2a       3a      4alt)	 ◦	a	current	val ue	of 	computa0on	(resu 		
     result ß result + a 
def mult_iter(a, b):
    result = 0
 while b > 0: += aresult
b -= 1
    return result
	
6.0001	LECTURE	6	 8	
	
 	
 	
a*b = a + a + a + a + … + a 
 = a + a + a + a + … + a 
 = a + a * (b-1)  MULTIPLICATION –  
RECURSIVE SOLUTION
§	recursive	step	
•	think	how	to	reduce	
problem	to	a	simpler/
smaller	version	 of	
same	problem		
§	base	case	
•	keep	reducing	
problem	unSl	reach	a	simple	case	t"
"hat	can	be	solved	directly	
•	when	b	=	1,	a*b	=	a	
	
6.0001	LECTURE	6	 9	def mult(a, b):
   if b == 1:
return a
    else :
return a + mult(a, b-1)
FACTORIAL
n! = n*(n-1)*(n-2)*(n-3)* … * 1 
§	for	what	n	do	we	know	the	factorial?	
n	=	1  à  if n == 1: 
    return 1  
§	how	to	reduce	problem?	Rewrite	in	terms	of	
something	simpler	to	reach	base	case	
n*(n-1)! 	à 	else:  
    return n*factorial(n-1) 
	
6.0001	LECTURE	6	 10	RECURSIVE  
FUNCTION  
SCOPE  EXAMPLE
6.0001	LECTURE	6	 11	Global	scope	
fact	 Some	
c"
"ode	fact	scope	
(call	w/	n=4)	
n	4	fact	scope	
(call	w/	n=3)	
n	3	fact	scope	
(call	w/	n=2)	
n	2	fact	scope	
(call	w/	n=1)	
n	1	def fact(n):
    if n == 1:
return 1
    else:
return n*fact(n-1)
print(fact(4))SOME OBSERVATIONS
§	each	recursive	call	to	a	funcSon	creates	its	
own	scope/environment	
§	bindings	of	variables	 in	a	scope	are	not	
changed	by	recursive	call	
§	ﬂow	of	control	passes	back	to	previous	
scope	 once	funcSon	call	returns	value	
6.0001	LECTURE	6	 12	ITERATION vs.  RECURSION  
def facto"
"rial_iter(n): def factorial(n):
    prod = 1     if n == 1:
    for i in range(1,n+1): return 1
prod *= i     else:
    return prod  return n*factorial(n-1)
6.0001	LECTURE	6	 13	§	recursion	may	be	simpler,	more	intuiSve		
§	recursion	may	be	eﬃcient	from	programmer	POV	
§	recursion	may	not	be	eﬃcient	from	computer	POV	INDUCTIVE REASONING
§	How	do	we	know	that	our	 def mult_iter(a, b):
recursive	code	will	work?	     result = 0
§	mult_iter	terminates	     while b > 0:
because	b	is	iniSally	posiSve,	 result +="
" aand	decreases	by	1	each	Sme	
around	loop;	thus	must	b -= 1
eventually	become	less	than	1	     return result
§	mult	called	with	b	=	1	has	no	
recursive	call	and	stops	 def mult(a, b):
§	mult		called	with	b	>	1	makes	     if b == 1:
a	recursive	call	with	a	smaller	return aversion	of	b;	must	eventually	reach	call	with	b	=	1	
    else:
return a + mult(a, b-1)
	
6.0001	LECTURE	6	 14	MATHEMATICAL INDUCTION
§	To	prove	a	statement	indexed	on	integers	is	true	for	all	
values	of	n:	
◦Prove	it	is	true	when	n	is	sma"
"llest	value	(e.g.	n	=	0	or	n	=	1)	
◦Then	prove	that	if	it	is	true	for	an	arbitrary	value	of	n,	one	
can	show	that	it	must	be	true	for	n+1	
6.0001	LECTURE	6	 15EXAMPLE OF INDUCTION
§	0	+	1	+	2	+	3	+	…	+	n	=	(n(n+1))/2	
§	Proof:	
◦If	n	=	0,	then	LHS	is	0	and	RHS	is	0*1/2	=	0,	so	true	
◦Assume	true	for	some	k,	then	need	to	show	that	
										0	+	1	+	2	+	…	+	k	+	(k+1)	=	((k+1)(k+2))/2	
◦LHS	is	k(k+1)/2	+	(k+1)	by	assumpSon	that	property	holds	for	
problem	of	size	k	
◦This	becomes,	by	algebra,	((k+1)(k+2))/2	"
"
◦Hence	expression	holds	for	all	n	>=	0	
6.0001	LECTURE	6	 16	RELEVANCE TO CODE?
§	Same	logic	applies	
def mult(a, b):
    if b == 1:
return a
    else:
return a + mult(a, b-1)
§	Base	case,	we	can	show	that	mult must	return	correct	answer	§	For	recursive	case,	we	can	assume	that	mult correctly	returns	an	
answer	for	problems	of	size	smaller	than	b,	then	by	the	addiSon	step,	it	
must	also	return	a	correct	answer	for	problem	of	size	b	
§	Thus	by	inducSon,	code	correctly	returns	answer	
	6.0001	LECTURE	6	 17	"
"TOWERS OF HANOI
§The	story:
◦3	tall	spikes
◦Stack	of	64	diﬀerent	sized	discs	–	start	on	one	spike
◦Need	to	move	stack	to	second	spike	(at	which	point
universe	ends)
◦Can	only	move	one	disc	at	a	Sme,	and	a	larger	disc	can
never	cover	up	a	small	disc
6.0001	LECTURE	6	 18	TOWERS OF HANOI
§	Having	seen	a	set	of	examples	of	diﬀerent	sized	
stacks,	how	would	you	write	a	program	to	print	out	the	
right	set	of	moves?	
§	Think	recursively!	
◦Solve	a	smaller	problem	
◦Solve	a	basic	problem	
◦Solve	a	smaller	problem"
"	
6.0001	LECTURE	6	 196.0001	LECTURE	6	 20	def printMove(fr, to):
    print('move from ' + str(fr) + ' to ' + str(to))
def Towers(n, fr, to, spare):
    if n == 1:
printMove(fr, to)
    else:
Towers(n-1, fr, spare, to)
Towers(1, fr, to, spare)
Towers(n-1, spare, to, fr)RECURSION WITH MULTIPLE 
BASE CASES
§	Fibonacci	numbers	
◦Leonardo	of	Pisa	(aka	Fibonacci)	modeled	the	following	
challenge	
◦Newborn	pair	of	rabbits	(one	female,	one	male)	are	put	in	a	pen	
◦Rabbits	mate	at	age	of	one	month	
◦Rabbits	have	a"
"	one	month	gestaSon	period	
◦Assume	rabbits	never	die,	that	female	always	produces	one	new	
pair	(one	male,	one	female)	every	month	from	its	second	month	
on.	
◦How	many	female	rabbits	are	there	at	the	end	of	one	year?	
6.0001	LECTURE	6	 21Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 22	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 23	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 24Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz"
"	
6.0001	LECTURE	6	 25	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 26Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 27	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 28	6.0001	LECTURE	6	 29	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 30	Demo	courtesy	of	Prof.	Denny	Freeman	and	Adam	Hartz	
6.0001	LECTURE	6	 31	FIBONACCI
	 Ayer	one	month	(call	it	0)	–	1	female	
	 Ayer	second	month	–	sSll	1	female	(now	
pregn"
"ant)	
	 Ayer	third	month	–	two	females,	one	pregnant,	
one	not	
	 In	general,	females(n)	=	females(n-1)	+	
females(n-2)	
◦Every	female	alive	at	month	n-2	will	produce	one	
female	in	month	n;	
◦These	can	be	added	those	alive	in	month	n-1	to	
get	total	alive	in	month	n	Month	 Females	
0	 1	
1	 1	2	 2	3	 3	4	 5	5	 8	6	 13	
6.0001	LECTURE	6	 32	FIBONACCI
§	Base	cases:	
◦Females(0)	=	1	
◦Females(1)	=	1	
§	Recursive	case	
◦Females(n)	=	Females(n-1)	+	Females(n-2)	
6.0001	LECTURE	6	 33	6.0001	LECTURE	6	 34FIBONAC"
"CI
def fib(x):
    """"""assumes x an int >= 0
returns Fibonacci of x""""”
   if x == 0 or x == 1:
return 1
    else:
return fib(x-1) + fib(x-2)RECURSION ON NON-
NUMERICS
§how	to	check	if	a	string	of	characters	is	a	palindrome,	i.e.,
reads	the	same	forwards	and	backwards	
◦“Able	was	I,	ere	I	saw	Elba”	–	avributed	to	Napoleon	
◦“Are	we	not	drawn	onward,	we	few,	drawn	onward	to	new	era?”	–	
avributed	to	Anne	Michaels	
35
Image courtesy of wikipedia , in the public domain. By Larth_Rasnal (Own work) [GFDL (https:"
"//www.gnu.org/licenses/fdl-1.3.en.html ) or 
CC BY 3.0 ( https://creativecommons.org/licenses/by/3.0 )], via Wikimedia Commons.
6.0001	LECTURE	6	SOLVING RECURSIVELY?
§	First,	convert	the	string	to	just	characters,	by	stripping	
out	punctuaSon,	and	converSng	upper	case	to	lower	
case	
§	Then	
◦Base	case:	a	string	of	length	0	or	1	is	a	palindrome	
◦Recursive	case:	
◦If	ﬁrst	character	matches	last	character,	then	is	a	palindrome	if	
middle	secSon	is	a	palindrome 		
	
6.0001	LECTURE	6	 36	EXAMPLE
§ ‘Able	was	"
"I,	ere	I	saw	Elba’	à	‘ablewasiereisawleba’	
§ isPalindrome(‘ablewasiereisawleba’ )	
is	same	as		
◦‘a’ == ‘a’ and	
isPalindrome(‘blewasiereisawleb’)
6.0001	LECTURE	6	 37	
6.0001	LECTURE	6	 38	def isPalindrome(s):
    def toChars(s):
s = s.lower()
ans = ''
for c in s:
if c in 'abcdefghijklmnopqrstuvwxyz':
ans = ans + c
return ans
    def isPal(s):
if len(s) <= 1:
return True
else:
return s[0] == s[-1] and isPal(s[1:-1])
    return isPal(toChars(s))
	
	DIVIDE AND CONQUER
§	an	example	of	a	“divide	and	conquer”"
"	algorithm	
§	solve	a	hard	problem	by	breaking	it	into	a	set	of	sub-
problems	such	that:	
◦sub-problems	are	easier	to	solve	than	the	original	
◦soluSons	of	the	sub-problems	can	be	combined	to	solve	
the	original	
6.0001	LECTURE	6	 39DICTIONARIES 
6.0001	LECTURE	6	 40	HOW TO STORE  
STUDENT INFO
§	so	far,	can	store	using	separate	lists	for	every	info	
names = ['Ana', 'John', 'Denise', 'Katy']
grade = ['B', 'A+', 'A', 'A']course = [2.00, 6.0001, 20.002, 9.01]
§	a	separate 	list	for	each	item	
§	each	list	mu"
"st	have	the	same	length	
§	info	stored	across	lists	at	same	index ,	each	index	refers	to	
info	for	a	diﬀerent	person	
	
6.0001	LECTURE	6	 41	
HOW TO UPDATE/RETRIEVE  
STUDENT INFO
def get_grade(student, name_list, grade_list, course_list):
    i = name_list.index(student)    grade = grade_list[i]
    course = course_list[i]
    return (course, grade)
§	messy	if	have	a	lot	of	diﬀerent	info	to	keep	track	of	
§	must	maintain	many	lists	 and	pass	them	as	arguments	
§	must	always	index	using	integers	§	must	rem"
"ember	to	change	mulSple	lists	
6.0001	LECTURE	6	 42	A BETTER AND CLEANER WAY –  
A DICTIONARY
§	nice	to	index	item	of	interest	directly	 (not	always	int)	
§	nice	to	use	one	data	structure,	no	separate	lists	
	A	list 	 			 A	dic0onary	
	Elem	1	
Elem	2	
Elem	3	
Elem	4	
…	Key	1	
Key	2	
Key	3	
Key	4	
…	Val	1	
Val	2	
Val	3	
Val	4	
…	0	
1	
2	
3	
…	
6.0001	LECTURE	6	 43	A PYTHON DICTIONARY
§	store	pairs	of	data	
•	key	
•	value	
my_dict = {}  
grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} Key	1	
Key"
"	2	
Key	3	
…	Val	1	
Val	2	
Val	3	
…	
key1				val1	 key2					val2	 key3											val3 	 key4						val4	
6.0001	LECTURE	6	 44	'Ana' 
'Denise' 
'John' 
'Katy' 'B' 
'A' 
'A+' 
'A' 'Ana' 
'Denise' 
'John' 
'Katy' 'B' 
'A' 
'A+' DICTIONARY LOOKUP
§	similar	to	indexing	into	a	list	
§	looks	up	the	key	§	returns 	the	value	associated	
with	the	key	
'A' 
§	if	key	isn’t	found,	get	an	error	
grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} 
grades['John']   à evaluates	to	'A+' 
grades['Sylvan']  à gives	a	"
"KeyError	
6.0001	LECTURE	6	 45	DICTIONARY  
OPERATIONS
grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'} 
§	add	an	entry	
grades['Sylvan'] = 'A'
§	test	if	key	in	dicSonary	
'John' in grades àreturns True
  'Daniel' in grades àreturns False
§	delete	entry	
del(grades['Ana'])
6.0001	LECTURE	6	 46	'Sylvan' 'A' 'Ana' 
'Denise' 
'John' 
'Katy' 'B' 
'A' 
'A+' 
'A' DICTIONARY  
OPERATIONS
grades = {'Ana':'B', 'John':'A+', 'Denise':'A', 'Katy':'A'}  
§	get	an	iterable	that	acts	like	a	tuple	of	all	keys	"
"
  grades.keys()   à returns ['Denise','Katy','John','Ana']
§	get	an	iterable	that	acts	like	a	tuple	of	all	values	
grades.values() à returns ['A', 'A', 'A+', 'B']
6.0001	LECTURE	6	 47	'Ana' 
'Denise' 
'John' 
'Katy' 'B' 
'A' 
'A+' 
'A' DICTIONARY KEYS and VALUES
§	values		
•	any	type	(immutable	and	mutable)	
•	can	be	duplicates	
•	dicSonary	values	can	be	lists,	even	other	dicSonaries! 	
§	keys	
•	must	be	unique		
•	immutable 	type	(int,	float,	string,	 tuple,bool )	
•actually	need	an	object	that	is	 hasha"
"ble ,	but	think	of	as	immutable	as	all	
immutable	types	are	hashable	
•	careful	with	float	type	as	a	key	
§	no	order	to	keys	or	values!	
d = {4:{1:0}, (1 ,3):""twelve"", 'const':[3.14,2.7,8.44]}	
6.0001	LECTURE	6	 48	list vsdict    
6.0001	LECTURE	6	 49	§	ordered	sequence	of	 §	matches	“keys”	to	
elements	 “values”	
§	look	up	elements	by	an	 §	look	up	one	item	by	
integer	index another	item	
§	indices	have	an	order	 §	no	order	is	guaranteed	
§	index	is	an	integer	 §	key	can	be	any	
immutable 	type	EXAMPLE:"
" 3 FUNCTIONS TO 
ANALYZE SONG LYRICS
1)	create	a	frequency	dic0onary	 mapping	str:int
2)	ﬁnd	word	that	occurs	the	most	 and	how	many	Smes	
•	use	a	list,	in	case	there	is	more	than	one	word	
•	return	a	tuple	(list,int)	for		(words_list,	 highest_freq)	
3)	ﬁnd	the	words	that	occur	at	least	X	0mes	
•	let	user	choose	“at	least	X	Smes”,	so	allow	as	parameter	
•	return	a	list	of	tuples,	each	tuple	is	a	 (list, int)
containing	the	list	of	words	ordered	by	their	frequency	
•	IDEA:	From	song	dicSonary,	ﬁnd	most	fre"
"quent	word.	Delete	
most	common	w ord.	Repeat.	It	works	because	you	are	
g	dicSonary.	
6.0001	LECTURE	6	 50mutaSng	the	sonCREATING A DICTIONARY
def lyrics_to_frequencies(lyrics):
   myDict = {}
   for word in lyrics: 
if word in myDict:  
myDict[word] += 1
else:
myDict[word] = 1
   return myDict
6.0001	LECTURE	6	 51	USING THE DICTIONARY
def most_common_words(freqs):
    values = freqs.values()    best = max(values)    words = []    for k in freqs:
if freqs[k] == best:
words.append(k)
    return (words, be"
"st)
6.0001	LECTURE	6	 52LEVERAGING DICTIONARY 
PROPERTIES
def words_often(freqs, minTimes):
    result = []
    done = False
    while not done:
temp = most_common_words(freqs)
if temp[1] >= minTimes:
result.append(temp)for w in temp[0]:
del(freqs[w])
else:
done = True
    return result   
print(words_often(b
eatles, 5))
6.0001	LECTURE	6	 53	FIBONACCI RECURSIVE CODE
def fib(n):
    if n == 1:
return 1
    elif n == 2:
return 2
    else:
return fib(n-1) + fib(n-2)
§	two	base	cases	
§	calls	itself	twice	§	t"
"his	code	is	ineﬃcient	
6.0001	LECTURE	6	 54	INEFFICIENT FIBONACCI 
fib(n) = fib(n-1) + fib(n-2)  
§	recalcula0ng	the	same	values	many	Smes!	
§	could	keep	 track	of	already	calculated	values	
6.0001	LECTURE	6	 55	fib(5) 
fib(4) fib(3) 
fib(3) fib(2) fib(1) 
fib(2) fib(1) fib(2) 
FIBONACCI WITH A 
DICTIONARY
def fib_efficient(n, d):
    if n in d:
return d[n]
    else:
ans = fib_efficient(n-1, d) + fib_efficient(n-2, d)d[n] = ansreturn ans
d = {1:1, 2:2}print(fib_efficient(6, d))
§	do	a	lookup	ﬁrst	in	case	a"
"lready	calculated	the	value	
§	modify	dic0onary	as	progress	through	funcSon	calls	
6.0001	LECTURE	6	 56	EFFICIENCY GAINS
§Calling	ﬁb(34)	results	in	11,405,773	recursive	calls	to
the	procedure	
§Calling	ﬁb_eﬃcient(34)	results	in	65	recursive	calls	to
the	procedure	
§	Using	dicSonaries	to	capture	intermediate	results	can	
be	very	eﬃcient	
§	But	note	that	this	only	works	for	procedures	without	
side	eﬀects	(i.e.,	the	procedure	will	always	produce	the	
same	result	for	a	speciﬁc	argument	independent	of	any	othe"
"r	computaSons	between	calls)	
6.0001	LECTURE	6	 57MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall 2016
For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms ."
"TESTING, DEBUGGING, 
EXCEPTIONS, ASSERTIONS
(download slides and . pyfiles and follow along!)
6.0001 LECTURE 7
6.0001 LECTURE 7 1WE AIM FOR HIGH QUALITY –
AN ANALOGY WITH SOUP
You are making soup but bugs keep falling in from the 
ceiling. What do you do?
check soup for bugs
•testing
keep lid closed
•defensive 
programming
clean kitchen
•eliminate source 
of bugs
Analogy thanks to Prof Srini Devadas
6.0001 LECTURE 7 2DEFENSIVE PROGRAMMING
•Write specifications for functions
•Modularize programs
•Check co"
"nditions on inputs/outputs (assertions)
TESTING/VALIDATION
•Compare input/output 
pairs to specification
•“It’s not working!”
•“How can I break my 
program?”DEBUGGING
•Study events leading up 
to an error
•“Why is it not working?”
•“How can I fix my 
program?”
6.0001 LECTURE 7 3SET YOURSELF UP FOR EASY 
TESTING AND DEBUGGING
from the start , design code to ease this part
break program up into modules that can be tested 
and debugged individually
document constraints on modules
•what do you expect the inp"
"ut to be?
•what do you expect the output to be?
document assumptions behind code design
6.0001 LECTURE 7 4WHEN ARE YOU READY TO 
TEST?
ensure code runs
•remove syntax errors
•remove static semantic errors
•Python interpreter can usually find these for you
have a set of expected results
•an input set
•for each input, the expected output
6.0001 LECTURE 7 5CLASSES OF TESTS
Unit testing
•validate each piece of program
•testing each function separately
Regression testing
•add test for bugs as you find them
"
"•catch reintroduced errors that were previously fixed
Integration testing
•does overall program work?
•tend to rush to do this
6.0001 LECTURE 7 6TESTING APPROACHES
intuition about natural boundaries to the problem
defis_bigger (x, y):
"""""" Assumes x and y are ints
Returns True if y is less than x, else False """"""
•can you come up with some natural partitions?
if no natural partitions, might do random testing
•probability that code is correct increases with more tests
•better options below
black box testin"
"g
•explore paths through specification
glass box testing
•explore paths through code
6.0001 LECTURE 7 7defsqrt(x, eps):
"""""" Assumes x, eps floats, x >= 0, eps > 0
Returns res such that x -eps <= res*res <= x+eps""""""
designed without looking at the code
can be done by someone other than the implementer to 
avoid some implementer biases
testing can be reused if implementation changes
paths through specification 
•build test cases in different natural space partitions
•also consider boundary conditions (em"
"pty lists, singleton 
list, large numbers, small numbers)BLACK BOX TESTING
6.0001 LECTURE 7 8defsqrt(x, eps):
"""""" Assumes x, eps floats, x >= 0, eps > 0
Returns res such that x -eps <= res*res <= x+eps""""""BLACK BOX TESTING
6.0001 LECTURE 7 9CASE x eps
boundary 0 0.0001
perfect square 25 0.0001
less than 1 0.05 0.0001
irrational square root 2 0.0001
extremes 2 1.0/2.0**64.0
extremes 1.0/2.0**64.0 1.0/2.0**64.0
extremes 2.0**64.0     1.0/2.0**64.0
extremes 1.0/2.0**64.0 2.0**64.0
extremes 2.0**64.0     2.0**64"
".0GLASS BOX TESTING
use code directly to guide design of test cases 
called path -complete if every potential path through 
code is tested at least once
what are some drawbacks of this type of testing?
•can go through loops arbitrarily many times
•missing paths
guidelines 
•branches
•for loops
•while loops
6.0001 LECTURE 7 10GLASS BOX TESTING
defabs(x):
"""""" Assumes x is an int
Returns x if x>=0 and –x otherwise """"""
if x < -1:
return –x
else:
return x
a path -complete test suite could miss a bug
path -"
"complete test suite: 2 and -2
but abs( -1) incorrectly returns -1
should still test boundary cases
6.0001 LECTURE 7 11DEBUGGING
steep learning curve
goal is to have a bug -free program
tools
•built in to IDLE and Anaconda
•Python Tutor
•print statement
•use your brain, be systematic in your hunt
6.0001 LECTURE 7 12PRINT STATEMENTS
good way to test hypothesis
when to print
•enter function
•parameters
•function results
use bisection method
•put print halfway in code
•decide where bug may be depending "
"on values
6.0001 LECTURE 7 13DEBUGGING STEPS
study program code
•don’t ask what is wrong
•ask how did I get the unexpected result 
•is it part of a family?
scientific method
•study available data
•form hypothesis
•repeatable experiments
•pick simplest input to test with
6.0001 LECTURE 7 14ERROR MESSAGES –EASY
trying to access beyond the limits of a list
test = [1,2,3] then      test[4] IndexError
trying to convert an inappropriate type
int(test) TypeError
referencing a non -existent variable 
a Name"
"Error
mixing data types without appropriate coercion
'3'/4 TypeError
forgetting to close parenthesis, quotation, etc. 
a= len([1,2,3]
print(a) SyntaxError
6.0001 LECTURE 7 15LOGIC ERRORS -HARD
think before writing new code
draw pictures, take a break
explain the code to 
•someone else
•a rubber ducky
6.0001 LECTURE 7 16DON’T DO
•Write entire program
•Test entire program
•Debug entire program•Write a function
•Test the function, debug the function
•Write a function
•Test the function, debug the functi"
"on
•*** Do integration testing ***
•Change code
•Remember where bug was
•Test code
•Forget where bug was or what change 
you made
•Panic•Backup code
•Change code
•Write down potential bug in a 
comment
•Test code
•Compare new version with old 
version
6.0001 LECTURE 7 17EXCEPTIONS AND ASSERTIONS
what happens when procedure execution hits an 
unexpected condition ?
get an exception … to what was expected
•trying to access beyond list limits 
test = [1,7,4]
test[4] IndexError
•trying to convert an inapprop"
"riate type 
int(test) TypeError
•referencing a non -existing variable 
a NameError
•mixing data types without coercion 
'a'/4 TypeError
6.0001 LECTURE 7 18OTHER TYPES OF EXCEPTIONS
already seen common error types:
•SyntaxError : Python can’t parse program
•NameError : local or global name not found
•AttributeError : attribute reference fails
•TypeError : operand doesn’t have correct type
•ValueError : operand type okay, but value is illegal
•IOError : IO system reports malfunction (e.g. file not 
found "
")
6.0001 LECTURE 7 19DEALING WITH EXCEPTIONS
Python code can provide handlers for exceptions
try:
a = int(input(""Tell me one number:""))
b = int(input(""Tell me another number:""))
print(a/b)
except:
print(""Bug in user input ."")
exceptions raised by any statement in body of try are 
handled by the except statement and execution continues 
with the body of the except statement
6.0001 LECTURE 7 20HANDLING SPECIFIC 
EXCEPTIONS
have separate except clauses to deal with a particular 
type of exception
try:
a = i"
"nt(input(""Tell me one number: ""))
b = int(input(""Tell me another number: ""))
print(""a/b = "", a/b)
print(""a+b= "", a+b)
except ValueError :
print(""Could not convert to a number ."")
except ZeroDivisionError :
print(""Can't divide by zero"")
except:
print(""Something went very wrong ."")
6.0001 LECTURE 7 21OTHER EXCEPTIONS
else:
•body of this is executed when execution of associated 
try body completes with no exceptions
finally :
•body of this is always executed after try ,  else and 
except clauses, even if the"
"y raised another error or 
executed a break , continue or return
•useful for clean -up code that should be run no matter 
what else happened (e.g. close a file)
6.0001 LECTURE 7 22WHAT TO DO WITH 
EXCEPTIONS?
what to do when encounter an error?
fail silently : 
•substitute default values or just continue
•bad idea! user gets no warning
return an “error” value
•what value to choose?
•complicates code having to check for a special value
stop execution, signal error condition
•in Python: raise an exception"
"
raise Exception(""descriptive string"")
6.0001 LECTURE 7 23EXCEPTIONS AS CONTROL 
FLOW
don’t return special values when an error occurred 
and then check whether ‘error value’ was returned
instead, raise an exception when unable to produce a 
result consistent with function’s specification
raise <exceptionName >(<arguments>)
raise ValueError (""something is wrong"")
6.0001 LECTURE 7 24EXAMPLE: RAISING AN 
EXCEPTION
defget_ratios (L1, L2):
"""""" Assumes: L1 and L2 are lists of equal length of numbers
Returns: a"
" list containing L1[ i]/L2[i] """"""
ratios = []
for index in range(len(L1)):
try:
ratios.append (L1[index]/L2[index])
except ZeroDivisionError :
ratios.append (float('nan')) #nan = not a number
except:
raise ValueError ('get_ratios called with bad arg')
return ratios
6.0001 LECTURE 7 25EXAMPLE OF EXCEPTIONS
assume we are given a class list for a subject: each 
entry is a list of two parts
•a list of first and last name for a student
•a list of grades on assignments
create a new class list , with name, grade"
"s, and an 
average
6.0001 LECTURE 7 26test_grades = [[['peter', 'parker'], [80.0, 70.0, 85.0]], 
[['bruce', 'wayne'], [100.0, 80.0, 74.0 ]]]
[[['peter', 'parker'], [80.0, 70.0, 85.0], 78.33333 ], 
[['bruce', 'wayne'], [100.0, 80.0, 74.0], 84.666667]]]EXAMPLE 
CODE
defget_stats (class_list ):
new_stats = []
for eltin class_list :
new_stats.append ([elt[0], elt[1], avg(elt[1])])
return new_stats
defavg(grades):
return sum(grades)/ len(grades)
6.0001 LECTURE 7 27[[['peter', 'parker'], [80.0, 70.0, 85.0]], 
[['"
"bruce', 'wayne'], [100.0, 80.0, 74.0]]]ERROR IF NO GRADE FOR A 
STUDENT
if one or more students don’t have any grades , 
get an error
test_grades = [[['peter', 'parker'], [10.0, 5.0, 85.0]], 
[['bruce', 'wayne'], [10.0, 8.0, 74.0]],
[['captain', ' america'], [8.0,10.0,96.0 ]],
[['deadpool '], []]]
get ZeroDivisionError : float division by zero
because try to 
return sum(grades)/ len(grades)
6.0001 LECTURE 7 28OPTION 1: FLAG THE ERROR 
BY PRINTING A MESSAGE
decide to notify that something went wrong with "
"a msg
defavg(grades):
try:
return sum(grades)/ len(grades)
except ZeroDivisionError :
print('warning: no grades data')
running on some test data gives
warning: no grades data
[[['peter', 'parker'], [10.0, 5.0, 85.0], 15.41666666 ], 
[['bruce', 'wayne'], [10.0, 8.0, 74.0], 13.83333334 ], 
[['captain', ' america'], [8.0, 10.0, 96.0], 17.5 ],
[['deadpool '], [], None ]]
6.0001 LECTURE 7 29OPTION 2: CHANGE THE POLICY
decide that a student with no grades gets a zero
defavg(grades):
try:
return sum(grades)/ len"
"(grades)
except ZeroDivisionError :
print('warning: no grades data')
return 0.0
running on some test data gives
warning: no grades data
[[['peter', 'parker'], [10.0, 5.0, 85.0], 15.41666666], 
[['bruce', 'wayne'], [10.0, 8.0, 74.0], 13.83333334], 
[['captain', ' america'], [8.0, 10.0, 96.0], 17.5],
[['deadpool '], [], 0.0]]
6.0001 LECTURE 7 30ASSERTIONS
want to be sure that assumptions on state of 
computation are as expected
use an assert statement to raise an 
AssertionError exception if assumptions no"
"t met
an example of good defensive programming
31 6.0001 LECTURE 7EXAMPLE
defavg(grades):
assert len(grades) != 0, 'no grades data'
return sum(grades)/ len(grades)
raises an AssertionError if it is given an empty list for 
grades
otherwise runs ok
32 6.0001 LECTURE 7ASSERTIONS AS DEFENSIVE 
PROGRAMMING
assertions don’t allow a programmer to control 
response to unexpected conditions
ensure that execution halts whenever an expected 
condition is not met
typically used to check inputs to functions, but "
"can be 
used anywhere
can be used to check outputs of a function to avoid 
propagating bad values
can make it easier to locate a source of a bug
33 6.0001 LECTURE 7WHERE TO USE ASSERTIONS?
goal is to spot bugs as soon as introduced and make 
clear where they happened
use as a supplement to testing
raise exceptions if users supplies bad data input
use assertions to
•check types of arguments or values
•check that invariants on data structures are met
•check constraints on return values
•check for violat"
"ions of constraints on procedure (e.g. no 
duplicates in a list)
34 6.0001 LECTURE 7MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"8. Iteration: Strings  
Topics:  
  
 Using Methods from the string class  
 
 Iterating through a string with for Iterating Through a String   
Two problems we cannot easily solve : 
 
1.Given a string s, assign to t the “reversed” 
string.     ‘abcd’  ‘dcba’ 
 
2.  Given a string s, how many digit characters 
does i t contain?   ‘1or2or3’  3   The Reverse String Problem   
 
s =  ‘abcd’ 
t = ‘’ 
for c in s: 
    t = c + t  
   s -> ‘abcd’ 
‘dcba’ t -> 
How does the  for loop work?  The Number -of-Digits"
" Problem   
 
s =  ‘2x78y’  
n = 0 
for c in s: 
   if c.isdigit (): 
      n=n+1 
   s -> ‘2x78y’ 
 3  n -> 
How does the for loop work?    
 
s = ‘abcd’ 
for c in s: 
   print c 
      a 
 b 
 c 
 d                 
In this example, the “for -loop” variable is  c. 
One at a time, it takes on the value of each  
character in s.    Using for to Traverse a String  
Character -by-Character   
Output:  The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd"
"’ 
 ‘’ t -> 
At the start of the loop, c is assigned  
the zeroth  character in s.   ‘abcd’ 
 ‘a’  c -> The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘a’  c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘a’  t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘a’  "
"c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t  
   s ->  ‘abcd’ 
 ‘a’  t -> 
The next time through the loop, c is assigned  
the first character in s.   ‘abcd’ 
 ‘b’  c -> The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘a’  t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘b’  c ->                              The Reverse String Problem   
 
 s ="
"  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘ba’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘b’  c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘ba’ t -> 
The next time through the loop, c is assigned  
the second character in s.   ‘abcd’ 
 ‘c’  c -> The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘a"
"bcd’ 
 ‘cba’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘c’  c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
 
   s ->  ‘abcd’ 
 ‘ba’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘c’  c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘cba’ t -> 
The last time through the loop, c is assigned "
" 
the third character in s.   ‘abcd’ 
 ‘d’  c -> The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘cba’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘d’  c ->                              The Reverse String Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘dcba’ t -> 
The loop body is executed using that value in c.  ‘abcd’ 
 ‘d’  c ->                              The Reverse Stri"
"ng Problem   
 
 s =  ‘abcd’ 
 t = ‘’ 
 for c in s: 
    t = c + t  
 print t 
   s ->  ‘abcd’ 
 ‘dcba’ t -> 
The string has been traversed. The iteration 
ends. The next statement after the loop is 
executed. Indentation important.                                dcba                Output:  for-loop Mechanics  
for <loop variable> in <string>:  
 
             Loop Body        
 
If the string has length n, then the  
loop body is executed n times.  for-loop Mechanics  
for x in y: 
 
           Loop Body "
"       
 
Let  x = y[0] and then execute the loop body.  
Let  x = y[1] and then execute the loop body.  
Let  x = y[2] and then execute the loop body.  
              etc 
Let  x = y[n-1] and then execute the loop body.  Function for Reversing Strings   
def Reverse(s):  
   """""" Returns a string that is obtained  
   from s by reversing the order of its  
   characters.  
 
   Precondition: s is a string.""""""  
     
   t = ‘’       # The empty string  
   for c in s:  
       t = c+t  # Repeated concatenat"
"ion  
   return t  The Number -of-Digits Problem  
Given a string s, how many of its  
characters are digit characters?  
 
‘a10b20c30d40’    8 The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1 
print n 
   s -> ‘2z78y’ 
 0  n -> 
 ‘2z78y’ 
x ->  ‘2’  
At the start of the loop, x is assigned  
the zeroth  character in s. The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s"
" -> ‘2z78y’ 
 0  n -> 
 ‘2z78y’ 
x ->  ‘2’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 1  n -> 
 ‘2z78y’ 
x ->  ‘2’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
s =  ‘2z78y’"
"  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1 
print n 
   s -> ‘2z78y’ 
 1  n -> 
 ‘2z78y’ 
x ->  ‘z’  
The next time through the loop, x is assigned  
the first character in s. The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 1  n -> 
 ‘2z78y’ 
x ->  ‘z’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits P"
"roblem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1 
print n 
   s -> ‘2z78y’ 
 1  n -> 
 ‘2z78y’ 
x ->  ‘7’  
The next time through the loop, x is assigned  
the second character in s. The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 1  n -> 
 ‘2z78y’ 
x ->  ‘7’  
The loop body is executed using that value in x.                              
                                       "
"  The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 2  n -> 
 ‘2z78y’ 
x ->  ‘7’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1 
print n 
   s -> ‘2z78y’ 
 2  n -> 
 ‘2z78y’ 
x ->  ‘8’  
The next time through the loop, x is assigned  
"
"the third character in s. The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 2  n -> 
 ‘2z78y’ 
x ->  ‘8’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 3  n -> 
 ‘2z78y’ 
x ->  ‘8’  
The lo"
"op body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1 
print n 
   s -> ‘2z78y’ 
 3  n -> 
 ‘2z78y’ 
x ->  ‘y’  
The next time through the loop, x is assigned  
the fourth character in s. The Number -of-Digits Problem   
 
s =  ‘2z78y’  
n = 0 
for x in s: 
   if x.isdigit (): 
      n=n+1        
print n            
   s -> ‘2z78y’ 
 3  n -> 
 ‘2"
"z78y’ 
x ->  ‘y’  
The loop body is executed using that value in x.                              
                                         The Number -of-Digits Problem   
 
 s =  ‘2z78y’  
 n = 0 
 for x in s: 
    if x.isdigit (): 
       n=n+1        
  
 print n         
   s -> ‘2z78y’ 
 3  n -> 
The string has been traversed. The iteration 
ends. The next statement after the loop is 
executed. Indentation important.                               
                                            3          "
"       Output:  Function for Counting Digits   
def nDigits(s): 
  """""" Returns an int whose value is the 
number of digit characters that are in 
s. 
 
  Precondition: s is a string.""""""  
  n = 0; 
  for c in s:  
      # Increment n if c is a digit  
      if c.isdigit (): 
          n=n+1 
  return n  "
"OBJECT ORIENTED 
PROGRAMMING
(download slides and . pyfilesĂŶĚ follow along!)
6.0001 LECTURE 8
6.0001 LECTURE 8 1OBJECTS
Python supports many different kinds of data
1234 3.14159 ""Hello"" [1, 5, 7, 11, 13]
{""CA"": ""California"", ""MA"": ""Massachusetts""}
each is an object , and every object has:
•a type
•an internal data representation (primitive or composite)
•a set of procedures for interaction with the object
an object is an instance of a type
•1234 is an instance of an int
•""hello"" is an instance of a st"
"ring
6.0001 LECTURE 8 2OBJECT ORIENTED 
PROGRAMMING (OOP)
EVERYTHING IN PYTHON IS AN OBJECT (and has a type)
can create new objects of some type
can manipulate objects
can destroy objects
•explicitly using del or just “forget” about them
•python system will reclaim destroyed or inaccessible 
objects –called “garbage collection ”
6.0001 LECTURE 8 3WHAT ARE OBJECTS?
objects are a data abstraction
that captures…
(1) an internal representation 
•through data attributes
(2) an interface for 
interacting wit"
"h object 
•through methods 
(aka procedures/functions)
•defines behaviors but 
hides implementation
6.0001 LECTURE 8 4how are lists represented internally ? linked list of cells
L =
how to manipulate lists?
•L[i], L[i:j], +
•len(), min(), max(), del(L[i])
•L.append(),L.extend(),L.count(),L.index(), 
L.insert(),L.pop(),L.remove(),L.reverse (), L.sort()
internal representation should be private
correct behavior may be compromised if you manipulate 
internal representation directlyEXAMPLE: 
[1,2,3,4] has t"
"ype list
6.0001 LECTURE 8 51        -> 2       -> 3       -> 4       ->ADVANTAGES OF OOP
bundle data into packages together with procedures 
that work on them through well -defined interfaces
divide -and-conquer development
•implement and test behavior of each class separately
•increased modularity reduces complexity
classes make it easy to reuse code
•many Python modules define new classes
•each class has a separate environment (no collision on 
function names)
•inheritance allows subclasses to redefine"
" or extend a 
selected subset of a superclass’ behavior
6.0001 LECTURE 8 6make a distinction between creating a class and 
using an instance of the class
creating the class involves
•defining the class name
•defining class attributes
•for example, someone wrote code to implement a list class
using the class involves
•creating new instances of objects
•doing operations on the instances
•for example, L=[1,2] and len(L)
6.0001 LECTURE 8 7Implementing the class Using the class
CREATING AND USING YOUR 
OWN TY"
"PES WITH CLASSESDEFINE YOUR OWN TYPES
use the class keyword to define a new type
class Coordinate(object):
#define attributes here
similar to def, indent code to indicate which statements are 
part of the class definition
the word object means that Coordinate is a Python 
object and inherits all its attributes (inheritance next lecture) 
•Coordinate is a subclass of object
•object is a superclass of Coordinate
6.0001 LECTURE 8 8Implementing the class Using the classWHAT ARE ATTRIBUTES?
data and procedur"
"es that “ belong ” to the class
data attributes
•think of data as other objects that make up the class
•for example, a coordinate is made up of two numbers
methods (procedural attributes)
•think of methods as functions that only work with this class
•how to interact with the object
•for example you can define a distance between two 
coordinate objects but there is no meaning to a distance 
between two list objects
6.0001 LECTURE 8 9DEFINING HOW TO CREATE AN 
INSTANCE OF A CLASS
first have to define how t"
"o create an instance of 
object 
use a special method called __init__ to 
initialize some data attributes
class Coordinate(object):
def __init__(self, x, y):
self.x= x
self.y= y
6.0001 LECTURE 8 10Implementing the class Using the classACTUALLY CREATING AN 
INSTANCE OF A CLASS
c = Coordinate(3,4)
origin = Coordinate(0,0)
print(c.x)
print(origin.x)
data attributes of an instance are called instance 
variables
don’t provide argument for self , Python does this 
automatically
6.0001 LECTURE 8 11Implementing "
"the class Using the classWHAT IS A METHOD?
procedural attribute, like a function that works only 
with this class
Python always passes the object as the first argument
•convention is to use self as the name of the first 
argument of all methods
the “ .”operator is used to access any attribute
•a data attribute of an object
•a method of an object
6.0001 LECTURE 8 12DEFINE A METHOD FOR THE 
Coordinate CLASS
class Coordinate(object):
def __init__(self, x, y):
self.x= x
self.y= y
def distance(self , other):
"
"x_diff_sq = ( self.x-other.x)**2
y_diff_sq = (self.y-other.y)**2
return (x_diff_sq +y_diff_sq)**0.5
other than self and dot notation, methods behave just 
like functions (take params, do operations, return)
6.0001 LECTURE 8 13Implementing the class Using the classHOW TO USE A METHOD
def distance(self, other):
# code here
Using the class:
conventional way
c = Coordinate(3,4)
zero = Coordinate(0,0)print(c.distance(zero))
6.0001 LECTURE 8 14equivalent to 
c = Coordinate(3,4)zero = Coordinate(0,0 )
print(Coo"
"rdinate.distance(c, zero))Implementing the class Using the classPRINT REPRESENTATION OF 
AN OBJECT
>>> c = Coordinate(3,4) 
>>> print(c)
<__main__.Coordinate object at 0x7fa918510488>
uninformative print representation by default
define a __str__method for a class
Python calls the __str__ method when used with 
print on your class object
you choose what it does! Say that when we print a 
Coordinate object, want to show
>>> print(c)
<3,4>
6.0001 LECTURE 8 15DEFINING YOUR OWN PRINT 
METHOD
class Coordinat"
"e(object):
def __init__(self, x, y):
self.x= x
self.y= y
defdistance(self, other):
x_diff_sq = (self.x-other.x)**2
y_diff_sq = (self.y-other.y)**2
return (x_diff_sq + y_diff_sq)**0.5
def __str__(self):
return ""<""+str( self.x)+"",""+str( self.y)+"">""
6.0001 LECTURE 8 16Implementing the class Using the classWRAPPING YOUR HEAD 
AROUND TYPES AND CLASSES
can ask for the type of an object instance
>>> c = Coordinate(3,4)
>>> print(c)
<3,4>
>>> print(type(c))
<class __ main__.Coordinate>
this makes sense since
>>> "
"print(Coordinate)
<class __ main__.Coordinate>
>>> print(type(Coordinate))
<type 'type'>
use isinstance() to check if an object is a Coordinate
>>> print(isinstance (c, Coordinate ))
True
6.0001 LECTURE 8 17Implementing the class Using the classSPECIAL OPERATORS
+, -, ==, <, >, len(), print, and many others
https ://docs.python.org/3/reference/datamodel.html#basic -customization
like print , can override these to work with your class
define them with double underscores before/after
__add__(self, other) "
"self + other
__sub__(self, other) self -other
__eq__(self, other) self == other
__lt__(self, other) self < other
__len__(self) len(self)
__str__(self) print self
... and others
6.0001 LECTURE 8 18EXAMPLE: FRACTIONS
create a new type to represent a number as a fraction
internal representation is two integers
•numerator
•denominator
interface a.k.a. methods a.k.a how to interact with 
Fraction objects
•add, subtract
•print representation, convert to a float
•invert the fraction
the code for this is "
"in the handout, check it out!
6.0001 LECTURE 8 19THE POWER OF OOP
bundle together objects that share 
•common attributes and 
•procedures that operate on those attributes
use abstraction to make a distinction between how to 
implement an object vs how to use the object
build layers of object abstractions that inherit 
behaviors from other classes of objects
create our own classes of objects on top of Python’s 
basic classes
6.0001 LECTURE 8 20MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to"
" Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"PYTHON CLASSES 
and INHERITANCE
(download slides and . pyfiles ĂŶĚ follow along!)
6.0001 LECTURE 9
6.0001 LECTURE 9 1LAST TIME
abstract data types through classes 
Coordinate example
Fraction example
more on classes
•getters and setters
•information hiding
•class variables
inheritance
6.0001 LECTURE 9 2TODAYIMPLEMENTING USING
THE CLASS             vs THE CLASS
implementing a new 
object type with a class
•define the class
•define data attributes
(WHAT IS the object)
•define methods
(HOW TO use the obj"
"ect)
6.0001 LECTURE 9 3using the new object type in 
code
•create instances of the 
object type
•do operations with themwrite code from two different perspectivesCLASS DEFINITION INSTANCE 
OF AN OBJECT TYPE   vs   OF A CLASS
class name is the type
class Coordinate(object)
class is defined generically
•use self to refer to some 
instance while defining the 
class
(self.x–self.y)**2
•self is a parameter to 
methods in class definition 
class defines data and 
methods common across all 
instances
6.0001 LE"
"CTURE 9 4instance is one specific object
coord= Coordinate(1,2)
data attribute values vary 
between instances
c1 = Coordinate(1,2)
c2 = Coordinate(3,4)
•c1 andc2have different data 
attribute values c1.x and c2.x
because they are different 
objects
instance has the structure of 
the classWHY USE OOP AND 
CLASSES OF OBJECTS?
•mimic real life
•group different objects part of the same type
6.0001 LECTURE 9 5
Image Credits, clockwise from top: Image Courtesy Harald Wehner, in the public Domain. Image Courtes"
"y MTSOfan , CC- BY-NC-SA. Image Courtesy Carlos Solana , license CC-
BY-NC-SA. Image Courtesy Rosemarie Banghart-Kovic , license CC- BY-NC-SA. Image Courtesy  Paul Reynolds , license CC-BY. Image Courtesy Kenny Louie , License CC- BY
WHY USE OOP AND 
CLASSES OF OBJECTS?
•mimic real life
•group different objects part of the same type
6.0001 LECTURE 9 6 6.0001 LECTURE 9 6
Image Credits, clockwise from top: Image Courtesy Harald Wehner, in the public Domain. Image Courtesy MTSOfan , CC- BY-NC-SA. Image Courtes"
"y Carlos Solana , license CC -
BY-NC-SA. Image Courtesy Rosemarie Banghart -Kovic , license CC -BY-NC-SA. Image Courtesy  Paul Reynolds , license CC -BY. Image Courtesy Kenny Louie , License CC-BYGROUPS OF OBJECTS HAVE 
ATTRIBUTES (RECAP)
data attributes
•how can you represent your object with data?
•what it is
•for a coordinate: x and y values
•for an animal: age, name
procedural attributes (behavior/operations/ methods )
•how can someone interact with the object?
•what it does
•for a coordinate: find di"
"stance between two
•for an animal: make a sound
6.0001 LECTURE 9 7HOW TO DEFINE A CLASS 
(RECAP)
class Animal(object):
def__init__(self, age):
self.age = age
self.name = None
myanimal = Animal(3)
6.0001 LECTURE 9 8GETTER AND SETTER METHODS
class Animal(object):
def__init__(self, age):
self.age = age
self.name = None
defget_age(self):
return self.age
defget_name (self):
return self.name
defset_age(self, newage):
self.age = newage
defset_name (self, newname=""""):
self.name = newname
def__str__(self):
return ""a"
"nimal:""+ str(self.name)+"":""+ str(self.age )
getters and setters should be used outside of class to 
access data attributes
6.0001 LECTURE 9 9AN INSTANCE and 
DOT NOTATION (RECAP)
instantiation creates an instance of an object
a = Animal(3)
dot notation used to access attributes (data and 
methods) though it is better to use getters and setters 
to access data attributes
a.age
a.get_age ()
6.0001 LECTURE 9 10INFORMATION HIDING
author of class definition may change data attribute 
variable names
class Ani"
"mal(object):
def__init__(self, age):
self.years = age
defget_age(self):
return self.years
if you are accessing data attributes outside the class and 
class definition changes , may get errors
outside of class, use getters and setters instead 
use a.get_age ()NOT a.age
•good style
•easy to maintain code
•prevents bugs
6.0001 LECTURE 9 11PYTHON NOT GREAT AT 
INFORMATION HIDING
allows you to access data from outside class definition
print(a.age)
allows you to write to data from outside class definition
a.a"
"ge= 'infinite'
allows you to create data attributes for an instance from 
outside class definition
a.size= ""tiny""
it’s not good style to do any of these! 
6.0001 LECTURE 9 12DEFAULT ARGUMENTS
default arguments for formal parameters are used if no 
actual argument is given
defset_name (self, newname=""""):
self.name = newname
default argument used here 
a = Animal(3)
a.set_name ()
print(a.get_name())
argument passed in is used here
a = Animal(3)
a.set_name (""fluffy "")
print(a.get_name ())
6.0001 LECTURE 9"
" 13HIERARCHIES
6.0001 LECTURE 9 14
Image Credits, clockwise from top: Image Courtesy Deeeep, CC -BY-NC. Image Image Courtesy MTSOfan , CC- BY-NC-SA. Image Courtesy Carlos Solana , license CC -BY-NC-SA. 
Image Courtesy Rosemarie Banghart -Kovic , license CC -BY-NC-SA. Image Courtesy  Paul Reynolds , license CC -BY. Image Courtesy Kenny Louie , License CC-BY. Courtesy 
Harald Wehner, in the public Domain. 
Animal
Cat RabbitHIERARCHIES
parent class
(superclass)
child class
(subclass)
•inherits all data Perso"
"n
and behaviors of 
parent class
•add more info
•add more behavior 
•override behaviorStudent
6.0001 LECTURE 9 15INHERITANCE:
PARENT CLASS
class Animal(object):
def__init__(self, age):
self.age = age
self.name = None
defget_age(self):
return self.age
defget_name (self):
return self.name
defset_age(self, newage):
self.age = newage
defset_name (self, newname=""""):
self.name = newname
def__str__(self):
return ""animal:""+ str(self.name)+"":""+ str(self.age )
6.0001 LECTURE 9 16INHERITANCE: 
SUBCLASS 
class Cat(Anim"
"al):
defspeak(self):
print(""meow"")
def__str__(self):
return ""cat:""+str(self.name)+"":""+ str(self.age )
add new functionality with speak()
•instance of type Cat can be called with new methods
•instance of type Animal throws error if called with Cat ’s 
new method
__init__ is not missing, uses the Animal version
6.0001 LECTURE 9 17WHICH METHOD TO USE?
•subclass can have methods with same name as 
superclass
•for an instance of a class, look for a method name in 
current class definition
•if not found, look f"
"or method name up the hierarchy 
(in parent, then grandparent, and so on)
•use first method up the hierarchy that you found with 
that method name
6.0001 LECTURE 9 18class Person(Animal):
def__init__(self, name, age):
Animal.__ init__(self, age)
self.set_name (name)
self.friends = []
defget_friends (self):
return self.friends
defadd_friend (self, fname):
if fnamenot in self.friends :
self.friends.append (fname)
defspeak(self):
print(""hello"")
defage_diff (self, other):
diff = self.age -other.age
print(abs(di"
"ff), ""year difference"")
def__str__(self):
return ""person:""+ str(self.name)+"":""+ str(self.age )
6.0001 LECTURE 9 19import random
class Student(Person):
def__init__(self, name, age, major=None):
Person.__ init__(self, name, age)
self.major = major
defchange_major (self, major):
self.major = major
defspeak(self):
r = random.random ()
if r < 0.25:
print(""ihave homework"")
elif0.25 <= r < 0.5:
print(""ineed sleep"")
elif0.5 <= r < 0.75:
print(""ishould eat"")
else:
print(""iam watching tv"")
def__str__(self):
return ""s"
"tudent:""+ str(self.name)+"":""+ str(self.age )+"":""+str(self.major )
6.0001 LECTURE 9 20CLASS VARIABLES AND THE 
Rabbit SUBCLASS
class variables and their values are shared between all 
instances of a class
class Rabbit(Animal):
tag = 1
def__init__(self, age, parent1=None, parent2=None):
Animal.__ init__(self, age)
self.parent1 = parent1
self.parent2 = parent2
self.rid = Rabbit.tag
Rabbit.tag += 1
tag used to give unique id to each new rabbit instance
6.0001 LECTURE 9 21Rabbit GETTER METHODS
class Rabbit(Ani"
"mal):
tag = 1
def__init__(self, age, parent1=None, parent2=None):
Animal.__ init__(self, age)
self.parent1 = parent1
self.parent2 = parent2
self.rid = Rabbit.tag
Rabbit.tag += 1
defget_rid(self):
return str(self.rid ).zfill(3)
defget_parent1(self):
return self.parent1
defget_parent2(self):
return self.parent2
6.0001 LECTURE 9 22WORKING WITH YOUR OWN 
TYPES
def__add__(self, other):
# returning object of same type as this class
return Rabbit(0, self, other)
define + operator between two Rabbit instances
•def"
"ine what something like this does: r4 = r1 + r2
where r1and r2are Rabbit instances
•r4is a new Rabbit instance with age 0
•r4has self as one parent and other as the other parent
•in __init__, parent1 and parent2 are of type Rabbit
6.0001 LECTURE 9 23recall Rabbit’s __init__(self, age, parent1=None, parent2=None)SPECIAL METHOD TO 
COMPARE TWO Rabbits
decide that two rabbits are equal if they have the same two 
parents
def__eq__(self, other):
parents_same = self.parent1.rid == other.parent1.rid \
and self.pa"
"rent2.rid == other.parent2.rid
parents_opposite = self.parent2.rid == other.parent1.rid \
and self.parent1.rid == other.parent2.rid
return parents_same or parents_opposite
compare ids of parents since ids are unique (due to class var)
note you can’t compare objects directly
•for ex. with  self.parent1 == other.parent1
•this calls the __eq__method over and over until call it on None and 
gives an AttributeError when it tries to do None.parent1
6.0001 LECTURE 9 24OBJECT ORIENTED 
PROGRAMMING
create your ow"
"n collections of data
organize information
division of work
access information in a consistent manner
add layers of complexity
like functions, classes are a mechanism for 
decomposition and abstraction in programming
6.0001 LECTURE 9 25MIT OpenCourseWare
https://ocw.mit.edu
6.0001 Introduction to Computer Science and Programming in Python
Fall  2016
For information about citing these materials or our Terms of Use, visit: https:// ocw.mit.edu/terms ."
"9A. Iteration with range 
Topics:  
 
 Using for with range 
       Summation  
   Computing Min’s  
 Functions and for -loops  
 A Graphics Applications    
 
s = ‘abcd’ 
for c in s: 
   print c 
      a 
 b 
 c 
 d                 
In this example, the “for -loop” variable is  c. 
One at a time, it takes on the value of each  
character in s.    Iterating Through a String   
Output:  
We learned about this in the previous lecture.  Iterating Through a Range   
  
 
n = 4 
for k in range(n):  
   print k 
"
"      0 
 1 
 2 
 3                 Output:  
How does this work?  What does range(n) mean?  Note the Similarities   
   
n = 4 
for k in range(n):  
   print k 
   
   0 
 1 
 2 
 3                 Output:   
s = ‘abcd’ 
for c in s: 
   print c 
   
Output:     a 
 b 
 c 
 d                 Summation is a Good Example    
n = 4 
s = 0 
for k in range(n):  
    x = 2**k  
    s = s + x  
print s 
1 + 2 + 4 + 8 =  15    15                 Output:  
We are repeating the purple box 4 times           for-loop M"
"echanics with range 
for k in range(4):  
 
           Loop Body        
 
Let  k = 0 and then execute the loop body.  
Let  k = 1 and then execute the loop body.  
Let  k = 2 and then execute the loop body.  
Let  k = 3 and then execute the loop body.  
 
 k is called the loop variable a.k.a. the count variable  Summation    
n = 4 
s = 0 
for k in range(n):  
    x = 2**k  
    s = s + x  
print s 
1 + 2 + 4 + 8 =  15    15                 Output:  
Let’s derive this code. It’s about adding up powers of t"
"wo  Summation: How Do We Do It?   
Let’s add up powers of 2…  
 
  1 = 1 
  3 = 1 + 2  
  7 = 1 + 2 + 4  
       15 = 1 + 2 + 4 + 8  
 
       And so on  
 
Do we “start from scratch” each time we generate a new sum?  Summation   
Let’s add up powers of 2…  
 
  1 = 1 
  3 = 1 + 2 
  7 = 1 + 2 + 4 
       15 = 1 + 2 + 4 + 8 
        
       And so on  
 
Nope! We keep a “running sum” into which we add powers of 2   
 
  1 = 0 + 1 
  3 = 1 + 2 
  7 = 3 + 4 
       15 = 7   + 8 
        
       And so on  
 S"
"ummation   
s = 0 
x = 2**0  
s = s+x 
x = 2**1  
s = s+x 
x = 2**2  
s = s+x 
x = 2***3  
s = s+x 
 1 = 0 + 1 
 
3 = 1 + 2 
 
7 = 3 + 4 
 
15 = 7 + 8       
 Summation   
s = 0 
x = 2**0  
s = s+x 
x = 2**1  
s = s+x 
x = 2**2  
s = s+x 
x = 2**3  
s = s+x 
 1 = 0 + 1 
 
3 = 1 + 2 
 
7 = 3 + 4 
 
15 = 7 + 8       
 
Note the pattern              
            
            
            Summation   
s = 0 
x = 2**0  
s = s+x 
x = 2**1  
s = s+x 
x = 2**2  
s = s+x 
x = 2**3  
s = s+x 
 
Let’s step through the"
" mechanics of this for-loop             
            
            
            s = 0 
for k in range(4):  
    x = 2**k  
    s = s+x 
print s            1 + 2 + 4 + 8   
Initialize the running sum s. s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  0  s -> 1 + 2 + 4 + 8   
k ->  0  
We enter the loop.  
 
The loop variable k is set to zero  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  0  s -> 1 + 2 + 4 + 8   
k ->  0  
 k<4 is true so we execute the loop body  
wit"
"h that value of k. s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  0  s -> 
              1 + 2 + 4 + 8   
k ->  0  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  1  s -> 
              
 1  x -> 1 + 2 + 4 + 8   
k ->  0  
 k is increased by 1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  1  s -> 
 1  x -> 1 + 2 + 4 + 8   
k ->  1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  1  s -> 
 1  x -> 1 + 2 + 4 + 8   
k ->  1  
 "
"k<4 is true so we execute the loop body  
with that value of k. s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  1  s -> 
              
 1  x -> 1 + 2 + 4 + 8   
k ->  1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  3  s -> 
              
 2  x -> 1 + 2 + 4 + 8   
k ->  1  
 k is increased by 1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  3  s -> 
 2  x -> 1 + 2 + 4 + 8   
k ->  2  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
"
"print s  3  s -> 
 2  x -> 1 + 2 + 4 + 8   
k ->  2  
 k<4 is true so we execute the loop body  
with that value of k. s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  3  s -> 
              
 2  x -> 1 + 2 + 4 + 8   
k ->  2  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  7  s -> 
              
 4  x -> 1 + 2 + 4 + 8   
k ->  2  
 k is increased by 1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  7  s -> 
 4  x -> 1 + 2 + 4 + 8   
k ->  3  s = "
"0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  7  s -> 
 4  x -> 1 + 2 + 4 + 8   
k ->  3  
 k<4 is true so we execute the loop body  
with that value of k. s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  7  s -> 
 4  x ->               1 + 2 + 4 + 8   
k ->  3  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  15  s -> 
 8  x ->               1 + 2 + 4 + 8   
k ->  3  
 k is increased by 1  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
pri"
"nt s  15  s -> 
 8  x -> 1 + 2 + 4 + 8   
k ->  4  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  15  s -> 
 8  x -> 1 + 2 + 4 + 8   
k ->  4  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
print s  15  s -> 
 8  x -> 
 k<4 is False so we exit the loop body  
and proceed with the next  
statement after the loop.  1 + 2 + 4 + 8   
k ->  4  s = 0 
for k in range(4):  
    x = 2**k  
    s = s + x  
 print s  15  s -> 
 8  x -> 
   15                 Output  More General:  
 1 "
"+ 2 + 4 + … + 2**(n -1)  
n = any positive integer  
s = 0 
for k in range(n):  
    x = 2**k  
    s = s+x 
print s for-loop Mechanics with range 
for k in range(n):  
 
           Loop Body        
 
Let  k = 0 and then execute the loop body.  
Let  k = 1 and then execute the loop body.  
Let  k = 2 and then execute the loop body.  
            : 
Let  k = n-1 and then execute the loop body.  
 
 for-loop Mechanics with range 
for k in range(n):  
 
  x = 2**k  
  s = s+x        
 
Let  k = 0 and then exe"
"cute the loop body.  
Let  k = 1 and then execute the loop body.  
Let  k = 2 and then execute the loop body.  
            : 
Let  k = n-1 and then execute the loop body.  
 
   
Counting:  
A Special Type of Summation  How Many Integers < 10**6  are 
there that are divisible by  
2, 3, and 5?     
  33334                 Output:  N = 0 
for k in range(10**6):  
   if k%2==0 and k%3==0 and k%5==0:  
      N = N+1 
print N 
   
Using a For -Loop to  
Enumerate all Possibilities  “Left -Shifting” a String   "
"
  
 
s = ‘abcd’ 
n = len(s) 
for k in range(n):  
   t = s[k:]+s[:k]  
   print t 
      abcd 
 bcda 
 cdab 
 dabc                  Output:  
Iteration with strings doesn’t always have the form  “ for c in s”  If k==2 , then s[2:]+s[:2]  
looks like this:  ‘ cd’ + ‘ab’   
Looking for a Minimum  Assume this Function is Available  
def dist(t):  
   “““ Returns a float that is the distance  
 between Earth and a rogue asteroid  
  at time t (days).  
     
     PreC: t is a nonnegative float.""""""  
Problem : "
"Which of the numbers  
 
     dist(0), dist(1), dist(2),…,dist(100000)   
 
is the smallest and what is its value?  Solution  
d_min = dist(0)  
t_min = 0 
for t in range(100001):  
    d_current  = dist(t)  
    if d_current  < d_min: 
        # A new minimum is found  
        d_min = d_current  
        # Remember the day it occurred  
        t_min = t 
print t_min, d_min 
We need range(100001) because we want to check  dist(100000)     More on range 
In all our examples, the loop variable  
steps  from"
" 0 to some number.  
 
There are other options.  “Counting from 1”   
   
n = 4 
for k in range(n):  
   print k 
   
   0 
 1 
 2 
 3                 Output:   
n = 4 
for k in range(1,n):  
   print k 
   
Output:     1 
 2 
 3                 “Counting from Here to 
(Almost) There”   
  Here = 20  
There = 24  
for k in range( Here,There ): 
   print k 
   
Output:     20 
 21 
 22 
 23                 “Counting Down”   
  Here = 20  
There = 24  
for k in range(There,Here, -1): 
   print k 
   
Output: "
"    24 
 23 
 22 
 21                   
Now Let Us Look at  
Functions and For Loops  Recall From SimpleMath  
def sqrt(x): 
    x = float(x)  
    L = x  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    return L  
Let’s implement this with a for -loop For-Loop Implementation  
def sqrt(x): 
    x = float(x)  
    L = x  
    for k in range(5):  
       L = (L + x/L)/2  
    return L  def sqrt(x): 
    x = float(x)  
    L = x  
    L = (L +"
" x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    L = (L + x/L)/2  
    return L  Another For -Loop Implementation  
def sqrt(x): 
    x = float(x)  
    L = x  
    for k in range(5):  
       L = (L + x/L)/2  
    return L  def sqrt(x,N=5): 
    x = float(x)  
    L = x  
    for k in range(N):  
       L = (L + x/L)/2  
    return L  
Sample Call:    y = sqrt(12345,20 ) 
The optional argument allows you to determine the number of iterations.    
Now Let Us Look at  
Graphics"
" Procedures  
 and For Loops    Recall DrawRect  
DrawRect (xc,yc,s,s,FillColor =RED) 
DrawRect (xc,yc,s,s,FillColor =WHITE) This will draw a red square with side s  
and center ( xc,yc ): 
This will draw a white square with side s  
and center ( xc,yc ): Let’s Write a Procedure that  
Can Draw a Checkered Row  
Assume n squares  
each with side s.  
 
Assume (x0,y0) is  
the center of the  
leftmost square.  
 
Let c1 and c2 be the  
Colors of the first  
and second square  Solution  
def DrawRow(x0,y0,s,n"
",c1,c2):  
    # Center of next square is ( xc,yc) 
    xc = x0, yc = y0 
    for k in range(n):  
        % Draw the kth square 
        if k%2==0:  
           DrawRect (xc,yc,s,s,FillColor =c1) 
        else: 
           DrawRect (xc,yc,s,s,FillColor =c2) 
        xc = xc+s Now Let’s Draw This  This Draws an 8x8 Checker Board  
 y0 = -4; x0 = -3.5; n = 8; s = 1  
 #(x0,y0) is the center of the leftmost  
 # square in the next row to draw  
 for k in range(n):  
     # Draw the kth row 
     if k%2==0:  
"
"        DrawRow(x0,y0,s,n,RED,WHITE)  
     else: 
        DrawRow(x0,y0,s,n,WHITE,RED)  
     # The next row is s units higher  
     y0 = y0+s  "
"9B. Random Simulations  
Topics:  
 The class random 
 Estimating probabilities  
 Estimating averages  
 More occasions to practice iteration  
 
 
 The random  Module  
Contains functions that can be used   
in the design of random simulations.  
 
We will practice with these:  
 
  random.randint (a,b) 
  random.uniform (a,b) 
  random.normalvariate (mu,sigma ) 
 
 
  And as a fringe benefit, more practice with for -loops   Generating Random Integers  
 That is, we randomly select an element from the set"
" {a,a+1,…,b} and assign it to n   If a and b are initialized integers with a < b 
then  
               i = random.randint (a,b) 
 
assigns to  i a “random” integer that satisfies  
 
                             a <= i <= b 
 What Does “Random” Mean?  
import random  
for k in range(1000000):  
   i = random.randint (1,6) 
   print i 
 
The output would “look like” you rolled a dice  
one million times and recorded the outcomes.  
 
No discernible pattern.  
 
Roughly equal numbers of 1’s, 2’s, 3’s, 4’s, 5"
"’s, and 6’s.  Renaming Imported Functions  
import random  
for k in range(1000000):  
   i = random.randint (1,6) 
   print i 
 
from random import randint as randi 
for k in range(1000000):  
   i = randi(1,6) 
   print i 
 
 Handy when the names are long or when you just want to name things your way.   Random Simulation  
We can use randint  to simulate genuinely  
random events, e.g.,  
 
Flip a coin one million times and record the  
number of heads and tails.  
 Coin Toss  
from random import randint "
"as randi 
 
N = 1000000  
Heads = 0  
Tails = 0  
for k in range(N):  
    i = randi(1,2) 
    if i==1: 
      Heads = Heads+1  
    else: 
      Tails = Tails+1  
print  N, Heads, Tails  The “count” variables Heads  
and Tails  are initialized  
randi  returns  1 or 2  
Convention: “1” is heads  
Convention: “2” is tails  A Handy Short Cut  
Incrementing a variable is such a common  
calculation that Python supports a shortcut.  
 
These are equivalent:  
 
                    x += 1 
 
    x = x+1 
  x +="
" c    is equivalent to x = x+c Coin Toss  
from random import randint as randi 
 
N = 1000000  
Heads = 0  
Tails = 0  
for k in range(N):  
    i = randi(1,2) 
    if i==1: 
      Heads+=1  
    else: 
      Tails+=1  
print  N, Heads, Tails  The “count” variables Heads  
and Tails  are initialized  
randi  returns  1 or 2  
Convention: “1” is heads  
Convention: “2” is tails  Sample Outputs  
    N = 1000000  
Heads =  500636  
Tails =  499364  
    N = 1000000  
Heads =  499354  
Tails =  500646  
 Diffe"
"rent runs produce  
different results.  
 
This is consistent with 
what would happen if 
we physically tossed a 
coin one million times.  Estimating Probabilities  
You roll a dice. What is the probability  
that the outcome is “5”?  
 
Of course, we know the answer is 1/6. But  
let’s “discover” this through simulation.  
 Dice Roll  
from random import randint as randi 
N = 6000000  
count = 0  
for k in range(N):  
    i = randi(1,6) 
    if i==5: 
      count+=1  
prob = float(count)/float(N)  
print p"
"rob 
 
 N is the number of 
“experiments”.  
i is the outcome of 
an experiment  
prob   is the 
probability 
the outcome 
is 5 Dice Roll  
from random import randint as randi 
N = 6000000  
count = 0  
for k in range(N):  
    i = randi(1,6) 
    if i==5: 
      count+=1  
prob = float(count)/float(N)  
print prob 
 
 Output: 
             
 .166837  Discovery Through Simulation  
Roll three dice.  
 
What is the probability that the three  
outcomes are all different ?  
 
If you know a little math, you c"
"an do this  
without the computer. Let’s assume that  
we don’t know that math.  
 
 Solution  
N = 1000000  
count = 0  
for k in range(1,N+1):  
    d1 = randi(1,6) 
    d2 = randi(1,6) 
    d3 = randi(1,6) 
    if d1!=d2 and d2!=d3 and d3!=d1:  
        count +=1  
    if k%100000==0:  
       print k,float(count)/float(k)  
 Prints snapshots of the probability estimates every 100,000 trials   Note the  
3 calls to  
randi  Sample Output  
     k       count/k  
----------------------  
  100000     0.55"
"4080  
  200000     0.555125  
  300000     0.555443  
  400000     0.555512  
  500000     0.555882  
  600000     0.555750  
  700000     0.555901  
  800000     0.556142  
  900000     0.555841  
 1000000     0.555521  Note how we  
say “sample 
output” because 
if the script is 
run again, then 
we will get 
different 
results.  
 
Educated guess:  
true prob = 5/9  Generating Random Floats  
Problem:  
 
 Randomly pick a float in the interval 
 [0,1000].  
 
 What is the probability  that it is in 
 [1"
"00,500]?  
 
Answer = (500 -100)/(1000 -0) = .4  Generating Random Floats  
  The actual probability that x is equal to a or b is basically 0.  If a and b are initialized floats with a < b 
then  
               x = random.uniform (a,b) 
 
assigns to  x a “random” float that satisfies  
 
                          a <= x <= b  
 The Uniform Distribution  
Picture:  
 
 
 
The probability that  
 
              L <= random.uniform (a,b) <= R  
is true is  
                                   (R-L) / (b -a) a "
"R L b Illustrate the Uniform Distribution  
from random import uniform as randu 
N = 1000000  
a = 0; b = 1000; L = 100; R = 500  
count = 0  
for k in range(N):  
    x = randu(a,b) 
    if L<=x<=R:  
        count+=1      
prob = float(count)/float(N)  
fraction = float(R -L)/float(b -a) 
print prob,fraction  
Pick a float in the interval [0,1000]. What is the prob that it is in [100,500]?  Sample Output  
Estimated probability:  0.399928    
 
         (R-L)/(b-a) :  0.400000  Estimating Pi Using  
rando"
"m.uniform (a,b) 
Idea:  
 
 Set up a game whose outcome tells us  
 something about pi.  
 
 This problem solving strategy is called  
 Monte Carlo . It is widely used in certain 
areas of science and engineering.  
 
 
 The Game  
Throw darts at the  
2x2 cyan square that  
is centered at (0,0).  
 
If the dart lands in  
the radius -1 disk, then  
count that as a ”hit”.  3 Facts About the Game  
1. Area of square = 4  
 
2. Area of disk  is  pi 
since the radius is 1.  
 
3. Ratio of hits to throws 
shoul"
"d approximate 
pi/4  and so  
 
 
    4*hits/throws  “=“  pi  
 
 Example  
1000 throws  
 
776 hits  
 
Pi = 4*776/1000  
   =   3.104  When Do We Have a Hit?  
The boundary of the disk is given by  
                   
                              x**2 + y**2 = 1  
 
If (x,y) is the coordinate of the dart throw,  
then it is inside the disk if  
                              x**2+y**2 <= 1  
 
is True. Solution  
from random import uniform as randu 
N = 1000000  
Hits = 0  
for throws in range(N):  
    "
"x = randu(-1,1) 
    y = randu(-1,1) 
    if x**2 + y**2 <= 1 :  
        # Inside the unit circle  
        Hits += 1  
piEst = 4*float(Hits)/float(N)  Note the  
2 calls to  
randu  Repeatability of Experiments  
In science, whenever you make a discovery 
through experimentation, you must provide 
enough details for others to repeat the 
experiment.  
 
We have “discovered” pi through random 
simulation. How can others repeat our 
computation?  random.seed  
What we have been calling random numbers are  
"
"actually pseudo -random numbers . 
 
They pass rigorous statistical tests so that  
we can use them as if they are truly random.  
 
But  they are generated by a program and are  
anything but random.  
 
The  seed   function can be used to reset the  
algorithmic process that generates the pseudo  
random numbers.  Repeatable Solution  
from random import uniform as randu 
from random import seed 
N = 1000000; Hits = 0  
seed(0) 
for throws in range(N):  
    x = randu(-1,1); y = randu(-1,1) 
    if x**2 +"
" y**2 <= 1 :  
        Hits += 1  
piEst = 4*float(Hits)/float(N)  Now we will 
get the same 
answer every 
time Another Example  
Produce this  
“random square”  
design.  
 
Think: I toss post -its 
of different colors  
and sizes onto  
a table.  Solution Framework  
Repeat:  
       1. Position a square randomly in the  
   figure window.  
 
  2. Choose its side length randomly.  
 
  3. Determine its tilt randomly  
 
  4. Color it cyan, magenta, or, yellow  
   randomly.  Getting Started  
from rando"
"m import uniform as randu 
from random import randint as randi 
from SimpleGraphics  import *  
n = 10 
MakeWindow (n,bgcolor =BLACK) 
for k in range(400):  
    # Draw a random colored square  
    pass 
ShowWindow ()              Note the  
3 calls to  
randi  
“pass”  is a necessary place holder. Without it, this script will not run  Positioning the square  
x = randu(-n,n) 
y = randu(-n,n) The figure window is built from  
MakeWindow (n). 
 
A particular square with random center  
(x,y) will be located"
" using randu : The Size s of the square  
s = randu(0,n/3.0)  
 Let’s make the squares no bigger than  
n/3 on a side.  The tilt of the square  
t = randi(0,45) Pick an integer from 0 to 45 and 
rotate the square that many degrees.  The Color of the square  
i = randi(1,3) 
if i==1; 
   c = CYAN  
elif i==2: 
   c = MAGENTA  
else: 
   c = YELLOW  With probability 1/3, color it cyan  
With probability 1/3 color it magenta  
With probability 1/3, color it yellow.  The Final Loop Body  
x = randu(-n,n) 
y = r"
"andu(-n,n) 
s = randu(0,n/3.0)  
t = randi(0,45) 
i = randi(1,3) 
if i==1: 
   c = CYAN  
elif i==2: 
   c = MAGENTA  
else: 
   c = YELLOW  
DrawRect (x,y,s,s,tilt =t,FillColor =c) The side  The center  
The tilt  
The color  Stepwise Refinement  
Appreciate the problem -solving methodology  
just illustrated.  
 
It is called stepwise refinement . 
 
We started at the top level. A for -loop strategy  
was identified first. Then, one -by-one, we dealt  
with the location, size, tilt, and color issues.  
 A"
"nother Example: TriStick  
Pick three sticks each having a random  
length between zero and one.  
 
You win if you can form a triangle  
whose sides are the sticks. Otherwise  
you lose.  Win:  
Lose:  TriStick  The Problem to Solve  
Estimate the probability of winning a game of  
TriStick  by simulating a million games and  
counting the number of wins.  
 
We proceed using the strategy of step -wise 
refinement…  Pseudocode  
Initialize running sum variable.  
Repeat 1,000,000 times:  
      Play a game"
" of TriStick  by picking  
          the three sticks.  
      If you win  
          increment the running sum  
Estimate the probability of winning  
 
Pseudocode : Describing an algorithm in English but laying out  
its parts in python style  The Transition  
               Pseudocode  
 
                                                via  
                                             stepwise  
                                           refinement  
 
         Finished Python Code  First Refinement  
I"
"nitialize running sum variable.  
Repeat 1,000,000 times:  
      Play a game of TriStick  by picking  
          the three sticks.  
      If you win  
          increment the running sum  
Estimate the probability of winning  
 
Turn the loop -related stuff into Python  Next, Refine the Loop Body  
# Initialize running sum variable.  
wins = 0  
for n in range(1000000):  
      Play the nth game of TriStick  by  
              picking the three sticks.  
      If you win  
          increment the running "
"sum.  
# Estimate the prob of winning  
p = float(wins)/1000000  Refine the Loop Body  
 Play the nth game of TriStick  by picking 
the three sticks.  
 If you win  
      increment the running sum.  
 
a = randu(0,1) 
b = randu(0,1) 
c = randu(0,1) 
if a<=b+c and b<=a+c and c<=a+b:    
 wins +=1  
 The 3 sticks  Key Problem -Solving  
Strategy  
Progress from pseudocode  to Python  
through a sequence of refinements.  
 
Comments have an essential role during  
the transitions. They remain all the  
way to"
" the finished code.  Final “Random” Topic:  
The Normal Distribution  
Generating floats from  
the Normal Distribution  
 
If mu and sigma (positive) are floats , then 
  
        x = random.normalvariate (mu,sigma ) 
 
assigns to  x a “random” float sampled from the  
normal distribution with mean mu and standard 
deviation sigma  
 
                          
 Normal Distribution  
Mean =  0, Standard Deviation = 1  
Typical Situation: Test Scores  
from random import normalvariate  as randn 
for k in ra"
"nge(450):  
    x = randn(70,7) 
    print round(x)  
This would look like a report of test scores  
from a class of 450 students.  
 
The mean is approximately 70 and the standard  
deviation  is approximately 7.  More on Standard Dev  
Generate a million random numbers using  
 
  random.normalvariate (mu,sigma ) 
 
and confirm that the generated data has  
mean mu and std sigma  
 Checking Out randn 
N = 1000000; sum1 = 0; sum2 = 0  
mu = 70; sigma = 7  
for k in range(N):  
     x = randn(mu,sigma ) 
  "
"sum1 += x  
    sum2 += (x -mu)**2   
ApproxMean  = float(sum1)/float(N)          
ApproxSTD   = sqrt(float(sum2)/float(N))  
Sample Output:  70.007824       6.998934  Final Reminder  
randi , randu , and randn  are RENAMED  
versions of  
 
       random.randint  
  random.uniform  
  random.normalvariate  
 "
